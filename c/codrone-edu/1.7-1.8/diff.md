# Comparing `tmp/codrone_edu-1.7-py3-none-any.whl.zip` & `tmp/codrone_edu-1.8-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,29 +1,29 @@
-Zip file size: 140763 bytes, number of entries: 27
--rw-r--r--  2.0 unx    84260 b- defN 23-Feb-20 00:37 codrone_edu/protocol.py
--rw-r--r--  2.0 unx   135228 b- defN 23-Feb-20 00:38 codrone_edu/drone.py
--rw-r--r--  2.0 unx      102 b- defN 23-Feb-20 00:37 codrone_edu/__init__.py
--rw-r--r--  2.0 unx     2357 b- defN 23-Feb-20 00:37 codrone_edu/swarm.py
--rw-r--r--  2.0 unx    14115 b- defN 23-Feb-20 00:37 codrone_edu/system.py
--rw-r--r--  2.0 unx     6875 b- defN 23-Feb-20 00:37 codrone_edu/receiver.py
--rw-r--r--  2.0 unx     2772 b- defN 23-Feb-20 00:37 codrone_edu/storage.py
--rw-r--r--  2.0 unx     9206 b- defN 23-Feb-20 00:37 codrone_edu/update.py
--rw-r--r--  2.0 unx     4525 b- defN 23-Feb-20 00:37 codrone_edu/crc.py
--rw-r--r--  2.0 unx      120 b- defN 23-Feb-20 00:37 codrone_edu/__main__.py
--rw-r--r--  2.0 unx   157500 b- defN 23-Feb-20 00:37 codrone_edu/data/white.txt
--rw-r--r--  2.0 unx   157500 b- defN 23-Feb-20 00:37 codrone_edu/data/blue.txt
--rw-r--r--  2.0 unx   157500 b- defN 23-Feb-20 00:37 codrone_edu/data/lightblue.txt
--rw-r--r--  2.0 unx   157500 b- defN 23-Feb-20 00:37 codrone_edu/data/black.txt
--rw-r--r--  2.0 unx   157500 b- defN 23-Feb-20 00:37 codrone_edu/data/red.txt
--rw-r--r--  2.0 unx   157500 b- defN 23-Feb-20 00:37 codrone_edu/data/green.txt
--rw-r--r--  2.0 unx   157500 b- defN 23-Feb-20 00:37 codrone_edu/data/yellow.txt
--rw-r--r--  2.0 unx   157500 b- defN 23-Feb-20 00:37 codrone_edu/data/purple.txt
--rw-r--r--  2.0 unx       31 b- defN 23-Feb-20 00:37 codrone_edu/tools/__init__.py
--rw-r--r--  2.0 unx    30977 b- defN 23-Feb-20 00:37 codrone_edu/tools/parser.py
--rw-r--r--  2.0 unx     9206 b- defN 23-Feb-20 00:37 codrone_edu/tools/update.py
--rw-r--r--  2.0 unx       10 b- defN 23-Feb-20 00:43 codrone_edu-1.7.dist-info/DESCRIPTION.rst
--rw-r--r--  2.0 unx      505 b- defN 23-Feb-20 00:43 codrone_edu-1.7.dist-info/metadata.json
--rw-r--r--  2.0 unx       12 b- defN 23-Feb-20 00:43 codrone_edu-1.7.dist-info/top_level.txt
--rw-r--r--  2.0 unx       92 b- defN 23-Feb-20 00:43 codrone_edu-1.7.dist-info/WHEEL
--rw-r--r--  2.0 unx      397 b- defN 23-Feb-20 00:43 codrone_edu-1.7.dist-info/METADATA
--rw-r--r--  2.0 unx     2245 b- defN 23-Feb-20 00:43 codrone_edu-1.7.dist-info/RECORD
-27 files, 1563035 bytes uncompressed, 137241 bytes compressed:  91.2%
+Zip file size: 141192 bytes, number of entries: 27
+-rw-r--r--  2.0 unx    84260 b- defN 23-May-05 16:12 codrone_edu/protocol.py
+-rw-r--r--  2.0 unx   137302 b- defN 23-May-07 20:51 codrone_edu/drone.py
+-rw-r--r--  2.0 unx      102 b- defN 23-May-05 16:12 codrone_edu/__init__.py
+-rw-r--r--  2.0 unx     2357 b- defN 23-May-05 16:12 codrone_edu/swarm.py
+-rw-r--r--  2.0 unx    14115 b- defN 23-May-05 16:12 codrone_edu/system.py
+-rw-r--r--  2.0 unx     6875 b- defN 23-May-05 16:12 codrone_edu/receiver.py
+-rw-r--r--  2.0 unx     2772 b- defN 23-May-05 16:12 codrone_edu/storage.py
+-rw-r--r--  2.0 unx     9206 b- defN 23-May-05 16:12 codrone_edu/update.py
+-rw-r--r--  2.0 unx     4525 b- defN 23-May-05 16:12 codrone_edu/crc.py
+-rw-r--r--  2.0 unx      120 b- defN 23-May-05 16:12 codrone_edu/__main__.py
+-rw-r--r--  2.0 unx   157500 b- defN 23-May-05 16:12 codrone_edu/data/white.txt
+-rw-r--r--  2.0 unx   157500 b- defN 23-May-05 16:12 codrone_edu/data/blue.txt
+-rw-r--r--  2.0 unx   157500 b- defN 23-May-05 16:12 codrone_edu/data/lightblue.txt
+-rw-r--r--  2.0 unx   157500 b- defN 23-May-05 16:12 codrone_edu/data/black.txt
+-rw-r--r--  2.0 unx   157500 b- defN 23-May-05 16:12 codrone_edu/data/red.txt
+-rw-r--r--  2.0 unx   157500 b- defN 23-May-05 16:12 codrone_edu/data/green.txt
+-rw-r--r--  2.0 unx   157500 b- defN 23-May-05 16:12 codrone_edu/data/yellow.txt
+-rw-r--r--  2.0 unx   157500 b- defN 23-May-05 16:12 codrone_edu/data/purple.txt
+-rw-r--r--  2.0 unx       31 b- defN 23-May-05 16:12 codrone_edu/tools/__init__.py
+-rw-r--r--  2.0 unx    30977 b- defN 23-May-05 16:12 codrone_edu/tools/parser.py
+-rw-r--r--  2.0 unx     9206 b- defN 23-May-05 16:12 codrone_edu/tools/update.py
+-rw-r--r--  2.0 unx       10 b- defN 23-May-07 20:55 codrone_edu-1.8.dist-info/DESCRIPTION.rst
+-rw-r--r--  2.0 unx      495 b- defN 23-May-07 20:55 codrone_edu-1.8.dist-info/metadata.json
+-rw-r--r--  2.0 unx       12 b- defN 23-May-07 20:55 codrone_edu-1.8.dist-info/top_level.txt
+-rw-r--r--  2.0 unx       92 b- defN 23-May-07 20:55 codrone_edu-1.8.dist-info/WHEEL
+-rw-r--r--  2.0 unx      375 b- defN 23-May-07 20:55 codrone_edu-1.8.dist-info/METADATA
+-rw-r--r--  2.0 unx     2245 b- defN 23-May-07 20:55 codrone_edu-1.8.dist-info/RECORD
+27 files, 1565077 bytes uncompressed, 137670 bytes compressed:  91.2%
```

## zipnote {}

```diff
@@ -57,26 +57,26 @@
 
 Filename: codrone_edu/tools/parser.py
 Comment: 
 
 Filename: codrone_edu/tools/update.py
 Comment: 
 
-Filename: codrone_edu-1.7.dist-info/DESCRIPTION.rst
+Filename: codrone_edu-1.8.dist-info/DESCRIPTION.rst
 Comment: 
 
-Filename: codrone_edu-1.7.dist-info/metadata.json
+Filename: codrone_edu-1.8.dist-info/metadata.json
 Comment: 
 
-Filename: codrone_edu-1.7.dist-info/top_level.txt
+Filename: codrone_edu-1.8.dist-info/top_level.txt
 Comment: 
 
-Filename: codrone_edu-1.7.dist-info/WHEEL
+Filename: codrone_edu-1.8.dist-info/WHEEL
 Comment: 
 
-Filename: codrone_edu-1.7.dist-info/METADATA
+Filename: codrone_edu-1.8.dist-info/METADATA
 Comment: 
 
-Filename: codrone_edu-1.7.dist-info/RECORD
+Filename: codrone_edu-1.8.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## codrone_edu/drone.py

```diff
@@ -17,21 +17,20 @@
 from codrone_edu.protocol import *
 from codrone_edu.storage import *
 from codrone_edu.receiver import *
 from codrone_edu.system import *
 from codrone_edu.crc import *
 import PIL.Image
 import PIL.ImageDraw
-from pynput import keyboard
+# from pynput import keyboard
 import os
 import signal
 import pkg_resources
 
 
-
 def convertByteArrayToString(dataArray):
     if dataArray == None:
         return ""
 
     string = ""
 
     if (isinstance(dataArray, bytes)) or (isinstance(dataArray, bytearray)) or (not isinstance(dataArray, list)):
@@ -63,37 +62,38 @@
     :return: list of data resized to fit on controller screen
     """
     img = PIL.Image.open(image_file_name)
     controller_size = (127, 63)
     img = img.resize(controller_size)
     return list(img.getdata())
 
+
 class Drone:
 
-    def __on_press(self, key):
-        """
-        checks for key press on keyboard
-        :param key: the key that is pressed
-        :return: False to stop listener if esc pressed
-        """
-        if key == keyboard.Key.esc:
-            try:
-                self.emergency_stop()
-            finally:
-                os.kill(os.getpid(), signal.SIGTERM)
-                # stop listener
-                return False
+    # def __on_press(self, key):
+    #     """
+    #     checks for key press on keyboard
+    #     :param key: the key that is pressed
+    #     :return: False to stop listener if esc pressed
+    #     """
+    #     if key == keyboard.Key.esc:
+    #         try:
+    #             self.emergency_stop()
+    #         finally:
+    #             os.kill(os.getpid(), signal.SIGTERM)
+    #             # stop listener
+    #             return False
 
-    def __listen(self):
-        """
-        starts the keyboard listener
-        :return: None
-        """
-        listener = keyboard.Listener(on_press=self.__on_press)
-        listener.start()
+    # def __listen(self):
+    #     """
+    #     starts the keyboard listener
+    #     :return: None
+    #     """
+    #     listener = keyboard.Listener(on_press=self.__on_press)
+    #     listener.start()
 
     def __button_event(self, button):
         """
         Stores any button press event with a time stamp
         :param button:
         :return: N/A
         """
@@ -147,36 +147,45 @@
         self.joystick_data = [0, 0, 0, 0, 0, 0, 0, 0, 0]
         self.color_data = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
         self.trim_data = [0, 0, 0, 0, 0]
         self.waypoint_data = []
         self.previous_land = [0, 0]
         self.button_data = [0, 0, 0]
         self.init_press = 0
-        self.error_data = [0,0,0]
+        self.error_data = [0, 0, 0]
 
         # set the event handlers for the sensor requests
         self.setEventHandler(DataType.Altitude, self.update_altitude_data)
         self.setEventHandler(DataType.State, self.update_state_data)
         self.setEventHandler(DataType.Motion, self.update_motion_data)
         self.setEventHandler(DataType.Position, self.update_position_data)
         self.setEventHandler(DataType.RawFlow, self.update_flow_data)
         self.setEventHandler(DataType.Range, self.update_range_data)
         self.setEventHandler(DataType.Joystick, self.update_joystick_data)
         self.setEventHandler(DataType.CardColor, self.update_color_data)
         self.setEventHandler(DataType.Trim, self.update_trim_data)
-        self.setEventHandler(DataType.Button, self.__button_event)
+        # self.setEventHandler(DataType.Button, self.__button_event)
         self.setEventHandler(DataType.Error, self.update_error_data)
 
+        # fill values for the lists
+        self.get_altitude_data()
+        self.get_range_data()
+        self.get_position_data()
+        self.get_flow_data()
+        self.get_state_data()
+        self.get_motion_data()
+        self.get_trim_data()
+
         # Color classifier
         self.knn = neighbors.KNeighborsClassifier(n_neighbors=9)
         self.labels = []
         self.parent_dir = os.getcwd()
 
         # Threaded keyboard listener
-        self.__listen()
+        # self.__listen()
 
         for i in range(0, 36):
             self.monitorData.append(i)
 
         self._control = ControlQuad8()
 
         colorama.init()
@@ -188,15 +197,33 @@
               "\nFor more information go to: robolink.com/edu-controller-issue"
               "\n")
 
     def __del__(self):
 
         self.close()
 
-    def update_error_data(self,drone_type):
+    def get_sensor_data(self, delay=0.01):
+        self.sendRequest(DeviceType.Drone, DataType.Altitude)
+        time.sleep(delay)
+        self.sendRequest(DeviceType.Drone, DataType.Motion)
+        time.sleep(delay)
+        self.sendRequest(DeviceType.Drone, DataType.Position)
+        time.sleep(delay)
+        self.sendRequest(DeviceType.Drone, DataType.Range)
+        time.sleep(delay)
+        self.sendRequest(DeviceType.Drone, DataType.State)
+        time.sleep(delay)
+
+        sensor_data_list = []
+        sensor_data_list = self.altitude_data + self.motion_data \
+                           + self.position_data + self.range_data + self.state_data
+
+        return sensor_data_list
+
+    def update_error_data(self, drone_type):
         """
         ErrorFlagsForSensor -----------------------------------------------------------
 
         None_                                   = 0x00000000
 
         Motion_NoAnswer                         = 0x00000001    # Motion 센서 응답 없음
         Motion_WrongValue                       = 0x00000002    # Motion 센서 잘못된 값
@@ -234,35 +261,34 @@
         :return:
         """
 
         self.error_data[0] = time.time() - self.timeStartProgram
         self.error_data[1] = drone_type.errorFlagsForSensor
         self.error_data[2] = drone_type.errorFlagsForState
 
-
     def update_altitude_data(self, drone_type):
         """
         temperature	Float32	4 Byte	-	temp.(℃) Celsius
         pressure	Float32	4 Byte	-	pressure (Pascals)
         altitude	Float32	4 Byte	-	Converting pressure to elevation above sea level(meters)
         rangeHeight	Float32	4 Byte	-	Height value output from distance sensor (meters)
         """
 
         self.altitude_data[0] = time.time() - self.timeStartProgram
         self.altitude_data[1] = drone_type.temperature
         self.altitude_data[2] = drone_type.pressure
         self.altitude_data[3] = drone_type.altitude
         self.altitude_data[4] = drone_type.rangeHeight
 
-    def get_altitude_data(self, delay=0.005):
+    def get_altitude_data(self, delay=0.01):
         self.sendRequest(DeviceType.Drone, DataType.Altitude)
         time.sleep(delay)
         return self.altitude_data
 
-    def get_error_data(self, delay=0.005):
+    def get_error_data(self, delay=0.01):
         """
         Will get and print the current error state
         :param delay:
         :return:
         """
         self.sendRequest(DeviceType.Drone, DataType.Error)
         time.sleep(delay)
@@ -303,101 +329,104 @@
         inches per mercury
         torriceli
         atm
         :return: Returns pressure reading in set unit rounded by 2 decimal places
         '''
         pascals = self.get_altitude_data()[2]
         for i in range(3):
-            if pascals == 0: # check if the value is an error which would be 0
+            if pascals == 0:  # check if the value is an error which would be 0
                 pascals = self.get_altitude_data()[2]
-            else: # if not 0 then it is an ok value
+            else:  # if not 0 then it is an ok value
                 break
 
         if unit == "Pa":
             value = pascals
         elif unit == "KPa" or unit == "kPa" or unit == "kpa":
-            kiloPascals = pascals/1000
+            kiloPascals = pascals / 1000
             value = kiloPascals
         elif unit == "mB":
-            milliBars = pascals/100
+            milliBars = pascals / 100
             value = milliBars
         elif unit == "inHg":
-            inches_per_mercury = pascals/3386.39
+            inches_per_mercury = pascals / 3386.39
             value = inches_per_mercury
         elif unit == "torr":
-            torr = pascals/133.322
+            torr = pascals / 133.322
             value = torr
         elif unit == "atm":
-            atm = pascals/101325
+            atm = pascals / 101325
             value = atm
         else:
             print("error: get_pressure() input must be either: Pa KPa mB inHg torr atm, will default to Pascals")
             value = pascals
-        value =  round(value,2)
+        value = round(value, 2)
         return value
 
     def get_elevation(self, unit="m"):
         value = self.get_altitude_data()[3]
 
         if unit == "m":
             meters = round(value, 2)
             value = meters
         elif unit == "km":
-            kilometers = value/1000
+            kilometers = value / 1000
             value = kilometers
         elif unit == "ft":
-            feet = value*3.28084
+            feet = value * 3.28084
             value = feet
         elif unit == "mi":
-            miles = value/1609.34
+            miles = value / 1609.34
             value = miles
         else:
             print("error: get_elevation() input must be either: m km ft mi")
             return round(value, 2)
         return value
 
     def set_initial_pressure(self):
-        self.init_press  = 0
-        while self.init_press  < 1:
-            self.init_press  = self.get_pressure()
+        self.init_press = 0
+        while self.init_press < 1:
+            self.init_press = self.get_pressure()
 
     def height_from_pressure(self, b=0, m=9.34):
         """
         initial_pressure: the initial pressure taken at the "floor level"
         the drone must start as close to the "ground" as possible
-        otherwise the height will be offset
+        otherwise the height will be offset this method will
+        have lots of variance as the barometer is not
+        precise enough for millimeter accuracy.
+
         :param b: slope intercept in PASCALS
         :param m: slope in millimeters/pascals
         :return: the height in millimeters
         """
         current_pressure = self.get_pressure()
         height_pressure = (self.init_press - current_pressure + b) * m
         height_pressure = round(height_pressure, 2)
         return height_pressure
 
-    def get_temperature(self, unit = "C"):
+    def get_temperature(self, unit="C"):
         """
         In celsius by default
         unit == "C" or unit == "c" or unit == "Celsius"
         unit == "F" or unit == "f" or unit == "Fahrenheit"
         unit == "K" or unit == "k" or unit == "Kelvin"
         :return: the temperature in the desired units rounded 2 decimal places
         """
         data = self.get_altitude_data()[1]
         if unit == "C" or unit == "c" or unit == "Celsius":
             data = data
         elif unit == "F" or unit == "f" or unit == "Fahrenheit":
-            data = 9/5*data+32
+            data = 9 / 5 * data + 32
         elif unit == "K" or unit == "k" or unit == "Kelvin":
             data = data + 273.15
         else:
             data = data
         return round(data, 2)
 
-    def get_drone_temp(self, unit = "C"):
+    def get_drone_temp(self, unit="C"):
         """
         Deprecated function name.
         :param unit:
         :return:
         """
         self.get_temperature(unit=unit)
 
@@ -665,19 +694,18 @@
         max is level 3 which makes the drone go very fast.
         :param speed_level: integer from 1 -3
         :return: N/A
         """
         if speed_level > 3:
             speed_level = 3
         elif speed_level < 1:
-            speed_level =1
+            speed_level = 1
 
         self.sendCommand(CommandType.ControlSpeed, int(speed_level))
 
-
     def update_motion_data(self, drone_type):
 
         """
             Variable    Name    Type        Size          Range Unit     Description
         [0] time_elapsed          float                                 seconds
         [1] accelX	    Int16	2 Byte	-1568 ~ 1568 (-156.8 ~ 156.8)	m/s2 x 10	 X
         [2] accelY	    Int16	2 Byte	-1568 ~ 1568 (-156.8 ~ 156.8)	m/s2 x 10	 Y
@@ -959,15 +987,14 @@
                 :param yaw: int from -100-100
                 :param throttle: int from -100-100
                 :param timeMs: int from -100-1000000 in milliseconds
                 :return: sendControl()
                 """
         self.sendControlWhile(roll, pitch, yaw, throttle, duration * 1000)
 
-
     def _receiving(self):
         while self._flagThreadRun:
 
             self._bufferQueue.put(self._serialport.read())
 
             # Automatic update of data when incoming data background check is enabled
             if self._flagCheckBackground:
@@ -1604,15 +1631,14 @@
         self.get_position_data()
         x = self.get_position_data()[1]
         y = self.get_position_data()[2]
         z = self.get_position_data()[3]
         temp = [x, y, z]
         return self.waypoint_data.append(temp)
 
-
     def sendTakeOff(self):
 
         header = Header()
 
         header.dataType = DataType.Command
         header.length = Command.getSize()
         header.from_ = DeviceType.Base
@@ -1621,15 +1647,14 @@
         data = Command()
 
         data.commandType = CommandType.FlightEvent
         data.option = FlightEvent.TakeOff.value
 
         return self.transfer(header, data)
 
-
     def sendLanding(self):
 
         self._control.roll = 0
         self._control.pitch = 0
         self._control.yaw = 0
         self._control.throttle = 0
         self.move()
@@ -1814,35 +1839,35 @@
         """
         :param distance: the numerical value of the value to move
         :param units: can either be in inches, centimeters, meters, feet.
         :param speed: default 1 meter per second. Max is 2 meters/second.
         :return: N/A
         """
         if units == "cm":
-            distance_meters = distance/100
+            distance_meters = distance / 100
         elif units == "ft":
-            distance_meters = distance/3.28084
+            distance_meters = distance / 3.28084
         elif units == "in":
-            distance_meters = distance/39.37
+            distance_meters = distance / 39.37
         elif units == "m":
-            distance_meters = distance*1
+            distance_meters = distance * 1
 
         # cap the speed
-        if speed >2:
-            speed =2
+        if speed > 2:
+            speed = 2
         elif speed < 0:
             speed = 0
 
         # read the current position and move relative to
         # position
         data = self.get_position_data()
         x = data[1]
         y = data[2]
         z = data[3]
-        self.send_absolute_position(positionX=x+distance_meters,
+        self.send_absolute_position(positionX=x + distance_meters,
                                     positionY=y,
                                     positionZ=z,
                                     velocity=speed,
                                     heading=0,
                                     rotationalVelocity=0)
         time.sleep(0.001)
 
@@ -1850,32 +1875,32 @@
         """
         :param distance: the numerical value of the value to move
         :param units: can either be in inches, centimeters, meters, feet.
         :param speed: default 1 meter per second. Max is 2 meters/second.
         :return: N/A
         """
         if units == "cm":
-            distance_meters = distance/100
+            distance_meters = distance / 100
         elif units == "ft":
-            distance_meters = distance/3.28084
+            distance_meters = distance / 3.28084
         elif units == "in":
-            distance_meters = distance/39.37
+            distance_meters = distance / 39.37
         elif units == "m":
-            distance_meters = distance*1
+            distance_meters = distance * 1
 
         # cap the speed
-        if speed >2:
-            speed =2
+        if speed > 2:
+            speed = 2
         elif speed < 0:
             speed = 0
         data = self.get_position_data()
         x = data[1]
         y = data[2]
         z = data[3]
-        self.send_absolute_position(positionX=x-distance_meters,
+        self.send_absolute_position(positionX=x - distance_meters,
                                     positionY=y,
                                     positionZ=z,
                                     velocity=speed,
                                     heading=0,
                                     rotationalVelocity=0)
         time.sleep(0.001)
 
@@ -1883,67 +1908,67 @@
         """
         :param distance: the numerical value of the value to move
         :param units: can either be in inches, centimeters, meters, feet.
         :param speed: default 1 meter per second. Max is 2 meters/second.
         :return: N/A
         """
         if units == "cm":
-            distance_meters = distance/100
+            distance_meters = distance / 100
         elif units == "ft":
-            distance_meters = distance/3.28084
+            distance_meters = distance / 3.28084
         elif units == "in":
-            distance_meters = distance/39.37
+            distance_meters = distance / 39.37
         elif units == "m":
-            distance_meters = distance*1
+            distance_meters = distance * 1
 
         # cap the speed
-        if speed >2:
-            speed =2
+        if speed > 2:
+            speed = 2
         elif speed < 0:
             speed = 0
 
         data = self.get_position_data()
         x = data[1]
         y = data[2]
         z = data[3]
         self.send_absolute_position(positionX=x,
-                                    positionY=y+distance_meters,
+                                    positionY=y + distance_meters,
                                     positionZ=z,
                                     velocity=speed,
                                     heading=0,
                                     rotationalVelocity=0)
         time.sleep(0.001)
 
     def move_right(self, distance, units="cm", speed=1.0):
         """
         :param distance: the numerical value of the value to move
         :param units: can either be in inches, centimeters, meters, feet.
         :param speed: default 1 meter per second. Max is 2 meters/second.
         :return: N/A
         """
         if units == "cm":
-            distance_meters = distance/100
+            distance_meters = distance / 100
         elif units == "ft":
-            distance_meters = distance/3.28084
+            distance_meters = distance / 3.28084
         elif units == "in":
-            distance_meters = distance/39.37
+            distance_meters = distance / 39.37
         elif units == "m":
-            distance_meters = distance*1
+            distance_meters = distance * 1
 
         # cap the speed
-        if speed >2:
-            speed =2
+        if speed > 2:
+            speed = 2
         elif speed < 0:
             speed = 0
         data = self.get_position_data()
         x = data[1]
         y = data[2]
         z = data[3]
         self.send_absolute_position(positionX=x,
-                                    positionY=y-distance_meters,
+                                    positionY=y - distance_meters,
                                     positionZ=z,
                                     velocity=speed,
                                     heading=0,
                                     rotationalVelocity=0)
         time.sleep(0.001)
 
     def send_absolute_position(self, positionX, positionY, positionZ, velocity, heading, rotationalVelocity):
@@ -1983,73 +2008,75 @@
         header.dataType = DataType.Control
         header.length = ControlPosition.getSize()
         header.from_ = DeviceType.Base
         header.to_ = DeviceType.Drone
 
         data = ControlPosition()
 
-        data.positionX = float(positionX) - (self.previous_land[0] + self.get_position_data()[1])
-        data.positionY = float(positionY) - (self.previous_land[1] + self.get_position_data()[2])
-        data.positionZ = float(positionZ) - self.get_pos_z("m")
+        pos_data = self.get_position_data()
+        # calculate the deltas in position needed to fly in those axis.
+
+        data.positionX = float(positionX) - (self.previous_land[0] + pos_data[1])
+        data.positionY = float(positionY) - (self.previous_land[1] + pos_data[2])
+        data.positionZ = float(positionZ) - pos_data[3]
         data.velocity = float(velocity)
         data.heading = heading
         data.rotationalVelocity = rotationalVelocity
 
         self.transfer(header, data)
 
-
     def goto_waypoint(self, waypoint, velocity):
-            """
-            drone movement command
+        """
+        drone movement command
 
-            Use real values for position and velocity, and
-            integer values for heading and rotational Velocity.
-            :param positionX: float	-10.0 ~ 10.0	meter	Front (+), Back (-)
-            :param positionY: float	-10.0 ~ 10.0	meter	Left(+), Right(-)
-            :param positionZ: float	-10.0 ~ 10.0	meter	Up (+), Down (-)
-            :param velocity: float	0.5 ~ 2.0	m/s	position movement speed
-            :param heading: Int16	-360 ~ 360	degree	Turn left (+), turn right (-)
-            :param rotationalVelocity: Int16	10 ~ 360	degree/s	left and right rotation speed
-            :return: None
-            """
+        Use real values for position and velocity, and
+        integer values for heading and rotational Velocity.
+        :param positionX: float	-10.0 ~ 10.0	meter	Front (+), Back (-)
+        :param positionY: float	-10.0 ~ 10.0	meter	Left(+), Right(-)
+        :param positionZ: float	-10.0 ~ 10.0	meter	Up (+), Down (-)
+        :param velocity: float	0.5 ~ 2.0	m/s	position movement speed
+        :param heading: Int16	-360 ~ 360	degree	Turn left (+), turn right (-)
+        :param rotationalVelocity: Int16	10 ~ 360	degree/s	left and right rotation speed
+        :return: None
+        """
 
-            if not (isinstance(waypoint[0], float) or isinstance(waypoint[0], int)):
-                return None
+        if not (isinstance(waypoint[0], float) or isinstance(waypoint[0], int)):
+            return None
 
-            if not (isinstance(waypoint[1], float) or isinstance(waypoint[1], int)):
-                return None
+        if not (isinstance(waypoint[1], float) or isinstance(waypoint[1], int)):
+            return None
 
-            if not (isinstance(waypoint[2], float) or isinstance(waypoint[2], int)):
-                return None
+        if not (isinstance(waypoint[2], float) or isinstance(waypoint[2], int)):
+            return None
 
-            if not (isinstance(velocity, float) or isinstance(velocity, int)):
-                return None
+        if not (isinstance(velocity, float) or isinstance(velocity, int)):
+            return None
 
-            from math import sqrt
+        from math import sqrt
 
-            header = Header()
+        header = Header()
 
-            header.dataType = DataType.Control
-            header.length = ControlPosition.getSize()
-            header.from_ = DeviceType.Base
-            header.to_ = DeviceType.Drone
+        header.dataType = DataType.Control
+        header.length = ControlPosition.getSize()
+        header.from_ = DeviceType.Base
+        header.to_ = DeviceType.Drone
 
-            data = ControlPosition()
+        data = ControlPosition()
+
+        data.positionX = float(waypoint[0]) - (self.previous_land[0] + self.get_position_data()[1])
+        data.positionY = float(waypoint[1]) - (self.previous_land[1] + self.get_position_data()[2])
+        data.positionZ = data.positionZ
+        data.velocity = float(velocity)
+        data.heading = 0
+        data.rotationalVelocity = 0
 
-            data.positionX = float(waypoint[0]) - (self.previous_land[0] + self.get_position_data()[1])
-            data.positionY = float(waypoint[1]) - (self.previous_land[1] + self.get_position_data()[2])
-            data.positionZ = data.positionZ
-            data.velocity = float(velocity)
-            data.heading = 0
-            data.rotationalVelocity = 0
-
-            temp = sqrt(data.positionX ** 2 + data.positionY ** 2)
-            wait = (temp / velocity) + 1
-            self.transfer(header, data)
-            time.sleep(wait)
+        temp = sqrt(data.positionX ** 2 + data.positionY ** 2)
+        wait = (temp / velocity) + 1
+        self.transfer(header, data)
+        time.sleep(wait)
 
     # Control End
     def percent_error(self, desired, current):
         """
         Calculates the percent error of two values.
 
         :param desired: numerical value
@@ -2101,51 +2128,51 @@
             degree_diff = desired_angle - current_angle
 
             # save the first distance turning in one direction
             degree_dist_1 = abs(degree_diff)
 
             # now we find what direction to turn
             # sign will be either +1 or -1
-            if degree_dist_1>0:
+            if degree_dist_1 > 0:
                 sign = degree_diff / degree_dist_1
             else:
                 sign = 1
 
             # now save the second distance going
             # the opposite direction turning
             degree_dist_2 = 360 - degree_dist_1
 
             # find which one is the shorter path
             if degree_dist_1 <= degree_dist_2:
                 # normalize the degree distance so it goes from 0-100%
                 # where 100% would be 360 degree distance
-                error_percent = int(degree_dist_1/360*100)
-                error_percent = int(error_percent*p_value)
+                error_percent = int(degree_dist_1 / 360 * 100)
+                error_percent = int(error_percent * p_value)
                 # cap the value between -100% and 100%
                 if error_percent > 100:
                     error_percent = 100
                 elif error_percent < -100:
                     error_percent = -100
                 # now we can use the sign to determine the turning direction
                 speed = int(sign * error_percent)
                 self.sendControl(0, 0, speed, 0)
                 time.sleep(0.005)
-                #print( error_percent, " ,", current_angle," ,", sign," ,", degree_dist_1,
+                # print( error_percent, " ,", current_angle," ,", sign," ,", degree_dist_1,
                 #      " ,", degree_dist_2, " ,", speed, " ,", time.time(), " ,", desired_angle)
 
 
             elif degree_dist_2 < degree_dist_1:
-                error_percent = int(degree_dist_2/360*100)
+                error_percent = int(degree_dist_2 / 360 * 100)
                 error_percent = int(error_percent * p_value)
                 # cap the value between -100% and 100%
                 if error_percent > 100:
                     error_percent = 100
                 elif error_percent < -100:
                     error_percent = -100
-                speed = int(-1* sign * error_percent)
+                speed = int(-1 * sign * error_percent)
                 self.sendControl(0, 0, speed, 0)
                 time.sleep(0.005)
                 # print( error_percent, " ,", current_angle," ,", sign," ,", degree_dist_1,
                 #       " ,", degree_dist_2, " ,", speed, " ,", time.time(), " ,", desired_angle)
 
         # stop any movement just in case
         self.hover(0.05)
@@ -2153,39 +2180,38 @@
     def turn_left(self, degree=90, timeout=3):
         # make sure it is an int and a positive value
         degree = int(abs(degree))
         # cap the max value to turn to 180
         if degree >= 180:
             degree = 179
 
-
         current_degree = self.get_z_angle()
         # positive degrees are to the left
         des_degree = degree + current_degree
         if des_degree > 180:
             new_degree = -(360 - des_degree)
-            self.turn_degree(new_degree,timeout=timeout)
+            self.turn_degree(new_degree, timeout=timeout)
         else:
-            self.turn_degree(des_degree,timeout=timeout)
+            self.turn_degree(des_degree, timeout=timeout)
 
     def turn_right(self, degree=90, timeout=3):
         # make sure it is an int and a positive value
         degree = int(abs(degree))
         # cap the max value to turn to 180
         if degree >= 180:
             degree = 179
 
         current_degree = self.get_z_angle()
-        #postive degrees are to the left
+        # positive degrees are to the left
         des_degree = current_degree - degree
         if des_degree < -180:
             new_degree = (360 - des_degree)
-            self.turn_degree(new_degree,timeout=timeout)
+            self.turn_degree(new_degree, timeout=timeout)
         else:
-            self.turn_degree(des_degree,timeout=timeout)
+            self.turn_degree(des_degree, timeout=timeout)
 
     # Flight Sequences Start
     def avoid_wall(self, timeout=2, distance=70):
         """
         A looped method that makes the drone fly forward until it reaches
         a desired distance.
         The range of front sensor is from 0cm-100cm
@@ -2207,23 +2233,23 @@
             current_distance = self.get_front_range("cm")
             change_in_distance = prev_distance - current_distance
             prev_distance = current_distance
             data_now = self.get_flow_data()
             error_percent = self.percent_error(desired=distance, current=current_distance)
             # speed can range from -100 to 100
             speed = int(error_percent * p_value)
-            #print(data_now[0], ",", current_distance, ",",change_in_distance, ",",data_now[1], ",",data_now[2])
+            # print(data_now[0], ",", current_distance, ",",change_in_distance, ",",data_now[1], ",",data_now[2])
 
             if current_distance > distance + threshold or current_distance < distance - threshold:
                 self.sendControl(0, speed, 0, 0)
                 time.sleep(0.005)
             else:
                 self.hover()
-                counter = counter +1
-                if counter is 20:
+                counter = counter + 1
+                if counter == 20:
                     break
         self.hover()
 
     def keep_distance(self, timeout=2, distance=50):
         """
         A looped method that makes the drone fly forward until it reaches
         a desired distance. The drone will keep that distance.
@@ -2333,15 +2359,14 @@
 
         self.sendControlWhile(0, -power, 0, 0, duration)  # -Pitch
         self.sendControlWhile(0, power, 0, 0, 50)
 
         self.sendControlWhile(-power * direction, 0, 0, 0, duration)  # Roll
         self.sendControlWhile(power * direction, 0, 0, 0, 50)
 
-
     def triangle(self, speed=60, seconds=1, direction=1):
         """
         Flies the drone in the shape of a triangle. Defaults to the right.
 
         :param speed: integer from 0 to 100
         :param seconds:  integer that describes the duration of each side
         :param direction: integer, -1 or 1 that determines direction.
@@ -2506,15 +2531,14 @@
 
         data.mode = mode
         data.value = note_value
         data.time = 65535
 
         self.transfer(header, data)
 
-
     def stop_drone_buzzer(self):
         """
         stops buzzer.
 
         :return: None
         """
         header = Header()
@@ -2585,15 +2609,14 @@
 
         data.mode = BuzzerMode.Mute
         data.value = BuzzerMode.Mute.value
         data.time = 1
 
         return self.transfer(header, data)
 
-
     def controller_buzzer(self, note, duration):
         """
         Plays a note using the controller's buzzer.
 
         :param note: integer frequency or Note object
         :param duration: duration of the note in milliseconds
         :return: None
@@ -2879,20 +2902,40 @@
         data.commandType = CommandType.Headless
         data.option = headless.value
 
         return self.transfer(header, data)
 
     def reset_sensor(self):
         """
+        This method will reset the gyroscope and accelerometer
+        and calibrate it.
+
+        While this program runs the drone must be on a leveled flat surface
+        in order for the Gyroscope and Accelerometer to be cleared.
+        If the calibration is done while the drone is moving
+        the drone will have incorrect calibration values
+        resulting in incorrect gyro angles and accelerometer values
 
         :return:
         """
+        # send RF command to clear the bias and initiate the calibration
         self.sendClearBias()
         time.sleep(0.01)
 
+        print("Lay the drone on a flat surface & "
+              "Do not move CoDrone EDU")
+        time.sleep(1)
+        while True:
+            self.get_error_data()
+            error_flag_now = self.error_data[1]
+            if (error_flag_now & ErrorFlagsForSensor.Motion_Calibrating.value) == 0:
+                break
+                time.sleep(0.5)
+        print("Done calibrating.")
+
     def set_trim(self, roll, pitch):
         """
         Sets the drone trim values for roll, pitch, yaw, and throttle.
 
         :param roll: integer from -100-100
         :param pitch: integer from -100-100
         :return: None
@@ -3090,23 +3133,23 @@
         data.motor[0].value = motor0
         data.motor[1].value = motor1
         data.motor[2].value = motor2
         data.motor[3].value = motor3
 
         return self.transfer(header, data)
 
-    def set_motor_speed(self, front_right=0,back_right=0,back_left=0,front_left=0,time_delay=0.001):
+    def set_motor_speed(self, front_right=0, back_right=0, back_left=0, front_left=0, time_delay=0.001):
         """
         for controlling the invidual motor speeds
         0-1000 integer
 
         :return:
         """
 
-        self.sendMotor(int(front_right),int(back_right),int(back_left),int(front_left))
+        self.sendMotor(int(front_right), int(back_right), int(back_left), int(front_left))
         sleep(time_delay)
 
     def sendMotorSingle(self, target, value):
 
         if ((not isinstance(target, int)) or
                 (not isinstance(value, int))):
             return None
@@ -3373,78 +3416,75 @@
         except:
             print("Error: A classifier has not been loaded. Call drone.load_classifier() and try again.")
             self.close()
             exit()
 
     def load_classifier(self, dataset=None, show_graph=False):
 
-        #TODO Check first if all text tiles in the dataset have the same number of data points 0.6
-
+        # TODO Check first if all text tiles in the dataset have the same number of data points 0.6
 
-        if dataset is None: # path to default data inside of cde lib
+        if dataset is None:  # path to default data inside of cde lib
             lib_dir = os.path.dirname(os.path.abspath(__file__))
             path = lib_dir + "/data/"
 
         else:
             path = os.path.join(self.parent_dir, dataset)  # user defined data
 
             if not os.path.isdir(path):
-                print("Error: Cannot load classifier. Dataset " +dataset+" does not exist.")
+                print("Error: Cannot load classifier. Dataset " + dataset + " does not exist.")
                 print("Use the new_color_data() method to add data.")
                 self.close()
                 exit()
 
             else:
                 folder = os.listdir(path)
 
                 if len(folder) == 0:
                     print("Error: Cannot load classifier. Dataset " + dataset + " is empty.")
                     print("Use the new_color_data() method to add data.")
                     self.close()
                     exit()
 
-
         all_data = []
         all_labels = []
         sample_size = None
         prev_sample_size = None
         samp_size_list = []
         sizes_different = False
 
         for filename in os.listdir(path):
-            #print(filename)
+            # print(filename)
             data = np.loadtxt(path + '/' + filename)
             all_data.append(data)
 
             sample_size = len(data)
             samp_size_list.append([sample_size, filename])
 
             if prev_sample_size is None:
                 prev_sample_size = sample_size
 
             if prev_sample_size != sample_size:
                 sizes_different = True
 
-
             prev_sample_size = sample_size
             all_labels.append(filename.strip('.txt'))
 
         if len(all_labels) < 3:
             print("Error: The data set must have at least 3 labels to call load_classifier().")
             print(f'Your data set "{dataset}" has {len(all_labels)} label(s)')
 
         if sizes_different:
             print("Error one or more files has a different sample size.")
             for sizes in samp_size_list:
-                print("samples ",sizes[0], " filename ",sizes[1])
+                print("samples ", sizes[0], " filename ", sizes[1])
 
-        x = [] # Hue
-        y = [] # Saturation
-        z = [] # Value
-        w = [] # Luminosity
+        x = []  # Hue
+        y = []  # Saturation
+        z = []  # Value
+        w = []  # Luminosity
         labels_list = []
 
         for color in range(len(all_labels)):
 
             for i in range(len(all_data)):
                 labels_list.append(all_labels[color])
                 # use data from both sensors front
@@ -3464,30 +3504,30 @@
             import matplotlib.pyplot as plt
             fig = plt.figure()
             ax = fig.add_subplot(projection='3d')
             ax.scatter3D(x, y, z, c=z)
             plt.show()
         return all_data
 
-    def print_num_data(self,label,dataset):
+    def print_num_data(self, label, dataset):
 
         folder = dataset
         parent_dir = os.getcwd()
         path = os.path.join(parent_dir, folder)
         filename = path + '/' + label + '.txt'
         file_exists = os.path.exists(filename)
 
         if not file_exists:
             print("Error: Cannot count data. Folder and file do not exist. Use new_color_data()")
             return
 
         data = np.loadtxt(filename)
         return len(data)
 
-    def append_color_data(self,label,data,dataset):
+    def append_color_data(self, label, data, dataset):
 
         """
           This function will append data to an already existing label in a dataset.
           If the file doesn't exist, then it will print an error.
 
           :param label: String label name that will be used for the filename
           :param data: List of HSV data samples
@@ -3506,15 +3546,15 @@
             return
 
         print("Appending data to " + label + "...")
 
         new_data = data  # new data we want to add
         con_data = np.array(new_data)  # convert it first to np array
         old_data = np.loadtxt(filename)  # load existing data
-        all_data = np.concatenate((old_data, con_data)) # add the data
+        all_data = np.concatenate((old_data, con_data))  # add the data
         np.savetxt(filename, all_data)  # save the new combined data
 
     def new_color_data(self, label, data, dataset):
         """
         This function creates a new textfile label.txt in a dataset folder.
 
         :param label: String label name that will be used for the filename
@@ -3524,15 +3564,15 @@
         """
 
         folder = dataset
         parent_dir = os.getcwd()
         path = os.path.join(parent_dir, folder)
 
         if not os.path.isdir(path):
-            #print("Creating new dataset.")
+            # print("Creating new dataset.")
             os.makedirs(path)
         print("Adding " + label + " to", dataset)
         filename = label + ".txt"
         np.savetxt(path + '/' + filename, data)
 
     # Color End
 
@@ -3843,15 +3883,16 @@
         :return: nothing
         """
         try:
             for i in range(len(point_list)):
                 if i == len(point_list) - 1:
                     self.sendDisplayDrawLine(point_list[i][0], point_list[i][1], point_list[0][0], point_list[0][1])
                 else:
-                    self.sendDisplayDrawLine(point_list[i][0], point_list[i][1], point_list[i+1][0], point_list[i+1][1])
+                    self.sendDisplayDrawLine(point_list[i][0], point_list[i][1], point_list[i + 1][0],
+                                             point_list[i + 1][1])
         except:
             print("Could not draw the list:", point_list)
             print("Use a list in the format: list [ (x1,y1), (x2, y2),..., (xn, yn) ]")
 
     def controller_draw_ellipse(self, ellipse_list, image, fill_in=None, pixel_width=1):
         """
         Draws an ellipse inside the given bounding box.
@@ -3934,15 +3975,15 @@
             return
 
         num_elem = len(pixel_list[0])
         for k in range(64):
             for i in range(128):
 
                 if (127 * k) + i == 8001:
-                    return # end
+                    return  # end
                 else:
                     current_index = pixel_list[(127 * k) + i]
 
                 if num_elem == 4:  # png
                     if current_index[0] > 200 and current_index[1] > 200 and current_index[2] > 200 and \
                             current_index[3] > 200:
                         None
```

## Comparing `codrone_edu-1.7.dist-info/RECORD` & `codrone_edu-1.8.dist-info/RECORD`

 * *Files 11% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 codrone_edu/__init__.py,sha256=SdD51Bmo1K69R3dnUwiNGpcdC38ReNzqbqss9oJ-SyY,102
 codrone_edu/__main__.py,sha256=ptqtUPF5GXUceV2k9sNWOS0lLlzMNvs-255AZUs5tvE,120
 codrone_edu/crc.py,sha256=3x7DN9fKHj2LpZgsDmbwQOwAR7_9CoFXBKn7HZqxs7c,4525
-codrone_edu/drone.py,sha256=rDLGGHlGc7gq3kfff4Bm_x2216mI9HWcDTmWoBE03UI,135228
+codrone_edu/drone.py,sha256=66suYoxf57GvJFqeE9nna4QJtnI8DsdHsuPD9yKCPwY,137302
 codrone_edu/protocol.py,sha256=5Dfb2f68V5O33YPoH36jKc4Gak6u7Jb_Jr2Dekr5Fno,84260
 codrone_edu/receiver.py,sha256=qjdAQomvdSs-hwSa_gzlR6CcqiUw_8Ya-4Di1G-1DiI,6875
 codrone_edu/storage.py,sha256=IZUZXFf76xkpFPkbv7lIa0rtAA-uK5ii8_KdULPjeIw,2772
 codrone_edu/swarm.py,sha256=uwc_y8tSYiW8g7l7aH1QKmphkQBT9KaPNfVwUnhaZEk,2357
 codrone_edu/system.py,sha256=RWlQHn09HtVvOHbFnLZtuT8ib-or_oZUdFcg81jCm3Y,14115
 codrone_edu/update.py,sha256=2hFfRrdBkjI_o61tN3eiqZKuxrC2BuTYNTdJxF0xaSg,9206
 codrone_edu/data/black.txt,sha256=A66esqEcS_v05TVswatoYB5OmYLsh2Rq3oxhA_4fRb0,157500
@@ -15,13 +15,13 @@
 codrone_edu/data/purple.txt,sha256=LRrwxNYqW6VFpgt1LuZ6vtNP4sgKLiZhUnPtE7cry6M,157500
 codrone_edu/data/red.txt,sha256=1aZIETa1MyJt6dxCZNlB1kbQfQFUZXfqxuBStZb5UqQ,157500
 codrone_edu/data/white.txt,sha256=0tAoXIEMW-3qqUwsRqhhQAn1thQiD7puTTpYpQwvQYA,157500
 codrone_edu/data/yellow.txt,sha256=x3mquYwuhg9YmZ566Q0vlfQnDWLlwvKXsZeZYt67U7M,157500
 codrone_edu/tools/__init__.py,sha256=_uSlmI1iOwJN4DrVfj0I4Fw375frEilfWu6gKyDhDMY,31
 codrone_edu/tools/parser.py,sha256=3HQlGqdH64Bg9sNBRMvolQy6AnmHmOJRrk_xZGMe_1E,30977
 codrone_edu/tools/update.py,sha256=2hFfRrdBkjI_o61tN3eiqZKuxrC2BuTYNTdJxF0xaSg,9206
-codrone_edu-1.7.dist-info/DESCRIPTION.rst,sha256=OCTuuN6LcWulhHS3d5rfjdsQtW22n7HENFRh6jC6ego,10
-codrone_edu-1.7.dist-info/METADATA,sha256=dXpL_qDoinOCDOSKFj2Nmx53fLsKtZy6KWxn6YxWGJc,397
-codrone_edu-1.7.dist-info/RECORD,,
-codrone_edu-1.7.dist-info/WHEEL,sha256=rNo05PbNqwnXiIHFsYm0m22u4Zm6YJtugFG2THx4w3g,92
-codrone_edu-1.7.dist-info/metadata.json,sha256=6g5j3zgN8RSLC_nYxG-srKawwt6qgqaiGR3OSj160vs,505
-codrone_edu-1.7.dist-info/top_level.txt,sha256=F2RRzxZb4AKoVuEuDUyzR8nMtNZPSes5ESZIlC1FpvI,12
+codrone_edu-1.8.dist-info/DESCRIPTION.rst,sha256=OCTuuN6LcWulhHS3d5rfjdsQtW22n7HENFRh6jC6ego,10
+codrone_edu-1.8.dist-info/METADATA,sha256=IeeT9qT2HiROhn6iANzcMcZJlB7mJ5xjPFsqISBaHQo,375
+codrone_edu-1.8.dist-info/RECORD,,
+codrone_edu-1.8.dist-info/WHEEL,sha256=rNo05PbNqwnXiIHFsYm0m22u4Zm6YJtugFG2THx4w3g,92
+codrone_edu-1.8.dist-info/metadata.json,sha256=c8f5PQn1uRLAqPm8rkVqTEXebNlFoxUBE4HNUXctVxo,495
+codrone_edu-1.8.dist-info/top_level.txt,sha256=F2RRzxZb4AKoVuEuDUyzR8nMtNZPSes5ESZIlC1FpvI,12
```

