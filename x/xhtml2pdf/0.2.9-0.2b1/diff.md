# Comparing `tmp/xhtml2pdf-0.2.9-py3-none-any.whl.zip` & `tmp/xhtml2pdf-0.2b1.zip`

## zipinfo {}

```diff
@@ -1,61 +1,37 @@
-Zip file size: 262925 bytes, number of entries: 59
--rw-r--r--  2.0 unx      638 b- defN 23-Jan-30 18:00 xhtml2pdf/__init__.py
--rw-r--r--  2.0 unx     8788 b- defN 22-Apr-05 01:53 xhtml2pdf/charts.py
--rw-r--r--  2.0 unx    35331 b- defN 23-Jan-30 17:59 xhtml2pdf/context.py
--rw-r--r--  2.0 unx    14019 b- defN 23-Jan-30 17:59 xhtml2pdf/default.py
--rw-r--r--  2.0 unx     6093 b- defN 23-Jan-28 01:28 xhtml2pdf/document.py
--rw-r--r--  2.0 unx    12811 b- defN 23-Jan-28 01:28 xhtml2pdf/files.py
--rw-r--r--  2.0 unx    16396 b- defN 23-Jan-30 17:59 xhtml2pdf/paragraph.py
--rw-r--r--  2.0 unx    27745 b- defN 23-Jan-28 01:28 xhtml2pdf/parser.py
--rw-r--r--  2.0 unx     1997 b- defN 23-Jan-28 01:28 xhtml2pdf/pdf.py
--rw-r--r--  2.0 unx    12021 b- defN 22-Mar-15 22:25 xhtml2pdf/pisa.py
--rw-r--r--  2.0 unx    71117 b- defN 23-Jan-30 17:59 xhtml2pdf/reportlab_paragraph.py
--rw-r--r--  2.0 unx    12058 b- defN 22-Mar-15 22:25 xhtml2pdf/tables.py
--rw-r--r--  2.0 unx    24393 b- defN 23-Jan-30 17:59 xhtml2pdf/tags.py
--rw-r--r--  2.0 unx    22129 b- defN 23-Jan-28 01:28 xhtml2pdf/util.py
--rw-r--r--  2.0 unx     2849 b- defN 22-Mar-15 22:25 xhtml2pdf/wsgi.py
--rw-r--r--  2.0 unx    34501 b- defN 23-Jan-28 01:28 xhtml2pdf/xhtml2pdf_reportlab.py
--rw-r--r--  2.0 unx      136 b- defN 23-Jan-30 18:03 xhtml2pdf/__pycache__/__init__.cpython-310.opt-1.pyc
--rw-r--r--  2.0 unx     9566 b- defN 23-Jan-30 18:03 xhtml2pdf/__pycache__/charts.cpython-310.opt-1.pyc
--rw-r--r--  2.0 unx    23225 b- defN 23-Jan-30 18:03 xhtml2pdf/__pycache__/context.cpython-310.opt-1.pyc
--rw-r--r--  2.0 unx     8862 b- defN 23-Jan-30 18:03 xhtml2pdf/__pycache__/default.cpython-310.opt-1.pyc
--rw-r--r--  2.0 unx     3839 b- defN 23-Jan-30 18:03 xhtml2pdf/__pycache__/document.cpython-310.opt-1.pyc
--rw-r--r--  2.0 unx    13423 b- defN 23-Jan-30 18:03 xhtml2pdf/__pycache__/files.cpython-310.opt-1.pyc
--rw-r--r--  2.0 unx    13558 b- defN 23-Jan-30 18:03 xhtml2pdf/__pycache__/paragraph.cpython-310.opt-1.pyc
--rw-r--r--  2.0 unx    14685 b- defN 23-Jan-30 18:03 xhtml2pdf/__pycache__/parser.cpython-310.opt-1.pyc
--rw-r--r--  2.0 unx     1908 b- defN 23-Jan-30 18:03 xhtml2pdf/__pycache__/pdf.cpython-310.opt-1.pyc
--rw-r--r--  2.0 unx     9066 b- defN 23-Jan-30 18:03 xhtml2pdf/__pycache__/pisa.cpython-310.opt-1.pyc
--rw-r--r--  2.0 unx    44247 b- defN 23-Jan-30 18:03 xhtml2pdf/__pycache__/reportlab_paragraph.cpython-310.opt-1.pyc
--rw-r--r--  2.0 unx     7617 b- defN 23-Jan-30 18:03 xhtml2pdf/__pycache__/tables.cpython-310.opt-1.pyc
--rw-r--r--  2.0 unx    23127 b- defN 23-Jan-30 18:03 xhtml2pdf/__pycache__/tags.cpython-310.opt-1.pyc
--rw-r--r--  2.0 unx    18477 b- defN 23-Jan-30 18:03 xhtml2pdf/__pycache__/util.cpython-310.opt-1.pyc
--rw-r--r--  2.0 unx     2539 b- defN 23-Jan-30 18:03 xhtml2pdf/__pycache__/wsgi.cpython-310.opt-1.pyc
--rw-r--r--  2.0 unx    23117 b- defN 23-Jan-30 18:03 xhtml2pdf/__pycache__/xhtml2pdf_reportlab.cpython-310.opt-1.pyc
--rw-r--r--  2.0 unx        0 b- defN 22-Apr-05 01:53 xhtml2pdf/builders/__init__.py
--rw-r--r--  2.0 unx     8179 b- defN 23-Jan-28 01:28 xhtml2pdf/builders/signs.py
--rw-r--r--  2.0 unx     4373 b- defN 23-Jan-28 01:28 xhtml2pdf/builders/watermarks.py
--rw-r--r--  2.0 unx      124 b- defN 23-Jan-30 18:03 xhtml2pdf/builders/__pycache__/__init__.cpython-310.opt-1.pyc
--rw-r--r--  2.0 unx     6295 b- defN 23-Jan-30 18:03 xhtml2pdf/builders/__pycache__/signs.cpython-310.opt-1.pyc
--rw-r--r--  2.0 unx     3282 b- defN 23-Jan-30 18:03 xhtml2pdf/builders/__pycache__/watermarks.cpython-310.opt-1.pyc
--rw-r--r--  2.0 unx        0 b- defN 18-Aug-08 20:35 xhtml2pdf/config/__init__.py
--rw-r--r--  2.0 unx     1817 b- defN 22-Mar-15 22:25 xhtml2pdf/config/httpconfig.py
--rw-r--r--  2.0 unx      122 b- defN 23-Jan-30 18:03 xhtml2pdf/config/__pycache__/__init__.cpython-310.opt-1.pyc
--rw-r--r--  2.0 unx     1631 b- defN 23-Jan-30 18:03 xhtml2pdf/config/__pycache__/httpconfig.cpython-310.opt-1.pyc
--rw-r--r--  2.0 unx      314 b- defN 22-Mar-15 22:25 xhtml2pdf/w3c/__init__.py
--rw-r--r--  2.0 unx    27861 b- defN 22-Mar-15 22:25 xhtml2pdf/w3c/css.py
--rw-r--r--  2.0 unx     4022 b- defN 22-Mar-15 22:25 xhtml2pdf/w3c/cssDOMElementInterface.py
--rw-r--r--  2.0 unx    42702 b- defN 23-Jan-30 17:59 xhtml2pdf/w3c/cssParser.py
--rw-r--r--  2.0 unx    13126 b- defN 22-Mar-15 22:25 xhtml2pdf/w3c/cssSpecial.py
--rw-r--r--  2.0 unx      119 b- defN 23-Jan-30 18:03 xhtml2pdf/w3c/__pycache__/__init__.cpython-310.opt-1.pyc
--rw-r--r--  2.0 unx    29941 b- defN 23-Jan-30 18:03 xhtml2pdf/w3c/__pycache__/css.cpython-310.opt-1.pyc
--rw-r--r--  2.0 unx     4042 b- defN 23-Jan-30 18:03 xhtml2pdf/w3c/__pycache__/cssDOMElementInterface.cpython-310.opt-1.pyc
--rw-r--r--  2.0 unx    29349 b- defN 23-Jan-30 18:03 xhtml2pdf/w3c/__pycache__/cssParser.cpython-310.opt-1.pyc
--rw-r--r--  2.0 unx     5458 b- defN 23-Jan-30 18:03 xhtml2pdf/w3c/__pycache__/cssSpecial.cpython-310.opt-1.pyc
--rw-r--r--  2.0 unx     1237 b- defN 23-Jan-30 18:03 xhtml2pdf-0.2.9.dist-info/AUTHORS.rst
--rw-r--r--  2.0 unx    11358 b- defN 23-Jan-30 18:03 xhtml2pdf-0.2.9.dist-info/LICENSE.txt
--rw-r--r--  2.0 unx     7738 b- defN 23-Jan-30 18:03 xhtml2pdf-0.2.9.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 23-Jan-30 18:03 xhtml2pdf-0.2.9.dist-info/WHEEL
--rw-r--r--  2.0 unx       84 b- defN 23-Jan-30 18:03 xhtml2pdf-0.2.9.dist-info/entry_points.txt
--rw-r--r--  2.0 unx       10 b- defN 23-Jan-30 18:03 xhtml2pdf-0.2.9.dist-info/top_level.txt
-?rw-rw-r--  2.0 unx     5596 b- defN 23-Jan-30 18:03 xhtml2pdf-0.2.9.dist-info/RECORD
-59 files, 729150 bytes uncompressed, 253859 bytes compressed:  65.2%
+Zip file size: 116995 bytes, number of entries: 35
+-rw-r--r--  2.0 unx      278 b- defN 16-Nov-30 04:07 xhtml2pdf-0.2b1/setup.cfg
+-rw-r--r--  2.0 unx       82 b- defN 16-Nov-17 21:26 xhtml2pdf-0.2b1/MANIFEST.in
+-rw-r--r--  2.0 unx     6265 b- defN 16-Nov-25 04:36 xhtml2pdf-0.2b1/README.rst
+-rw-r--r--  2.0 unx     9397 b- defN 16-Nov-30 04:07 xhtml2pdf-0.2b1/PKG-INFO
+-rw-r--r--  2.0 unx        6 b- defN 16-Nov-17 21:26 xhtml2pdf-0.2b1/VERSION.txt
+-rw-r--r--  2.0 unx    11358 b- defN 16-Nov-17 21:26 xhtml2pdf-0.2b1/LICENSE.txt
+-rw-r--r--  2.0 unx     2911 b- defN 16-Nov-25 05:36 xhtml2pdf-0.2b1/setup.py
+-rw-r--r--  2.0 unx       58 b- defN 16-Nov-30 04:07 xhtml2pdf-0.2b1/xhtml2pdf.egg-info/requires.txt
+-rw-r--r--  2.0 unx      782 b- defN 16-Nov-30 04:07 xhtml2pdf-0.2b1/xhtml2pdf.egg-info/SOURCES.txt
+-rw-r--r--  2.0 unx       10 b- defN 16-Nov-30 04:07 xhtml2pdf-0.2b1/xhtml2pdf.egg-info/top_level.txt
+-rw-r--r--  2.0 unx     9397 b- defN 16-Nov-30 04:07 xhtml2pdf-0.2b1/xhtml2pdf.egg-info/PKG-INFO
+-rw-r--r--  2.0 unx       84 b- defN 16-Nov-30 04:07 xhtml2pdf-0.2b1/xhtml2pdf.egg-info/entry_points.txt
+-rw-r--r--  2.0 unx        1 b- defN 16-Nov-30 04:07 xhtml2pdf-0.2b1/xhtml2pdf.egg-info/dependency_links.txt
+-rw-r--r--  2.0 unx    28918 b- defN 16-Nov-25 04:36 xhtml2pdf-0.2b1/xhtml2pdf/util.py
+-rw-r--r--  2.0 unx    25626 b- defN 16-Nov-25 04:36 xhtml2pdf-0.2b1/xhtml2pdf/parser.py
+-rw-r--r--  2.0 unx     1458 b- defN 16-Nov-25 04:36 xhtml2pdf-0.2b1/xhtml2pdf/turbogears.py
+-rw-r--r--  2.0 unx     2868 b- defN 16-Nov-25 04:36 xhtml2pdf-0.2b1/xhtml2pdf/wsgi.py
+-rw-r--r--  2.0 unx    23887 b- defN 16-Nov-25 04:36 xhtml2pdf-0.2b1/xhtml2pdf/paragraph.py
+-rw-r--r--  2.0 unx     1927 b- defN 16-Nov-25 04:36 xhtml2pdf-0.2b1/xhtml2pdf/pdf.py
+-rw-r--r--  2.0 unx    12341 b- defN 16-Nov-25 04:36 xhtml2pdf-0.2b1/xhtml2pdf/tables.py
+-rw-r--r--  2.0 unx    32816 b- defN 16-Nov-25 04:36 xhtml2pdf-0.2b1/xhtml2pdf/xhtml2pdf_reportlab.py
+-rw-r--r--  2.0 unx    34095 b- defN 16-Nov-25 04:36 xhtml2pdf-0.2b1/xhtml2pdf/context.py
+-rw-r--r--  2.0 unx    20837 b- defN 16-Nov-25 04:36 xhtml2pdf-0.2b1/xhtml2pdf/tags.py
+-rw-r--r--  2.0 unx      637 b- defN 16-Nov-25 04:36 xhtml2pdf-0.2b1/xhtml2pdf/__init__.py
+-rw-r--r--  2.0 unx     6516 b- defN 16-Nov-25 04:36 xhtml2pdf-0.2b1/xhtml2pdf/document.py
+-rw-r--r--  2.0 unx    12910 b- defN 16-Nov-17 21:26 xhtml2pdf-0.2b1/xhtml2pdf/default.py
+-rw-r--r--  2.0 unx    70939 b- defN 16-Nov-25 04:36 xhtml2pdf-0.2b1/xhtml2pdf/reportlab_paragraph.py
+-rw-r--r--  2.0 unx    11392 b- defN 16-Nov-25 04:36 xhtml2pdf-0.2b1/xhtml2pdf/pisa.py
+-rw-r--r--  2.0 unx    13477 b- defN 16-Nov-25 04:36 xhtml2pdf-0.2b1/xhtml2pdf/w3c/cssSpecial.py
+-rw-r--r--  2.0 unx     4180 b- defN 16-Nov-25 04:36 xhtml2pdf-0.2b1/xhtml2pdf/w3c/cssDOMElementInterface.py
+-rw-r--r--  2.0 unx    40584 b- defN 16-Nov-25 04:36 xhtml2pdf-0.2b1/xhtml2pdf/w3c/cssParser.py
+-rw-r--r--  2.0 unx      435 b- defN 16-Nov-17 21:26 xhtml2pdf-0.2b1/xhtml2pdf/w3c/__init__.py
+-rw-r--r--  2.0 unx    29291 b- defN 16-Nov-25 04:36 xhtml2pdf-0.2b1/xhtml2pdf/w3c/css.py
+-rw-r--r--  2.0 unx      607 b- defN 16-Nov-17 21:26 xhtml2pdf-0.2b1/test/testBackground.py
+-rw-r--r--  2.0 unx      579 b- defN 16-Nov-17 21:26 xhtml2pdf-0.2b1/test/testEvenOddPage.py
+35 files, 416949 bytes uncompressed, 111679 bytes compressed:  73.2%
```

## zipnote {}

```diff
@@ -1,178 +1,106 @@
-Filename: xhtml2pdf/__init__.py
+Filename: xhtml2pdf-0.2b1/setup.cfg
 Comment: 
 
-Filename: xhtml2pdf/charts.py
+Filename: xhtml2pdf-0.2b1/MANIFEST.in
 Comment: 
 
-Filename: xhtml2pdf/context.py
+Filename: xhtml2pdf-0.2b1/README.rst
 Comment: 
 
-Filename: xhtml2pdf/default.py
+Filename: xhtml2pdf-0.2b1/PKG-INFO
 Comment: 
 
-Filename: xhtml2pdf/document.py
+Filename: xhtml2pdf-0.2b1/VERSION.txt
 Comment: 
 
-Filename: xhtml2pdf/files.py
+Filename: xhtml2pdf-0.2b1/LICENSE.txt
 Comment: 
 
-Filename: xhtml2pdf/paragraph.py
+Filename: xhtml2pdf-0.2b1/setup.py
 Comment: 
 
-Filename: xhtml2pdf/parser.py
+Filename: xhtml2pdf-0.2b1/xhtml2pdf.egg-info/requires.txt
 Comment: 
 
-Filename: xhtml2pdf/pdf.py
+Filename: xhtml2pdf-0.2b1/xhtml2pdf.egg-info/SOURCES.txt
 Comment: 
 
-Filename: xhtml2pdf/pisa.py
+Filename: xhtml2pdf-0.2b1/xhtml2pdf.egg-info/top_level.txt
 Comment: 
 
-Filename: xhtml2pdf/reportlab_paragraph.py
+Filename: xhtml2pdf-0.2b1/xhtml2pdf.egg-info/PKG-INFO
 Comment: 
 
-Filename: xhtml2pdf/tables.py
+Filename: xhtml2pdf-0.2b1/xhtml2pdf.egg-info/entry_points.txt
 Comment: 
 
-Filename: xhtml2pdf/tags.py
+Filename: xhtml2pdf-0.2b1/xhtml2pdf.egg-info/dependency_links.txt
 Comment: 
 
-Filename: xhtml2pdf/util.py
+Filename: xhtml2pdf-0.2b1/xhtml2pdf/util.py
 Comment: 
 
-Filename: xhtml2pdf/wsgi.py
+Filename: xhtml2pdf-0.2b1/xhtml2pdf/parser.py
 Comment: 
 
-Filename: xhtml2pdf/xhtml2pdf_reportlab.py
+Filename: xhtml2pdf-0.2b1/xhtml2pdf/turbogears.py
 Comment: 
 
-Filename: xhtml2pdf/__pycache__/__init__.cpython-310.opt-1.pyc
+Filename: xhtml2pdf-0.2b1/xhtml2pdf/wsgi.py
 Comment: 
 
-Filename: xhtml2pdf/__pycache__/charts.cpython-310.opt-1.pyc
+Filename: xhtml2pdf-0.2b1/xhtml2pdf/paragraph.py
 Comment: 
 
-Filename: xhtml2pdf/__pycache__/context.cpython-310.opt-1.pyc
+Filename: xhtml2pdf-0.2b1/xhtml2pdf/pdf.py
 Comment: 
 
-Filename: xhtml2pdf/__pycache__/default.cpython-310.opt-1.pyc
+Filename: xhtml2pdf-0.2b1/xhtml2pdf/tables.py
 Comment: 
 
-Filename: xhtml2pdf/__pycache__/document.cpython-310.opt-1.pyc
+Filename: xhtml2pdf-0.2b1/xhtml2pdf/xhtml2pdf_reportlab.py
 Comment: 
 
-Filename: xhtml2pdf/__pycache__/files.cpython-310.opt-1.pyc
+Filename: xhtml2pdf-0.2b1/xhtml2pdf/context.py
 Comment: 
 
-Filename: xhtml2pdf/__pycache__/paragraph.cpython-310.opt-1.pyc
+Filename: xhtml2pdf-0.2b1/xhtml2pdf/tags.py
 Comment: 
 
-Filename: xhtml2pdf/__pycache__/parser.cpython-310.opt-1.pyc
+Filename: xhtml2pdf-0.2b1/xhtml2pdf/__init__.py
 Comment: 
 
-Filename: xhtml2pdf/__pycache__/pdf.cpython-310.opt-1.pyc
+Filename: xhtml2pdf-0.2b1/xhtml2pdf/document.py
 Comment: 
 
-Filename: xhtml2pdf/__pycache__/pisa.cpython-310.opt-1.pyc
+Filename: xhtml2pdf-0.2b1/xhtml2pdf/default.py
 Comment: 
 
-Filename: xhtml2pdf/__pycache__/reportlab_paragraph.cpython-310.opt-1.pyc
+Filename: xhtml2pdf-0.2b1/xhtml2pdf/reportlab_paragraph.py
 Comment: 
 
-Filename: xhtml2pdf/__pycache__/tables.cpython-310.opt-1.pyc
+Filename: xhtml2pdf-0.2b1/xhtml2pdf/pisa.py
 Comment: 
 
-Filename: xhtml2pdf/__pycache__/tags.cpython-310.opt-1.pyc
+Filename: xhtml2pdf-0.2b1/xhtml2pdf/w3c/cssSpecial.py
 Comment: 
 
-Filename: xhtml2pdf/__pycache__/util.cpython-310.opt-1.pyc
+Filename: xhtml2pdf-0.2b1/xhtml2pdf/w3c/cssDOMElementInterface.py
 Comment: 
 
-Filename: xhtml2pdf/__pycache__/wsgi.cpython-310.opt-1.pyc
+Filename: xhtml2pdf-0.2b1/xhtml2pdf/w3c/cssParser.py
 Comment: 
 
-Filename: xhtml2pdf/__pycache__/xhtml2pdf_reportlab.cpython-310.opt-1.pyc
+Filename: xhtml2pdf-0.2b1/xhtml2pdf/w3c/__init__.py
 Comment: 
 
-Filename: xhtml2pdf/builders/__init__.py
+Filename: xhtml2pdf-0.2b1/xhtml2pdf/w3c/css.py
 Comment: 
 
-Filename: xhtml2pdf/builders/signs.py
+Filename: xhtml2pdf-0.2b1/test/testBackground.py
 Comment: 
 
-Filename: xhtml2pdf/builders/watermarks.py
-Comment: 
-
-Filename: xhtml2pdf/builders/__pycache__/__init__.cpython-310.opt-1.pyc
-Comment: 
-
-Filename: xhtml2pdf/builders/__pycache__/signs.cpython-310.opt-1.pyc
-Comment: 
-
-Filename: xhtml2pdf/builders/__pycache__/watermarks.cpython-310.opt-1.pyc
-Comment: 
-
-Filename: xhtml2pdf/config/__init__.py
-Comment: 
-
-Filename: xhtml2pdf/config/httpconfig.py
-Comment: 
-
-Filename: xhtml2pdf/config/__pycache__/__init__.cpython-310.opt-1.pyc
-Comment: 
-
-Filename: xhtml2pdf/config/__pycache__/httpconfig.cpython-310.opt-1.pyc
-Comment: 
-
-Filename: xhtml2pdf/w3c/__init__.py
-Comment: 
-
-Filename: xhtml2pdf/w3c/css.py
-Comment: 
-
-Filename: xhtml2pdf/w3c/cssDOMElementInterface.py
-Comment: 
-
-Filename: xhtml2pdf/w3c/cssParser.py
-Comment: 
-
-Filename: xhtml2pdf/w3c/cssSpecial.py
-Comment: 
-
-Filename: xhtml2pdf/w3c/__pycache__/__init__.cpython-310.opt-1.pyc
-Comment: 
-
-Filename: xhtml2pdf/w3c/__pycache__/css.cpython-310.opt-1.pyc
-Comment: 
-
-Filename: xhtml2pdf/w3c/__pycache__/cssDOMElementInterface.cpython-310.opt-1.pyc
-Comment: 
-
-Filename: xhtml2pdf/w3c/__pycache__/cssParser.cpython-310.opt-1.pyc
-Comment: 
-
-Filename: xhtml2pdf/w3c/__pycache__/cssSpecial.cpython-310.opt-1.pyc
-Comment: 
-
-Filename: xhtml2pdf-0.2.9.dist-info/AUTHORS.rst
-Comment: 
-
-Filename: xhtml2pdf-0.2.9.dist-info/LICENSE.txt
-Comment: 
-
-Filename: xhtml2pdf-0.2.9.dist-info/METADATA
-Comment: 
-
-Filename: xhtml2pdf-0.2.9.dist-info/WHEEL
-Comment: 
-
-Filename: xhtml2pdf-0.2.9.dist-info/entry_points.txt
-Comment: 
-
-Filename: xhtml2pdf-0.2.9.dist-info/top_level.txt
-Comment: 
-
-Filename: xhtml2pdf-0.2.9.dist-info/RECORD
+Filename: xhtml2pdf-0.2b1/test/testEvenOddPage.py
 Comment: 
 
 Zip file comment:
```

## Comparing `xhtml2pdf/__init__.py` & `xhtml2pdf-0.2b1/xhtml2pdf/__init__.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,17 +1,16 @@
 # -*- coding: utf-8 -*-
-
 # Copyright 2010 Dirk Holtwick, holtwick.it
 #
 # Licensed under the Apache License, Version 2.0 (the "License");
 # you may not use this file except in compliance with the License.
 # You may obtain a copy of the License at
 #
 #     http://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software
 # distributed under the License is distributed on an "AS IS" BASIS,
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
-__version__ = "0.2.9"
+__version__ = "0.2b1"
```

## Comparing `xhtml2pdf/context.py` & `xhtml2pdf-0.2b1/xhtml2pdf/context.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,8 +1,37 @@
 # -*- coding: utf-8 -*-
+from reportlab.lib.enums import TA_LEFT
+from reportlab.lib.fonts import addMapping
+from reportlab.lib.pagesizes import landscape, A4
+from reportlab.lib.styles import ParagraphStyle
+from reportlab.pdfbase import pdfmetrics
+from reportlab.pdfbase.ttfonts import TTFont
+from reportlab.platypus.frames import Frame, ShowBoundaryValue
+from reportlab.platypus.paraparser import ParaFrag, ps2tt, tt2ps
+from xhtml2pdf.util import getSize, getCoords, getFile, pisaFileObject, \
+    getFrameDimensions, getColor
+from xhtml2pdf.w3c import css
+from xhtml2pdf.xhtml2pdf_reportlab import PmlPageTemplate, PmlTableOfContents, \
+    PmlParagraph, PmlParagraphAndImage, PmlPageCount
+import copy
+import logging
+import os
+import re
+import reportlab
+import six
+
+
+TupleType = tuple
+ListType = list
+try:
+    import urlparse
+except ImportError:
+    import urllib.parse as urlparse
+import xhtml2pdf.default
+import xhtml2pdf.parser
 
 # Copyright 2010 Dirk Holtwick, holtwick.it
 #
 # Licensed under the Apache License, Version 2.0 (the "License");
 # you may not use this file except in compliance with the License.
 # You may obtain a copy of the License at
 #
@@ -10,45 +39,16 @@
 #
 # Unless required by applicable law or agreed to in writing, software
 # distributed under the License is distributed on an "AS IS" BASIS,
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
-import copy
-import logging
-import os
-import re
-from pathlib import Path
-
-from reportlab import rl_settings
-from reportlab.lib.enums import TA_LEFT
-from reportlab.lib.fonts import addMapping
-from reportlab.lib.pagesizes import A4
-from reportlab.lib.styles import ParagraphStyle
-from reportlab.pdfbase import pdfmetrics
-from reportlab.pdfbase.ttfonts import TTFont
-from reportlab.platypus.frames import Frame, ShowBoundaryValue
-from reportlab.platypus.paraparser import ParaFrag, ps2tt, tt2ps
-
-import xhtml2pdf.default
-import xhtml2pdf.parser
-from xhtml2pdf.files import  getFile, pisaFileObject
-from xhtml2pdf.util import (arabic_format, copy_attrs, frag_text_language_check, getColor, getCoords,
-                            getFrameDimensions, getSize, set_asian_fonts, set_value, getFloat)
-from xhtml2pdf.w3c import css
-from xhtml2pdf.xhtml2pdf_reportlab import (PmlPageCount, PmlPageTemplate, PmlParagraph,
-                                           PmlParagraphAndImage, PmlTableOfContents)
-import urllib.parse as urlparse
-TupleType = tuple
-ListType = list
+reportlab.rl_config.warnOnMissingFontGlyphs = 0
 
-
-
-rl_settings.warnOnMissingFontGlyphs = 0
 log = logging.getLogger("xhtml2pdf")
 
 sizeDelta = 2       # amount to reduce font size by for super and sub script
 subFraction = 0.4   # fraction of font size that a sub script should be lowered
 superFraction = 0.4
 
 NBSP = u"\u00a0"
@@ -67,79 +67,100 @@
 
 
 ParaFrag.clone = clone
 
 
 def getParaFrag(style):
     frag = ParaFrag()
-
-    set_value(frag,
-              ('sub', 'super', 'rise', 'underline', 'strike', 'greek',
-               'leading', 'leadingSpace', 'spaceBefore',
-               'spaceAfter', 'leftIndent', 'rightIndent', 'firstLineIndent',
-               'borderPadding', 'paddingLeft', 'paddingRight',
-               'paddingTop', 'paddingBottom', 'bulletIndent',
-               'insideStaticFrame', 'outlineLevel'
-               ),
-              0)
-
-    set_value(frag,
-              ('backColor', 'vAlign', 'link', 'borderStyle',
-               'borderColor', 'listStyleType', 'listStyleImage',
-               'wordWrap', 'height', 'width', 'bulletText'
-               ),
-              None
-              )
-    set_value(frag,
-              ('pageNumber', 'pageCount', 'outline',
-               'outlineOpen', 'keepWithNext', 'rtl'),
-              False)
-
+    frag.sub = 0
+    frag.super = 0
+    frag.rise = 0
+    frag.underline = 0  # XXX Need to be able to set color to fit CSS tests
+    frag.strike = 0
+    frag.greek = 0
+    frag.link = None
     frag.text = ""
     frag.fontName = "Times-Roman"
     frag.fontName, frag.bold, frag.italic = ps2tt(style.fontName)
     frag.fontSize = style.fontSize
     frag.textColor = style.textColor
 
     # Extras
+    frag.leading = 0
     frag.letterSpacing = "normal"
     frag.leadingSource = "150%"
+    frag.leadingSpace = 0
+    frag.backColor = None
+    frag.spaceBefore = 0
+    frag.spaceAfter = 0
+    frag.leftIndent = 0
+    frag.rightIndent = 0
+    frag.firstLineIndent = 0
+    frag.keepWithNext = False
     frag.alignment = TA_LEFT
+    frag.vAlign = None
+
     frag.borderWidth = 1
+    frag.borderStyle = None
+    frag.borderPadding = 0
+    frag.borderColor = None
 
     frag.borderLeftWidth = frag.borderWidth
     frag.borderLeftColor = frag.borderColor
     frag.borderLeftStyle = frag.borderStyle
     frag.borderRightWidth = frag.borderWidth
     frag.borderRightColor = frag.borderColor
     frag.borderRightStyle = frag.borderStyle
     frag.borderTopWidth = frag.borderWidth
     frag.borderTopColor = frag.borderColor
     frag.borderTopStyle = frag.borderStyle
     frag.borderBottomWidth = frag.borderWidth
     frag.borderBottomColor = frag.borderColor
     frag.borderBottomStyle = frag.borderStyle
 
+    frag.paddingLeft = 0
+    frag.paddingRight = 0
+    frag.paddingTop = 0
+    frag.paddingBottom = 0
+
+    frag.listStyleType = None
+    frag.listStyleImage = None
     frag.whiteSpace = "normal"
+
+    frag.wordWrap = None
+
+    frag.pageNumber = False
+    frag.pageCount = False
+    frag.height = None
+    frag.width = None
+
+    frag.bulletIndent = 0
+    frag.bulletText = None
     frag.bulletFontName = "Helvetica"
+
     frag.zoom = 1.0
 
+    frag.outline = False
+    frag.outlineLevel = 0
+    frag.outlineOpen = False
+
+    frag.insideStaticFrame = 0
+
     return frag
 
 
 def getDirName(path):
     parts = urlparse.urlparse(path)
     if parts.scheme:
         return path
     else:
-        return str(Path(path).parent.resolve())
+        return os.path.dirname(os.path.abspath(path))
 
 
 class pisaCSSBuilder(css.CSSBuilder):
-
     def atFontFace(self, declarations):
         """
         Embed fonts
         """
         result = self.ruleset([self.selector('*')], declarations)
         data = list(result[0].values())[0]
         if "src" not in data:
@@ -147,144 +168,151 @@
             return {}, {}
         names = data["font-family"]
 
         # Font weight
         fweight = str(data.get("font-weight", "normal")).lower()
         bold = fweight in ("bold", "bolder", "500", "600", "700", "800", "900")
         if not bold and fweight != "normal":
-            log.warning(
-                self.c.warning("@fontface, unknown value font-weight '%s'", fweight))
+            log.warn(self.c.warning("@fontface, unknown value font-weight '%s'", fweight))
 
         # Font style
-        italic = str(
-            data.get("font-style", "")).lower() in ("italic", "oblique")
+        italic = str(data.get("font-style", "")).lower() in ("italic", "oblique")
 
         # The "src" attribute can be a CSS group but in that case
         # ignore everything except the font URI
         uri = data['src']
-        fonts = []
-
-        if isinstance(data['src'], list):
+        if not isinstance(data['src'], str):
             for part in uri:
                 if isinstance(part, str):
-                    fonts.append(part)
-        else:
-            fonts.append(uri)
+                    uri = part
+                    break
 
-        for font in fonts:
-            src = self.c.getFile(font, relative=self.c.cssParser.rootPath)
-            if not src.notFound():
-                self.c.loadFont(names, src,
-                                bold=bold, italic=italic)
+        src = self.c.getFile(uri, relative=self.c.cssParser.rootPath)
+        self.c.loadFont(
+            names,
+            src,
+            bold=bold,
+            italic=italic)
         return {}, {}
 
     def _pisaAddFrame(self, name, data, first=False, border=None, size=(0, 0)):
         c = self.c
         if not name:
             name = "-pdf-frame-%d" % c.UID()
         if data.get('is_landscape', False):
             size = (size[1], size[0])
         x, y, w, h = getFrameDimensions(data, size[0], size[1])
         # print name, x, y, w, h
-        # if not (w and h):
+        #if not (w and h):
         #    return None
         if first:
             return name, None, data.get("-pdf-frame-border", border), x, y, w, h, data
 
         return (name, data.get("-pdf-frame-content", None),
                 data.get("-pdf-frame-border", border), x, y, w, h, data)
 
     def _getFromData(self, data, attr, default=None, func=None):
         if not func:
-            def func(x): return x
+            func = lambda x: x
 
         if type(attr) in (list, tuple):
             for a in attr:
                 if a in data:
                     return func(data[a])
                 return default
         else:
             if attr in data:
                 return func(data[attr])
             return default
 
-    def get_background_context(self, data):
-        dev = {}
-        object_position = data.get('background-object-position', None)
-        height=data.get('background-height', None)
-        width=data.get('background-width', None)
-        opacity=data.get('background-opacity', None)
-        dev['step']=getFloat(data.get('background-page-step', 1))
-        if object_position:
-            dev['object_position'] = [getSize(object_position[0]), getSize(object_position[1])]
-        if height:
-            dev['height'] = getSize(height)
-        if width:
-            dev['width'] = getSize(width)
-        if opacity:
-            dev['opacity'] = getFloat(opacity)
-        return dev
-
-    def atPage(self, name, pseudopage, data, isLandscape, pageBorder):
+    def atPage(self, name, pseudopage, declarations):
         c = self.c
+        data = {}
         name = name or "body"
+        pageBorder = None
+
+        if declarations:
+            result = self.ruleset([self.selector('*')], declarations)
+
+            if declarations:
+                try:
+                    data = result[0].values()[0]
+                except Exception:
+                    data = result[0].popitem()[1]
+                pageBorder = data.get("-pdf-frame-border", None)
 
         if name in c.templateList:
-            log.warning(
-                self.c.warning("template '%s' has already been defined", name))
+            log.warn(self.c.warning("template '%s' has already been defined", name))
+
+        if "-pdf-page-size" in data:
+            c.pageSize = xhtml2pdf.default.PML_PAGESIZES.get(str(data["-pdf-page-size"]).lower(), c.pageSize)
+
+        isLandscape = False
+        if "size" in data:
+            size = data["size"]
+            if type(size) is not ListType:
+                size = [size]
+            sizeList = []
+            for value in size:
+                valueStr = str(value).lower()
+                if type(value) is TupleType:
+                    sizeList.append(getSize(value))
+                elif valueStr == "landscape":
+                    isLandscape = True
+                elif valueStr == "portrait":
+                    isLandscape = False
+                elif valueStr in xhtml2pdf.default.PML_PAGESIZES:
+                    c.pageSize = xhtml2pdf.default.PML_PAGESIZES[valueStr]
+                else:
+                    raise RuntimeError("Unknown size value for @page")
+
+            if len(sizeList) == 2:
+                c.pageSize = tuple(sizeList)
+            if isLandscape:
+                c.pageSize = landscape(c.pageSize)
 
         padding_top = self._getFromData(data, 'padding-top', 0, getSize)
         padding_left = self._getFromData(data, 'padding-left', 0, getSize)
         padding_right = self._getFromData(data, 'padding-right', 0, getSize)
         padding_bottom = self._getFromData(data, 'padding-bottom', 0, getSize)
-        border_color = self._getFromData(data, ('border-top-color', 'border-bottom-color',
+        border_color = self._getFromData(data, ('border-top-color', 'border-bottom-color',\
                                                 'border-left-color', 'border-right-color'), None, getColor)
-        border_width = self._getFromData(data, ('border-top-width', 'border-bottom-width',
+        border_width = self._getFromData(data, ('border-top-width', 'border-bottom-width',\
                                                 'border-left-width', 'border-right-width'), 0, getSize)
 
         for prop in ("margin-top", "margin-left", "margin-right", "margin-bottom",
                      "top", "left", "right", "bottom", "width", "height"):
             if prop in data:
-                c.frameList.append(
-                    self._pisaAddFrame(name, data, first=True, border=pageBorder, size=c.pageSize))
+                c.frameList.append(self._pisaAddFrame(name, data, first=True, border=pageBorder, size=c.pageSize))
                 break
 
         # Frames have to be calculated after we know the pagesize
         frameList = []
         staticList = []
         for fname, static, border, x, y, w, h, fdata in c.frameList:
-            fpadding_top = self._getFromData(
-                fdata, 'padding-top', padding_top, getSize)
-            fpadding_left = self._getFromData(
-                fdata, 'padding-left', padding_left, getSize)
-            fpadding_right = self._getFromData(
-                fdata, 'padding-right', padding_right, getSize)
-            fpadding_bottom = self._getFromData(
-                fdata, 'padding-bottom', padding_bottom, getSize)
-            fborder_color = self._getFromData(fdata, ('border-top-color', 'border-bottom-color',
+            fpadding_top = self._getFromData(fdata, 'padding-top', padding_top, getSize)
+            fpadding_left = self._getFromData(fdata, 'padding-left', padding_left, getSize)
+            fpadding_right = self._getFromData(fdata, 'padding-right', padding_right, getSize)
+            fpadding_bottom = self._getFromData(fdata, 'padding-bottom', padding_bottom, getSize)
+            fborder_color = self._getFromData(fdata, ('border-top-color', 'border-bottom-color',\
                                                       'border-left-color', 'border-right-color'), border_color, getColor)
-            fborder_width = self._getFromData(fdata, ('border-top-width', 'border-bottom-width',
+            fborder_width = self._getFromData(fdata, ('border-top-width', 'border-bottom-width',\
                                                       'border-left-width', 'border-right-width'), border_width, getSize)
 
             if border or pageBorder:
-
-                frame_border = ShowBoundaryValue(width=int(border))   #frame_border = ShowBoundaryValue() to
-                                                                      #frame_border = ShowBoundaryValue(width=int(border))
+                frame_border = ShowBoundaryValue()
             else:
-                frame_border = ShowBoundaryValue(
-                    color=fborder_color, width=fborder_width)
+                frame_border = ShowBoundaryValue(color=fborder_color, width=fborder_width)
 
-            # fix frame sizing problem.
+            #fix frame sizing problem.
             if static:
-                x, y, w, h = getFrameDimensions(
-                    fdata, c.pageSize[0], c.pageSize[1])
+                x, y, w, h = getFrameDimensions(fdata, c.pageSize[0], c.pageSize[1])
             x, y, w, h = getCoords(x, y, w, h, c.pageSize)
             if w <= 0 or h <= 0:
-                log.warning(
-                    self.c.warning("Negative width or height of frame. Check @frame definitions."))
+                log.warn(self.c.warning("Negative width or height of frame. Check @frame definitions."))
 
             frame = Frame(
                 x, y, w, h,
                 id=fname,
                 leftPadding=fpadding_left,
                 rightPadding=fpadding_right,
                 bottomPadding=fpadding_bottom,
@@ -295,35 +323,30 @@
                 frame.pisaStaticStory = []
                 c.frameStatic[static] = [frame] + c.frameStatic.get(static, [])
                 staticList.append(frame)
             else:
                 frameList.append(frame)
 
         background = data.get("background-image", None)
-        background_context = self.get_background_context(data)
         if background:
-            # should be relative to the css file
-            background = self.c.getFile(
-                background, relative=self.c.cssParser.rootPath)
+            #should be relative to the css file
+            background = self.c.getFile(background, relative=self.c.cssParser.rootPath)
 
         if not frameList:
-            log.warning(
-                c.warning("missing explicit frame definition for content or just static frames"))
+            log.warn(c.warning("missing explicit frame definition for content or just static frames"))
             fname, static, border, x, y, w, h, data = self._pisaAddFrame(name, data, first=True, border=pageBorder,
                                                                          size=c.pageSize)
             x, y, w, h = getCoords(x, y, w, h, c.pageSize)
             if w <= 0 or h <= 0:
-                log.warning(
-                    c.warning("Negative width or height of frame. Check @page definitions."))
+                log.warn(c.warning("Negative width or height of frame. Check @page definitions."))
 
             if border or pageBorder:
                 frame_border = ShowBoundaryValue()
             else:
-                frame_border = ShowBoundaryValue(
-                    color=border_color, width=border_width)
+                frame_border = ShowBoundaryValue(color=border_color, width=border_width)
 
             frameList.append(Frame(
                 x, y, w, h,
                 id=fname,
                 leftPadding=padding_left,
                 rightPadding=padding_right,
                 bottomPadding=padding_bottom,
@@ -334,15 +357,14 @@
             id=name,
             frames=frameList,
             pagesize=c.pageSize,
         )
         pt.pisaStaticList = staticList
         pt.pisaBackground = background
         pt.pisaBackgroundList = c.pisaBackgroundList
-        pt.backgroundContext = background_context
 
         if isLandscape:
             pt.pageorientation = pt.LANDSCAPE
 
         c.templateList[name] = pt
         c.template = None
         c.frameList = []
@@ -360,146 +382,107 @@
                 try:
                     data = data.values()[0]
                 except Exception:
                     data = data.popitem()[1]
                 self.c.frameList.append(
                     self._pisaAddFrame(name, data, size=self.c.pageSize))
 
-        return {}, {}  # TODO: It always returns empty dicts?
+        return {}, {} # TODO: It always returns empty dicts?
 
 
 class pisaCSSParser(css.CSSParser):
-
     def parseExternal(self, cssResourceName):
-        result = None
+
         oldRootPath = self.rootPath
         cssFile = self.c.getFile(cssResourceName, relative=self.rootPath)
         if not cssFile:
             return None
         if self.rootPath and urlparse.urlparse(self.rootPath).scheme:
             self.rootPath = urlparse.urljoin(self.rootPath, cssResourceName)
         else:
             self.rootPath = getDirName(cssFile.uri)
-        try:
-            result = self.parse(cssFile.getData())
-            self.rootPath = oldRootPath
-        except Exception as e:
-            print(e)
-        return result
 
+        result = self.parse(cssFile.getData())
+        self.rootPath = oldRootPath
+        return result
 
-class PageNumberText:
-    def __init__(self, *args, **kwargs):
-        self.data = ''
-
-    def __contains__(self, key):
-        if self.flowable.page is not None:
-            self.data = str(self.flowable.page)
-        return False
-
-    def split(self, text):
-        return [self.data]
-
-    def __getitem__(self, index):
-        if not self.data:
-            return self.data
-        return self.data[index]
-
-    def setFlowable(self, flowable):
-        self.flowable=flowable
-
-    def __str__(self):
-        return self.data
-
-class PageCountText:
-    def __init__(self, *args, **kwargs):
-        self.data = ''
-
-    def __str__(self):
-        return self.data
-
-    def __contains__(self, key):
-        if self.flowable.pagecount is not None:
-            self.data = str(self.flowable.pagecount)
-        return False
-
-    def split(self, text):
-        return [self.data]
-
-    def __getitem__(self, index):
-        if not self.data:
-            return self.data
-        return self.data[index]
-
-    def setFlowable(self, flowable):
-        self.flowable = flowable
-
-def reverse_sentence(sentence):
-    words = str(sentence).split(' ')
-    reverse_sentence = ' '.join(reversed(words))
-    reverse_sentence = reverse_sentence[::-1]
-    return reverse_sentence
 
 class pisaContext(object):
     """
     Helper class for creation of reportlab story and container for
     various data.
     """
 
     def __init__(self, path, debug=0, capacity=-1):
         self.fontList = copy.copy(xhtml2pdf.default.DEFAULT_FONT)
-        self.asianFontList = copy.copy(xhtml2pdf.util.get_default_asian_font())
-        set_value(self,
-                  ('path', 'story', 'text', 'log', 'frameStaticList',
-                   'pisaBackgroundList', 'frameList', 'anchorFrag',
-                   'anchorName', 'fragList', 'fragAnchor', 'fragStack'
-                   ), [],  _copy=True)
-
-        set_value(self, ('node', 'indexing_story',
-                         'template', 'keepInFrameIndex',
-                         'tableData', 'image'),
-                  None)
-        set_value(self, ('err', 'warn', 'uidctr', 'listCounter'), 0)
-        set_value(self, ('text', 'cssText', 'cssDefaultText'), "")
-        set_value(self, ('templateList', 'frameStatic', 'imageData'),
-                  {}, _copy=True)
+        self.path = []
         self.capacity = capacity
+
+        self.node = None
         self.toc = PmlTableOfContents()
+        self.story = []
+        self.indexing_story = None
+        self.text = []
+        self.log = []
+        self.err = 0
+        self.warn = 0
+        self.text = u""
+        self.uidctr = 0
         self.multiBuild = False
+
         self.pageSize = A4
+        self.template = None
+        self.templateList = {}
+
+        self.frameList = []
+        self.frameStatic = {}
+        self.frameStaticList = []
+        self.pisaBackgroundList = []
+
+        self.keepInFrameIndex = None
+
         self.baseFontSize = getSize("12pt")
-        self.frag = self.fragBlock = getParaFrag(
-            ParagraphStyle('default%d' % self.UID()))
+
+        self.anchorFrag = []
+        self.anchorName = []
+
+        self.tableData = None
+
+        self.frag = self.fragBlock = getParaFrag(ParagraphStyle('default%d' % self.UID()))
+        self.fragList = []
+        self.fragAnchor = []
+        self.fragStack = []
         self.fragStrip = True
+
+        self.listCounter = 0
+
+        self.cssText = ""
+        self.cssDefaultText = ""
+
+        self.image = None
+        self.imageData = {}
         self.force = False
-        self.dir = 'ltr'
 
-        # External callback function for path calculations
-        self.pathCallback = None
+        self.pathCallback = None # External callback function for path calculations
 
         # Store path to document
         self.pathDocument = path or "__dummy__"
         parts = urlparse.urlparse(self.pathDocument)
         if not parts.scheme:
-            self.pathDocument = str(Path(self.pathDocument).absolute().resolve())
+            self.pathDocument = os.path.abspath(self.pathDocument)
         self.pathDirectory = getDirName(self.pathDocument)
 
         self.meta = dict(
             author="",
             title="",
             subject="",
             keywords="",
             pagesize=A4,
         )
 
-    def setDir(self, dir):
-        if dir == 'rtl':
-            self.frag.rtl=True
-        self.dir=dir
-
     def UID(self):
         self.uidctr += 1
         return self.uidctr
 
     # METHODS FOR CSS
     def addCSS(self, value):
         value = value.strip()
@@ -534,74 +517,86 @@
         self.cssParser.rootPath = self.pathDirectory
         #self.cssParser.c = self
         self.cssParser._c = weakref.ref(self)
         pisaCSSParser.c = property(lambda self: self._c())
 
         self.css = self.cssParser.parse(self.cssText)
         self.cssDefault = self.cssParser.parse(self.cssDefaultText)
-        self.cssCascade = css.CSSCascadeStrategy(
-            userAgent=self.cssDefault, user=self.css)
+        self.cssCascade = css.CSSCascadeStrategy(userAgent=self.cssDefault, user=self.css)
         self.cssCascade.parser = self.cssParser
 
     # METHODS FOR STORY
     def addStory(self, data):
         self.story.append(data)
 
     def swapStory(self, story=None):
         story = story if story is not None else []
         self.story, story = copy.copy(story), copy.copy(self.story)
         return story
 
     def toParagraphStyle(self, first):
-        style = ParagraphStyle(
-            'default%d' % self.UID(), keepWithNext=first.keepWithNext)
-
-        copy_attrs(style, first,
-                   ('fontName', 'fontSize', 'letterSpacing', 'backColor',
-                    'spaceBefore', 'spaceAfter', 'leftIndent', 'rightIndent',
-                       'firstLineIndent', 'textColor', 'alignment',
-                       'bulletIndent', 'wordWrap', 'borderTopStyle',
-                       'borderTopWidth', 'borderTopColor',
-                       'borderBottomStyle', 'borderBottomWidth',
-                       'borderBottomColor', 'borderLeftStyle',
-                       'borderLeftWidth', 'borderLeftColor',
-                       'borderRightStyle', 'borderRightWidth',
-                       'borderRightColor', 'paddingTop', 'paddingBottom',
-                       'paddingLeft', 'paddingRight', 'borderPadding'
-                    )
-                   )
-
-        style.leading = max(
-            first.leading + first.leadingSpace, first.fontSize * 1.25)
+        style = ParagraphStyle('default%d' % self.UID(), keepWithNext=first.keepWithNext)
+        style.fontName = first.fontName
+        style.fontSize = first.fontSize
+        style.letterSpacing = first.letterSpacing
+        style.leading = max(first.leading + first.leadingSpace, first.fontSize * 1.25)
+        style.backColor = first.backColor
+        style.spaceBefore = first.spaceBefore
+        style.spaceAfter = first.spaceAfter
+        style.leftIndent = first.leftIndent
+        style.rightIndent = first.rightIndent
+        style.firstLineIndent = first.firstLineIndent
+        style.textColor = first.textColor
+        style.alignment = first.alignment
         style.bulletFontName = first.bulletFontName or first.fontName
         style.bulletFontSize = first.fontSize
+        style.bulletIndent = first.bulletIndent
+        style.wordWrap = first.wordWrap
 
         # Border handling for Paragraph
 
         # Transfer the styles for each side of the border, *not* the whole
         # border values that reportlab supports. We'll draw them ourselves in
         # PmlParagraph.
+        style.borderTopStyle = first.borderTopStyle
+        style.borderTopWidth = first.borderTopWidth
+        style.borderTopColor = first.borderTopColor
+        style.borderBottomStyle = first.borderBottomStyle
+        style.borderBottomWidth = first.borderBottomWidth
+        style.borderBottomColor = first.borderBottomColor
+        style.borderLeftStyle = first.borderLeftStyle
+        style.borderLeftWidth = first.borderLeftWidth
+        style.borderLeftColor = first.borderLeftColor
+        style.borderRightStyle = first.borderRightStyle
+        style.borderRightWidth = first.borderRightWidth
+        style.borderRightColor = first.borderRightColor
 
         # If no border color is given, the text color is used (XXX Tables!)
         if (style.borderTopColor is None) and style.borderTopWidth:
             style.borderTopColor = first.textColor
         if (style.borderBottomColor is None) and style.borderBottomWidth:
             style.borderBottomColor = first.textColor
         if (style.borderLeftColor is None) and style.borderLeftWidth:
             style.borderLeftColor = first.textColor
         if (style.borderRightColor is None) and style.borderRightWidth:
             style.borderRightColor = first.textColor
 
+        style.borderPadding = first.borderPadding
+
+        style.paddingTop = first.paddingTop
+        style.paddingBottom = first.paddingBottom
+        style.paddingLeft = first.paddingLeft
+        style.paddingRight = first.paddingRight
         style.fontName = tt2ps(first.fontName, first.bold, first.italic)
 
         return style
 
     def addTOC(self):
         styles = []
-        for i in range(20):
+        for i in six.moves.range(20):
             self.node.attributes["class"] = "pdftoclevel%d" % i
             self.cssAttr = xhtml2pdf.parser.CSSCollect(self.node, self)
             xhtml2pdf.parser.CSS2Frag(self, {
                 "margin-top": 0,
                 "margin-bottom": 0,
                 "margin-left": 0,
                 "margin-right": 0,
@@ -614,55 +609,48 @@
         self.indexing_story = None
 
     def addPageCount(self):
         if not self.multiBuild:
             self.indexing_story = PmlPageCount()
             self.multiBuild = True
 
-    def getPageCount(self, flow):
-        pc=PageCountText()
-        pc.setFlowable(flow)
-        return pc
-
-    def addPageNumber(self, flow):
-        pgnumber = PageNumberText()
-        pgnumber.setFlowable(flow)
-        return pgnumber
-
     def dumpPara(self, frags, style):
         return
 
     def addPara(self, force=False):
 
         force = (force or self.force)
         self.force = False
 
         # Cleanup the trail
-        rfragList = reversed(self.fragList)
+        try:
+            rfragList = reversed(self.fragList)
+        except:
+            # For Python 2.3 compatibility
+            rfragList = copy.copy(self.fragList)
+            rfragList.reverse()
 
         # Find maximum lead
         maxLeading = 0
         #fontSize = 0
         for frag in self.fragList:
-            leading = getSize(
-                frag.leadingSource, frag.fontSize) + frag.leadingSpace
-            maxLeading = max(
-                leading, frag.fontSize + frag.leadingSpace, maxLeading)
+            leading = getSize(frag.leadingSource, frag.fontSize) + frag.leadingSpace
+            maxLeading = max(leading, frag.fontSize + frag.leadingSpace, maxLeading)
             frag.leading = leading
 
         if force or (self.text.strip() and self.fragList):
+
             # Update paragraph style by style of first fragment
             first = self.fragBlock
             style = self.toParagraphStyle(first)
             # style.leading = first.leading + first.leadingSpace
             if first.leadingSpace:
                 style.leading = maxLeading
             else:
-                style.leading = getSize(
-                    first.leadingSource, first.fontSize) + first.leadingSpace
+                style.leading = getSize(first.leadingSource, first.fontSize) + first.leadingSpace
 
             bulletText = copy.copy(first.bulletText)
             first.bulletText = None
 
             # Add paragraph to story
             if force or len(self.fragAnchor + self.fragList) > 0:
 
@@ -673,27 +661,19 @@
                 else:
                     blank = self.frag.clone()
                     blank.fontName = "Helvetica"
                     blank.text = ''
                     self.fragList.append(blank)
 
                 self.dumpPara(self.fragAnchor + self.fragList, style)
-                if hasattr(self, 'language'):
-                    language = self.__getattribute__('language')
-                    detect_language_result = arabic_format(self.text, language)
-                    if detect_language_result != None:
-                        self.text = detect_language_result
-
                 para = PmlParagraph(
                     self.text,
                     style,
                     frags=self.fragAnchor + self.fragList,
-                    bulletText=bulletText,
-                    dir=self.dir
-                )
+                    bulletText=bulletText)
 
                 para.outline = first.outline
                 para.outlineLevel = first.outlineLevel
                 para.outlineOpen = first.outlineOpen
                 para.keepWithNext = first.keepWithNext
                 para.autoLeading = "max"
 
@@ -739,31 +719,24 @@
         frag = baseFrag = self.frag.clone()
 
         # if sub and super are both on they will cancel each other out
         if frag.sub == 1 and frag.super == 1:
             frag.sub = 0
             frag.super = 0
 
-        # XXX Has to be replaced by CSS styles like vertical-align and
-        # font-size
+        # XXX Has to be replaced by CSS styles like vertical-align and font-size
         if frag.sub:
             frag.rise = - frag.fontSize * subFraction
             frag.fontSize = max(frag.fontSize - sizeDelta, 3)
         elif frag.super:
             frag.rise = frag.fontSize * superFraction
             frag.fontSize = max(frag.fontSize - sizeDelta, 3)
 
        # bold, italic, and underline
-        frag.fontName = frag.bulletFontName = tt2ps(
-            frag.fontName, frag.bold, frag.italic)
-        if isinstance(text, (PageNumberText, PageCountText)):
-            frag.text = text
-            #self.text += frag.text
-            self._appendFrag(frag)
-            return
+        frag.fontName = frag.bulletFontName = tt2ps(frag.fontName, frag.bold, frag.italic)
 
         # Replace &shy; with empty and normalize NBSP
         text = (text
                 .replace(u"\xad", u"")
                 .replace(u"\xc2\xa0", NBSP)
                 .replace(u"\xa0", NBSP))
 
@@ -787,27 +760,23 @@
                     for text in re.split(r'(\ )', text):
                         frag = baseFrag.clone()
                         if text == " ":
                             text = NBSP
                         frag.text = text
                         self._appendFrag(frag)
         else:
-
             for text in re.split(u'(' + NBSP + u')', text):
                 frag = baseFrag.clone()
                 if text == NBSP:
                     self.force = True
                     frag.text = NBSP
                     self.text += text
                     self._appendFrag(frag)
                 else:
                     frag.text = " ".join(("x" + text + "x").split())[1: - 1]
-                    language_check = frag_text_language_check(self, frag.text)
-                    if language_check:
-                        frag.text = language_check
                     if self.fragStrip:
                         frag.text = frag.text.lstrip()
                         if frag.text:
                             self.fragStrip = False
                     self.text += frag.text
                     self._appendFrag(frag)
 
@@ -831,149 +800,159 @@
     def context(self, msg):
         return "%s\n%s" % (
             str(msg),
             self._getFragment(50))
 
     def warning(self, msg, *args):
         self.warn += 1
-        self.log.append((xhtml2pdf.default.PML_WARNING, self._getLineNumber(), str(
-            msg), self._getFragment(50)))
+        self.log.append((xhtml2pdf.default.PML_WARNING, self._getLineNumber(), str(msg), self._getFragment(50)))
         try:
             return self.context(msg % args)
         except:
             return self.context(msg)
 
     def error(self, msg, *args):
         self.err += 1
-        self.log.append((xhtml2pdf.default.PML_ERROR, self._getLineNumber(), str(
-            msg), self._getFragment(50)))
+        self.log.append((xhtml2pdf.default.PML_ERROR, self._getLineNumber(), str(msg), self._getFragment(50)))
         try:
             return self.context(msg % args)
         except:
             return self.context(msg)
 
+    # UTILS
+    def _getFileDeprecated(self, name, relative):
+        try:
+            path = relative or self.pathDirectory
+            if name.startswith("data:"):
+                return name
+            if self.pathCallback is not None:
+                nv = self.pathCallback(name, relative)
+            else:
+                if path is None:
+                    log.warn("Could not find main directory for getting filename. Use CWD")
+                    path = os.getcwd()
+                nv = os.path.normpath(os.path.join(path, name))
+                if not (nv and os.path.isfile(nv)):
+                    nv = None
+            if nv is None:
+                log.warn(self.warning("File '%s' does not exist", name))
+            return nv
+        except:
+            log.warn(self.warning("getFile %r %r %r", name, relative, path), exc_info=1)
+
     def getFile(self, name, relative=None):
         """
         Returns a file name or None
         """
-        if name is None:
-            return
-        return getFile(name, relative or self.pathDirectory, callback=self.pathCallback)
+        if self.pathCallback is not None:
+            return getFile(self._getFileDeprecated(name, relative))
+        return getFile(name, relative or self.pathDirectory)
 
     def getFontName(self, names, default="helvetica"):
         """
         Name of a font
         """
         # print names, self.fontList
         if type(names) is not ListType:
-            names = str(names)
+            if type(names) not in six.string_types:
+                names = str(names)
             names = names.strip().split(",")
         for name in names:
-            name = str(name)
-            font = name.strip().lower()
-            if font in self.asianFontList:
-                font = self.asianFontList.get(font, None)
-                set_asian_fonts(font)
-            else:
-                font = self.fontList.get(font,None)
+            if type(name) not in six.string_types:
+                name = str(name)
+            font = self.fontList.get(name.strip().lower(), None)
             if font is not None:
                 return font
         return self.fontList.get(default, None)
 
     def registerFont(self, fontname, alias=None):
         alias = alias if alias is not None else []
         self.fontList[str(fontname).lower()] = str(fontname)
         for a in alias:
-            self.fontList[str(a)] = str(fontname)
+            if type(fontname) not in six.string_types:
+                fontname = str(fontname)
+            self.fontList[str(a)] = fontname
 
-    # TODO: convert to getFile to support remotes fonts
     def loadFont(self, names, src, encoding="WinAnsiEncoding", bold=0, italic=0):
+
         # XXX Just works for local filenames!
         if names and src:
 
             file = src
             src = file.uri
 
             log.debug("Load font %r", src)
-            if isinstance(names, str) and names.startswith("#"):
-                names = names.strip('#')
+
             if type(names) is ListType:
                 fontAlias = names
             else:
                 fontAlias = (x.lower().strip() for x in names.split(",") if x)
 
             # XXX Problems with unicode here
             fontAlias = [str(x) for x in fontAlias]
 
-            ffname = names
             fontName = fontAlias[0]
             parts = src.split(".")
             baseName, suffix = ".".join(parts[: - 1]), parts[- 1]
             suffix = suffix.lower()
 
             if suffix in ["ttc", "ttf"]:
 
                 # determine full font name according to weight and style
                 fullFontName = "%s_%d%d" % (fontName, bold, italic)
 
                 # check if font has already been registered
                 if fullFontName in self.fontList:
-                    log.warning(
-                        self.warning("Repeated font embed for %s, skip new embed ", fullFontName))
+                    log.warn(self.warning("Repeated font embed for %s, skip new embed ", fullFontName))
                 else:
 
                     # Register TTF font and special name
                     filename = file.getNamedFile()
-                    file = TTFont(fullFontName, filename)
-                    pdfmetrics.registerFont(file)
+                    pdfmetrics.registerFont(TTFont(fullFontName, filename))
 
                     # Add or replace missing styles
                     for bold in (0, 1):
                         for italic in (0, 1):
                             if ("%s_%d%d" % (fontName, bold, italic)) not in self.fontList:
-                                addMapping(
-                                    fontName, bold, italic, fullFontName)
+                                addMapping(fontName, bold, italic, fullFontName)
 
                     # Register "normal" name and the place holder for style
                     self.registerFont(fontName, fontAlias + [fullFontName])
 
             elif suffix in ("afm", "pfb"):
 
                 if suffix == "afm":
                     afm = file.getNamedFile()
-                    tfile = pisaFileObject(baseName + ".pfb", basepath=file.basepath)
+                    tfile = pisaFileObject(baseName + ".pfb")
                     pfb = tfile.getNamedFile()
                 else:
                     pfb = file.getNamedFile()
-                    tfile = pisaFileObject(baseName + ".afm", basepath=file.basepath)
+                    tfile = pisaFileObject(baseName + ".afm")
                     afm = tfile.getNamedFile()
 
                 # determine full font name according to weight and style
                 fullFontName = "%s_%d%d" % (fontName, bold, italic)
 
                 # check if font has already been registered
                 if fullFontName in self.fontList:
-                    log.warning(
-                        self.warning("Repeated font embed for %s, skip new embed", fontName))
+                    log.warn(self.warning("Repeated font embed for %s, skip new embed", fontName))
                 else:
 
                     # Include font
                     face = pdfmetrics.EmbeddedType1Face(afm, pfb)
                     fontNameOriginal = face.name
                     pdfmetrics.registerTypeFace(face)
                     # print fontName, fontNameOriginal, fullFontName
-                    justFont = pdfmetrics.Font(
-                        fullFontName, fontNameOriginal, encoding)
+                    justFont = pdfmetrics.Font(fullFontName, fontNameOriginal, encoding)
                     pdfmetrics.registerFont(justFont)
 
                     # Add or replace missing styles
                     for bold in (0, 1):
                         for italic in (0, 1):
                             if ("%s_%d%d" % (fontName, bold, italic)) not in self.fontList:
-                                addMapping(
-                                    fontName, bold, italic, fontNameOriginal)
+                                addMapping(fontName, bold, italic, fontNameOriginal)
 
                     # Register "normal" name and the place holder for style
-                    self.registerFont(
-                        fontName, fontAlias + [fullFontName, fontNameOriginal])
+                    self.registerFont(fontName, fontAlias + [fullFontName, fontNameOriginal])
             else:
                 log.warning(self.warning("wrong attributes for <pdf:font>"))
+
```

## Comparing `xhtml2pdf/default.py` & `xhtml2pdf-0.2b1/xhtml2pdf/default.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,8 +1,10 @@
 # -*- coding: utf-8 -*-
+from reportlab.lib.pagesizes import (A0, A1, A2, A3, A4, A5, A6, B0, B1, B2, B3,
+                                     B4, B5, B6, LETTER, LEGAL, ELEVENSEVENTEEN)
 
 # Copyright 2010 Dirk Holtwick, holtwick.it
 #
 # Licensed under the Apache License, Version 2.0 (the "License");
 # you may not use this file except in compliance with the License.
 # You may obtain a copy of the License at
 #
@@ -10,20 +12,14 @@
 #
 # Unless required by applicable law or agreed to in writing, software
 # distributed under the License is distributed on an "AS IS" BASIS,
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
-from reportlab.lib.pagesizes import (A0, A1, A2, A3, A4, A5, A6,A7, A8, A9, A10,
-                                     B0, B1, B2, B3, B4, B5, B6, B7, B8, B9, B10,
-                                     C0, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10,
-                                     JUNIOR_LEGAL, HALF_LETTER, GOV_LETTER, GOV_LEGAL, TABLOID, LEDGER,
-                                     ELEVENSEVENTEEN, LEGAL, LETTER)
-
 PML_WARNING = "warning"
 PML_ERROR = "error"
 PML_EXCEPTION = "PML Exception"
 PML_PREFIX = "pdf:"
 
 #CLASS   = 1
 BOOL = 2
@@ -96,18 +92,14 @@
     "pdffont": (0, {
         "src": (FILE, MUST),
         "name": (STRING, MUST),
         # "print":                (BOOL, "0"),
         "encoding": (STRING, "WinAnsiEncoding"),
     }),
 
-    "pdflanguage": (0, {
-        "name": (STRING, ""),
-    }),
-
     "pdfdrawline": (0, {
         "from": (POS, MUST),
         "to": (POS, MUST),
         "color": (COLOR, "#000000"),
         "width": (SIZE, 1),
     }),
 
@@ -295,15 +287,14 @@
     }),
 
     "dt": (1, {
     }),
 
     "ol": (1, {
         "type": (["1", "a", "A", "i", "I"], "1"),
-        "start": INT,
     }),
 
     "ul": (1, {
         "type": (["circle", "disk", "square"], "disk"),
     }),
 
     "li": (1, {
@@ -314,25 +305,20 @@
         "size": (SIZE, "1"),
         "width": STRING,
         "align": ["left", "center", "right", "justify"],
     }),
 
     "div": (1, {
         "align": ["left", "center", "right", "justify"],
-        "dir": ["ltr", "rtl"]
     }),
 
     "p": (1, {
         "align": ["left", "center", "right", "justify"],
-        "dir": ["ltr", "rtl"]
     }),
 
-    "body": (1, {
-        "dir": ["ltr", "rtl"]
-    }),
     "br": (0, {
     }),
 
     "h1": (1, {
         "outline": STRING,
         "closed": (INT, 0),
         "align": ["left", "center", "right", "justify"],
@@ -383,16 +369,14 @@
         "name": STRING,
         "value": STRING,
         "type": (["text", "hidden", "checkbox"], "text"),
     }),
 
     "textarea": (1, {
         "name": STRING,
-        "cols": (SIZE, 40),
-        "rows": (SIZE, 1),
     }),
 
     "select": (1, {
         "name": STRING,
         "value": STRING,
     }),
 
@@ -404,14 +388,15 @@
 # XXX use "html" not "*" as default!
 DEFAULT_CSS = """
 html {
     font-family: Helvetica;
     font-size: 10px;
     font-weight: normal;
     color: #000000;
+    background-color: transparent;
     margin: 0;
     padding: 0;
     line-height: 150%;
     border: 1px none;
     display: inline;
     width: auto;
     height: auto;
@@ -590,41 +575,28 @@
 }
 
 ol {
     list-style-type: decimal;
     margin-left: 1.5em;
 }
 
-ul li div:first-child {
-    display: inline-block;
-}
-
 pre {
     white-space: pre;
 }
 
 blockquote {
     margin-left: 1.5em;
     margin-right: 1.5em;
 }
 
 noscript {
     display: none;
 }
 """
 
-DEFAULT_LANGUAGE_LIST = {
-    "arabic": "arabic",
-    "hebrew": "hebrew",
-    "persian": "persian",
-    "urdu": "urdu",
-    "pashto": "pashto",
-    "sindhi": "sindhi"
-}
-
 DEFAULT_FONT = {
     "courier": "Courier",
     "courier-bold": "Courier-Bold",
     "courier-boldoblique": "Courier-BoldOblique",
     "courier-oblique": "Courier-Oblique",
     "helvetica": "Helvetica",
     "helvetica-bold": "Helvetica-Bold",
@@ -658,43 +630,19 @@
     "a0": A0,
     "a1": A1,
     "a2": A2,
     "a3": A3,
     "a4": A4,
     "a5": A5,
     "a6": A6,
-    "a7": A7,
-    "a8": A8,
-    "a9": A9,
-    "a10": A10,
     "b0": B0,
     "b1": B1,
     "b2": B2,
     "b3": B3,
     "b4": B4,
     "b5": B5,
     "b6": B6,
-    "b7": B7,
-    "b8": B8,
-    "b9": B9,
-    "b10": B10,
-    "c0": C0,
-    "c1": C1,
-    "c2": C2,
-    "c3": C3,
-    "c4": C4,
-    "c5": C5,
-    "c6": C6,
-    "c7": C7,
-    "c8": C8,
-    "c9": C9,
-    "c10": C10,
     "letter": LETTER,
     "legal": LEGAL,
-    "ledger": LEDGER,
+    "ledger": ELEVENSEVENTEEN,
     "elevenseventeen": ELEVENSEVENTEEN,
-    "juniorlegal": JUNIOR_LEGAL,
-    "halfletter": HALF_LETTER,
-    "govletter": GOV_LETTER,
-    "govlegal": GOV_LEGAL,
-    "tabloid": TABLOID
 }
```

## Comparing `xhtml2pdf/document.py` & `xhtml2pdf-0.2b1/xhtml2pdf/document.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,8 +1,19 @@
 # -*- coding: utf-8 -*-
+import io
+
+from xhtml2pdf.context import pisaContext
+from xhtml2pdf.default import DEFAULT_CSS
+from xhtml2pdf.parser import pisaParser
+from reportlab.platypus.flowables import Spacer
+from reportlab.platypus.frames import Frame
+from xhtml2pdf.xhtml2pdf_reportlab import PmlBaseDoc, PmlPageTemplate
+from xhtml2pdf.util import pisaTempFile, getBox, PyPDF2
+import cgi
+import logging
 
 # Copyright 2010 Dirk Holtwick, holtwick.it
 #
 # Licensed under the Apache License, Version 2.0 (the "License");
 # you may not use this file except in compliance with the License.
 # You may obtain a copy of the License at
 #
@@ -10,48 +21,28 @@
 #
 # Unless required by applicable law or agreed to in writing, software
 # distributed under the License is distributed on an "AS IS" BASIS,
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
-import io
-import logging
-
-from reportlab.lib import pdfencrypt
-from reportlab.platypus.flowables import Spacer
-from reportlab.platypus.frames import Frame
-
-from xhtml2pdf.builders.signs import PDFSignature
-from xhtml2pdf.builders.watermarks import WaterMarks
-from xhtml2pdf.context import pisaContext
-from xhtml2pdf.default import DEFAULT_CSS
-from xhtml2pdf.parser import pisaParser
-from xhtml2pdf.util import pypdf, getBox
-from xhtml2pdf.files import pisaTempFile, cleanFiles
-from xhtml2pdf.xhtml2pdf_reportlab import PmlBaseDoc, PmlPageTemplate
-
-from html import escape as html_escape
-
 log = logging.getLogger("xhtml2pdf")
 
 
 def pisaErrorDocument(dest, c):
     out = pisaTempFile(capacity=c.capacity)
     out.write("<p style='background-color:red;'><strong>%d error(s) occured:</strong><p>" % c.err)
     for mode, line, msg, _ in c.log:
         if mode == "error":
-            out.write("<pre>%s in line %d: %s</pre>" %
-                      (mode, line, html_escape(msg)))
+            out.write("<pre>%s in line %d: %s</pre>" % (mode, line, cgi.escape(msg)))
 
     out.write("<p><strong>%d warning(s) occured:</strong><p>" % c.warn)
     for mode, line, msg, _ in c.log:
         if mode == "warning":
-            out.write("<p>%s in line %d: %s</p>" %
-                      (mode, line, html_escape(msg)))
+            out.write("<p>%s in line %d: %s</p>" % (mode, line, cgi.escape(msg)))
 
     return pisaDocument(out.getvalue(), dest, raise_exception=False)
 
 
 def pisaStory(src, path=None, link_callback=None, debug=0, default_css=None,
               xhtml=False, encoding=None, context=None, xml_output=None,
               **kw):
@@ -77,28 +68,17 @@
     # Remove anchors if they do not exist (because of a bug in Reportlab)
     for frag, anchor in context.anchorFrag:
         if anchor not in context.anchorName:
             frag.link = None
     return context
 
 
-def get_encrypt_instance(data):
-    if data is None:
-        return
-
-    if isinstance(data, str):
-        return pdfencrypt.StandardEncryption(data)
-
-    return data
-
-
-def pisaDocument(src, dest=None, dest_bytes=False, path=None, link_callback=None, debug=0,
+def pisaDocument(src, dest=None, path=None, link_callback=None, debug=0,
                  default_css=None, xhtml=False, encoding=None, xml_output=None,
                  raise_exception=True, capacity=100 * 1024, context_meta=None,
-                 encrypt=None, signature=None,
                  **kw):
     log.debug("pisaDocument options:\n  src = %r\n  dest = %r\n  path = %r\n  link_callback = %r\n  xhtml = %r\n  context_meta = %r",
               src,
               dest,
               path,
               link_callback,
               xhtml,
@@ -124,15 +104,14 @@
         pagesize=context.pageSize,
         author=context.meta["author"].strip(),
         subject=context.meta["subject"].strip(),
         keywords=[x.strip() for x in
                   context.meta["keywords"].strip().split(",") if x],
         title=context.meta["title"].strip(),
         showBoundary=0,
-        encrypt=get_encrypt_instance(encrypt),
         allowSplitting=1)
 
     # Prepare templates and their frames
     if "body" in context.templateList:
         body = context.templateList["body"]
         del context.templateList["body"]
     else:
@@ -153,38 +132,54 @@
     # Use multibuild e.g. if a TOC has to be created
     if context.multiBuild:
         doc.multiBuild(context.story)
     else:
         doc.build(context.story)
 
     # Add watermarks
-    output=io.BytesIO()
-    output, has_bg=WaterMarks.process_doc(context, out, output)
-
-    if not has_bg:
-        output=out
-    if signature:
-        signoutput = io.BytesIO()
-        do_ok=PDFSignature.sign(output,signoutput, signature)
-        if do_ok:
-            output=signoutput
+    if PyPDF2:
+        for bgouter in context.pisaBackgroundList:
+            # If we have at least one background, then lets do it
+            if bgouter:
+                istream = out
+
+                output = PyPDF2.PdfFileWriter()
+                input1 = PyPDF2.PdfFileReader(istream)
+                ctr = 0
+                # TODO: Why do we loop over the same list again?
+                # see bgouter at line 137
+                for bg in context.pisaBackgroundList:
+                    page = input1.getPage(ctr)
+                    if (
+                            bg and not bg.notFound() and
+                            (bg.mimetype == "application/pdf")
+                    ):
+                        bginput = PyPDF2.PdfFileReader(bg.getFile())
+                        pagebg = bginput.getPage(0)
+                        pagebg.mergePage(page)
+                        page = pagebg
+                    else:
+                        log.warn(context.warning(
+                            "Background PDF %s doesn't exist.", bg))
+                    output.addPage(page)
+                    ctr += 1
+                out = pisaTempFile(capacity=context.capacity)
+                output.write(out)
+                # data = sout.getvalue()
+                # Found a background? So leave loop after first occurence
+                break
+    else:
+        log.warn(context.warning("PyPDF2 not installed!"))
 
     # Get the resulting PDF and write it to the file object
     # passed from the caller
-    
-    # Get the resulting PDF and write it to the file object
-    # passed from the caller
 
     if dest is None:
         # No output file was passed - Let's use a pisaTempFile
         dest = io.BytesIO()
     context.dest = dest
 
-    data = output.getvalue()
+    data = out.getvalue()
+
     context.dest.write(data)  # TODO: context.dest is a tempfile as well...
-    cleanFiles()
-    
-    if dest_bytes:
-        return data
-    
+
     return context
-
```

## Comparing `xhtml2pdf/parser.py` & `xhtml2pdf-0.2b1/xhtml2pdf/parser.py`

 * *Files 20% similar despite different names*

```diff
@@ -9,150 +9,101 @@
 #     http://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software
 # distributed under the License is distributed on an "AS IS" BASIS,
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
 # limitations under the License.
-
+from __future__ import print_function, unicode_literals
+from html5lib import treebuilders #, inputstream
+from xhtml2pdf.default import TAGS, STRING, INT, BOOL, SIZE, COLOR, FILE
+from xhtml2pdf.default import BOX, POS, MUST, FONT
+from xhtml2pdf.util import getSize, getBool, toList, getColor, getAlign
+from xhtml2pdf.util import getBox, getPos, pisaTempFile
+from reportlab.platypus.doctemplate import NextPageTemplate, FrameBreak
+from reportlab.platypus.flowables import PageBreak, KeepInFrame
+from xhtml2pdf.xhtml2pdf_reportlab import PmlRightPageBreak, PmlLeftPageBreak
+from xhtml2pdf.tags import * # TODO: Kill wild import!
+from xhtml2pdf.tables import * # TODO: Kill wild import!
+from xhtml2pdf.util import * # TODO: Kill wild import!
+from xml.dom import Node
 import copy
+import html5lib
 import logging
 import re
-import xml.dom.minidom
-from xml.dom import Node
+import six
 
-import html5lib
-from html5lib import treebuilders
-from reportlab.platypus.doctemplate import FrameBreak, NextPageTemplate
-from reportlab.platypus.flowables import KeepInFrame, PageBreak
-
-from xhtml2pdf.default import BOOL, BOX, COLOR, FILE, FONT, INT, MUST, POS, SIZE, STRING, TAGS
-
-# TODO: Why do we need to import these Tags here? They aren't uses in this file or any other file,
-#  but if we don't import them, Travis & AppVeyor fail. Very strange (fbernhart)
-from xhtml2pdf.tables import (TableData,
-                              pisaTagTABLE,
-                              pisaTagTD,
-                              pisaTagTR,
-                              pisaTagTH)
-
-from xhtml2pdf.tags import (pisaTagIMG,
-                            pisaTagPDFLANGUAGE,
-                            pisaTagPDFNEXTPAGE,
-                            pisaTag,
-                            pisaTagA,
-                            pisaTagBODY,
-                            pisaTagBR,
-                            pisaTagDIV,
-                            pisaTagFONT,
-                            pisaTagH1,
-                            pisaTagH2,
-                            pisaTagH3,
-                            pisaTagH4,
-                            pisaTagH5,
-                            pisaTagH6,
-                            pisaTagHR,
-                            pisaTagLI,
-                            pisaTagMETA,
-                            pisaTagOL,
-                            pisaTagP,
-                            pisaTagPDFBARCODE,
-                            pisaTagPDFFONT,
-                            pisaTagPDFFRAME,
-                            pisaTagPDFNEXTFRAME,
-                            pisaTagPDFNEXTTEMPLATE,
-                            pisaTagPDFPAGECOUNT,
-                            pisaTagPDFPAGENUMBER,
-                            pisaTagPDFSPACER,
-                            pisaTagPDFTEMPLATE,
-                            pisaTagPDFTOC,
-                            pisaTagSTYLE,
-                            pisaTagSUB,
-                            pisaTagSUP,
-                            pisaTagTITLE,
-                            pisaTagUL,
-                            pisaTagINPUT,
-                            pisaTagTEXTAREA,
-                            # pisaTagSELECT,
-                            # pisaTagOPTION
-                            )
-from xhtml2pdf.files import pisaTempFile
-from xhtml2pdf.util import getAlign, getBool, getBox, getColor, getPos, getSize, toList, transform_attrs
-from xhtml2pdf.w3c import cssDOMElementInterface
-from xhtml2pdf.xhtml2pdf_reportlab import PmlLeftPageBreak, PmlRightPageBreak
+import xhtml2pdf.w3c.cssDOMElementInterface as cssDOMElementInterface
+import xml.dom.minidom
 
 CSSAttrCache = {}
 
 log = logging.getLogger("xhtml2pdf")
 
 rxhttpstrip = re.compile("https?://[^/]+(.*)", re.M | re.I)
 
 
 class AttrContainer(dict):
-
     def __getattr__(self, name):
         try:
             return dict.__getattr__(self, name)
         except:
             return self[name]
 
 
 def pisaGetAttributes(c, tag, attributes):
+    global TAGS
 
     attrs = {}
     if attributes:
         for k, v in attributes.items():
             try:
-                # XXX no Unicode! Reportlab fails with template names
-                attrs[str(k)] = str(v)
+                attrs[str(k)] = str(v)  # XXX no Unicode! Reportlab fails with template names
             except:
                 attrs[k] = v
 
     nattrs = {}
     if tag in TAGS:
         block, adef = TAGS[tag]
         adef["id"] = STRING
 
-        for k, v in adef.items():
+        for k, v in six.iteritems(adef):
             nattrs[k] = None
             # print k, v
             # defaults, wenn vorhanden
             if type(v) == tuple:
                 if v[1] == MUST:
                     if k not in attrs:
-                        log.warning(
-                            c.warning("Attribute '%s' must be set!", k))
+                        log.warn(c.warning("Attribute '%s' must be set!", k))
                         nattrs[k] = None
                         continue
                 nv = attrs.get(k, v[1])
                 dfl = v[1]
                 v = v[0]
             else:
                 nv = attrs.get(k, None)
                 dfl = None
 
             if nv is not None:
                 if type(v) == list:
                     nv = nv.strip().lower()
                     if nv not in v:
                         #~ raise PML_EXCEPTION, "attribute '%s' of wrong value, allowed is one of: %s" % (k, repr(v))
-                        log.warning(
-                            c.warning("Attribute '%s' of wrong value, allowed is one of: %s", k, repr(v)))
+                        log.warn(c.warning("Attribute '%s' of wrong value, allowed is one of: %s", k, repr(v)))
                         nv = dfl
 
                 elif v == BOOL:
                     nv = nv.strip().lower()
                     nv = nv in ("1", "y", "yes", "true", str(k))
 
                 elif v == SIZE:
                     try:
                         nv = getSize(nv)
                     except:
-                        log.warning(
-                            c.warning("Attribute '%s' expects a size value", k))
+                        log.warn(c.warning("Attribute '%s' expects a size value", k))
 
                 elif v == BOX:
                     nv = getBox(nv, c.pageSize)
 
                 elif v == POS:
                     nv = getPos(nv, c.pageSize)
 
@@ -237,64 +188,59 @@
     except LookupError:
         result = None
 
     # XXX Workaround for inline styles
     try:
         style = self.cssStyle
     except:
-        style = self.cssStyle = cssCascade.parser.parseInline(
-            self.cssElement.getStyleAttr() or '')[0]
+        style = self.cssStyle = cssCascade.parser.parseInline(self.cssElement.getStyleAttr() or '')[0]
     if attrName in style:
         result = style[attrName]
 
     if result == 'inherit':
         if hasattr(self.parentNode, 'getCSSAttr'):
             result = self.parentNode.getCSSAttr(cssCascade, attrName, default)
         elif default is not NotImplemented:
             return default
-        raise LookupError(
-            "Could not find inherited CSS attribute value for '%s'" % (attrName,))
+        raise LookupError("Could not find inherited CSS attribute value for '%s'" % (attrName,))
 
     if result is not None:
         self.cssAttrs[attrName] = result
     return result
 
 
-# TODO: Monkeypatching standard lib should go away.
+#TODO: Monkeypatching standard lib should go away.
 xml.dom.minidom.Element.getCSSAttr = getCSSAttr
 
 # Create an aliasing system.  Many sources use non-standard tags, because browsers allow
 # them to.  This allows us to map a nonstandard name to the standard one.
 nonStandardAttrNames = {
     'bgcolor': 'background-color',
 }
 
-
 def mapNonStandardAttrs(c, n, attrList):
     for attr in nonStandardAttrNames:
         if attr in attrList and nonStandardAttrNames[attr] not in c:
             c[nonStandardAttrNames[attr]] = attrList[attr]
     return c
 
-
 def getCSSAttrCacheKey(node):
     _cl = _id = _st = ''
     for k, v in node.attributes.items():
         if k == 'class':
             _cl = v
         elif k == 'id':
             _id = v
         elif k == 'style':
             _st = v
     return "%s#%s#%s#%s#%s" % (id(node.parentNode), node.tagName.lower(), _cl, _id, _st)
 
-
 def CSSCollect(node, c):
     #node.cssAttrs = {}
-    # return node.cssAttrs
+    #return node.cssAttrs
 
     if c.css:
 
         _key = getCSSAttrCacheKey(node)
 
         if hasattr(node.parentNode, "tagName"):
             if node.parentNode.tagName.lower() != "html":
@@ -305,45 +251,42 @@
 
         node.cssElement = cssDOMElementInterface.CSSDOMElementInterface(node)
         node.cssAttrs = {}
         # node.cssElement.onCSSParserVisit(c.cssCascade.parser)
         cssAttrMap = {}
         for cssAttrName in attrNames:
             try:
-                cssAttrMap[cssAttrName] = node.getCSSAttr(
-                    c.cssCascade, cssAttrName)
-            # except LookupError:
+                cssAttrMap[cssAttrName] = node.getCSSAttr(c.cssCascade, cssAttrName)
+            #except LookupError:
             #    pass
-            except Exception:  # TODO: Kill this catch-all!
+            except Exception: # TODO: Kill this catch-all!
                 log.debug("CSS error '%s'", cssAttrName, exc_info=1)
 
         CSSAttrCache[_key] = node.cssAttrs
-    return node.cssAttrs
 
+    return node.cssAttrs
 
 def lower(sequence):
-    if isinstance(sequence, str):
+    if isinstance(sequence, six.string_types):
         return sequence.lower()
     else:
         return sequence[0].lower()
 
-
 def CSS2Frag(c, kw, isBlock):
     # COLORS
     if "color" in c.cssAttr:
-        c.frag.textColor = getColor(c.cssAttr["color"], "#000000")
+        c.frag.textColor = getColor(c.cssAttr["color"])
     if "background-color" in c.cssAttr:
-        c.frag.backColor = getColor(c.cssAttr["background-color"], "#ffffff")
+        c.frag.backColor = getColor(c.cssAttr["background-color"])
         # FONT SIZE, STYLE, WEIGHT
     if "font-family" in c.cssAttr:
         c.frag.fontName = c.getFontName(c.cssAttr["font-family"])
     if "font-size" in c.cssAttr:
         # XXX inherit
-        c.frag.fontSize = max(
-            getSize("".join(c.cssAttr["font-size"]), c.frag.fontSize, c.baseFontSize), 1.0)
+        c.frag.fontSize = max(getSize("".join(c.cssAttr["font-size"]), c.frag.fontSize, c.baseFontSize), 1.0)
     if "line-height" in c.cssAttr:
         leading = "".join(c.cssAttr["line-height"])
         c.frag.leading = getSize(leading, c.frag.fontSize)
         c.frag.leadingSource = leading
     else:
         c.frag.leading = getSize(c.frag.leadingSource, c.frag.fontSize)
     if "letter-spacing" in c.cssAttr:
@@ -378,211 +321,188 @@
     if "text-align" in c.cssAttr:
         c.frag.alignment = getAlign(c.cssAttr["text-align"])
     if "vertical-align" in c.cssAttr:
         c.frag.vAlign = c.cssAttr["vertical-align"]
         # HEIGHT & WIDTH
     if "height" in c.cssAttr:
         try:
-            # XXX Relative is not correct!
-            c.frag.height = "".join(toList(c.cssAttr["height"]))
+            c.frag.height = "".join(toList(c.cssAttr["height"]))  # XXX Relative is not correct!
         except TypeError:
             # sequence item 0: expected string, tuple found
             c.frag.height = "".join(toList(c.cssAttr["height"][0]))
         if c.frag.height in ("auto",):
             c.frag.height = None
     if "width" in c.cssAttr:
         try:
-            # XXX Relative is not correct!
-            c.frag.width = "".join(toList(c.cssAttr["width"]))
+            c.frag.width = "".join(toList(c.cssAttr["width"]))  # XXX Relative is not correct!
         except TypeError:
             c.frag.width = "".join(toList(c.cssAttr["width"][0]))
         if c.frag.width in ("auto",):
             c.frag.width = None
         # ZOOM
     if "zoom" in c.cssAttr:
-        # XXX Relative is not correct!
-        zoom = "".join(toList(c.cssAttr["zoom"]))
+        zoom = "".join(toList(c.cssAttr["zoom"]))  # XXX Relative is not correct!
         if zoom.endswith("%"):
             zoom = float(zoom[: - 1]) / 100.0
         c.frag.zoom = float(zoom)
         # MARGINS & LIST INDENT, STYLE
     if isBlock:
-        transform_attrs(c.frag,
-                        (("spaceBefore", "margin-top"),
-                         ("spaceAfter", "margin-bottom"),
-                         ("firstLineIndent", "text-indent"),
-                         ),
-                        c.cssAttr,
-                        getSize,
-                        extras=c.frag.fontSize
-                        )
-
+        if "margin-top" in c.cssAttr:
+            c.frag.spaceBefore = getSize(c.cssAttr["margin-top"], c.frag.fontSize)
+        if "margin-bottom" in c.cssAttr:
+            c.frag.spaceAfter = getSize(c.cssAttr["margin-bottom"], c.frag.fontSize)
         if "margin-left" in c.cssAttr:
             c.frag.bulletIndent = kw["margin-left"]  # For lists
-            kw["margin-left"] += getSize(c.cssAttr["margin-left"],
-                                         c.frag.fontSize)
+            kw["margin-left"] += getSize(c.cssAttr["margin-left"], c.frag.fontSize)
             c.frag.leftIndent = kw["margin-left"]
         if "margin-right" in c.cssAttr:
-            kw["margin-right"] += getSize(
-                c.cssAttr["margin-right"], c.frag.fontSize)
+            kw["margin-right"] += getSize(c.cssAttr["margin-right"], c.frag.fontSize)
             c.frag.rightIndent = kw["margin-right"]
-
+        if "text-indent" in c.cssAttr:
+            c.frag.firstLineIndent = getSize(c.cssAttr["text-indent"], c.frag.fontSize)
         if "list-style-type" in c.cssAttr:
             c.frag.listStyleType = str(c.cssAttr["list-style-type"]).lower()
         if "list-style-image" in c.cssAttr:
             c.frag.listStyleImage = c.getFile(c.cssAttr["list-style-image"])
         # PADDINGS
     if isBlock:
-        transform_attrs(c.frag,
-                        (("paddingTop", "padding-top"),
-                         ("paddingBottom", "padding-bottom"),
-                         ("paddingLeft", "padding-left"),
-                         ("paddingRight", "padding-right"),
-                         ),
-                        c.cssAttr,
-                        getSize,
-                        extras=c.frag.fontSize
-                        )
-
+        if "padding-top" in c.cssAttr:
+            c.frag.paddingTop = getSize(c.cssAttr["padding-top"], c.frag.fontSize)
+        if "padding-bottom" in c.cssAttr:
+            c.frag.paddingBottom = getSize(c.cssAttr["padding-bottom"], c.frag.fontSize)
+        if "padding-left" in c.cssAttr:
+            c.frag.paddingLeft = getSize(c.cssAttr["padding-left"], c.frag.fontSize)
+        if "padding-right" in c.cssAttr:
+            c.frag.paddingRight = getSize(c.cssAttr["padding-right"], c.frag.fontSize)
         # BORDERS
     if isBlock:
-        transform_attrs(c.frag,
-                        (("borderTopWidth", "border-top-width"),
-                         ("borderBottomWidth", "border-bottom-width"),
-                         ("borderLeftWidth", "border-left-width"),
-                         ("borderRightWidth", "border-right-width"),
-                         ),
-                        c.cssAttr,
-                        getSize,
-                        extras=c.frag.fontSize
-                        )
-        transform_attrs(c.frag,
-                        (
-                            ("borderTopStyle", "border-top-style"),
-                            ("borderBottomStyle", "border-bottom-style"),
-                            ("borderLeftStyle", "border-left-style"),
-                            ("borderRightStyle", "border-right-style")
-                        ),
-                        c.cssAttr,
-                        lambda x: x
-                        )
-
-        transform_attrs(c.frag,
-                        (
-                            ("borderTopColor", "border-top-color"),
-                            ("borderBottomColor", "border-bottom-color"),
-                            ("borderLeftColor", "border-left-color"),
-                            ("borderRightColor",  "border-right-color")
-                        ),
-                        c.cssAttr,
-                        getColor
-                        )
+        if "border-top-width" in c.cssAttr:
+            c.frag.borderTopWidth = getSize(c.cssAttr["border-top-width"], c.frag.fontSize)
+        if "border-bottom-width" in c.cssAttr:
+            c.frag.borderBottomWidth = getSize(c.cssAttr["border-bottom-width"], c.frag.fontSize)
+        if "border-left-width" in c.cssAttr:
+            c.frag.borderLeftWidth = getSize(c.cssAttr["border-left-width"], c.frag.fontSize)
+        if "border-right-width" in c.cssAttr:
+            c.frag.borderRightWidth = getSize(c.cssAttr["border-right-width"], c.frag.fontSize)
+        if "border-top-style" in c.cssAttr:
+            c.frag.borderTopStyle = c.cssAttr["border-top-style"]
+        if "border-bottom-style" in c.cssAttr:
+            c.frag.borderBottomStyle = c.cssAttr["border-bottom-style"]
+        if "border-left-style" in c.cssAttr:
+            c.frag.borderLeftStyle = c.cssAttr["border-left-style"]
+        if "border-right-style" in c.cssAttr:
+            c.frag.borderRightStyle = c.cssAttr["border-right-style"]
+        if "border-top-color" in c.cssAttr:
+            c.frag.borderTopColor = getColor(c.cssAttr["border-top-color"])
+        if "border-bottom-color" in c.cssAttr:
+            c.frag.borderBottomColor = getColor(c.cssAttr["border-bottom-color"])
+        if "border-left-color" in c.cssAttr:
+            c.frag.borderLeftColor = getColor(c.cssAttr["border-left-color"])
+        if "border-right-color" in c.cssAttr:
+            c.frag.borderRightColor = getColor(c.cssAttr["border-right-color"])
 
 
 def pisaPreLoop(node, context, collect=False):
     """
     Collect all CSS definitions
     """
 
-    data = ""
+    data = u""
     if node.nodeType == Node.TEXT_NODE and collect:
         data = node.data
 
     elif node.nodeType == Node.ELEMENT_NODE:
         name = node.tagName.lower()
 
         if name in ("style", "link"):
             attr = pisaGetAttributes(context, name, node.attributes)
-            media = [x.strip()
-                     for x in attr.media.lower().split(",") if x.strip()]
+            media = [x.strip() for x in attr.media.lower().split(",") if x.strip()]
 
             if attr.get("type", "").lower() in ("", "text/css") and \
                     (not media or "all" in media or "print" in media or "pdf" in media):
 
                 if name == "style":
                     for node in node.childNodes:
                         data += pisaPreLoop(node, context, collect=True)
                     context.addCSS(data)
                     return u""
 
                 if name == "link" and attr.href and attr.rel.lower() == "stylesheet":
                     # print "CSS LINK", attr
-                    context.addCSS('\n@import "%s" %s;' %
-                                   (attr.href, ",".join(media)))
+                    context.addCSS('\n@import "%s" %s;' % (attr.href, ",".join(media)))
 
     for node in node.childNodes:
         result = pisaPreLoop(node, context, collect=collect)
         if collect:
             data += result
 
     return data
 
 
 def pisaLoop(node, context, path=None, **kw):
+
     if path is None:
         path = []
 
     # Initialize KW
     if not kw:
         kw = {
             "margin-top": 0,
             "margin-bottom": 0,
             "margin-left": 0,
             "margin-right": 0,
         }
     else:
         kw = copy.copy(kw)
 
-    # indent = len(path) * "  " # only used for debug print statements
+    #indent = len(path) * "  " # only used for debug print statements
 
     # TEXT
     if node.nodeType == Node.TEXT_NODE:
         # print indent, "#", repr(node.data) #, context.frag
         context.addFrag(node.data)
+
         # context.text.append(node.value)
 
     # ELEMENT
     elif node.nodeType == Node.ELEMENT_NODE:
 
         node.tagName = node.tagName.replace(":", "").lower()
 
         if node.tagName in ("style", "script"):
             return
 
         path = copy.copy(path) + [node.tagName]
 
         # Prepare attributes
         attr = pisaGetAttributes(context, node.tagName, node.attributes)
-        # log.debug(indent + "<%s %s>" % (node.tagName, attr) +
-        # repr(node.attributes.items())) #, path
+        #log.debug(indent + "<%s %s>" % (node.tagName, attr) + repr(node.attributes.items())) #, path
 
         # Calculate styles
         context.cssAttr = CSSCollect(node, context)
         context.cssAttr = mapNonStandardAttrs(context.cssAttr, node, attr)
         context.node = node
 
         # Block?
         PAGE_BREAK = 1
         PAGE_BREAK_RIGHT = 2
         PAGE_BREAK_LEFT = 3
 
         pageBreakAfter = False
         frameBreakAfter = False
         display = lower(context.cssAttr.get("display", "inline"))
-        # print indent, node.tagName, display,
-        # context.cssAttr.get("background-color", None), attr
+        # print indent, node.tagName, display, context.cssAttr.get("background-color", None), attr
         isBlock = (display == "block")
 
         if isBlock:
             context.addPara()
 
             # Page break by CSS
             if "-pdf-next-page" in context.cssAttr:
-                context.addStory(
-                    NextPageTemplate(str(context.cssAttr["-pdf-next-page"])))
+                context.addStory(NextPageTemplate(str(context.cssAttr["-pdf-next-page"])))
             if "-pdf-page-break" in context.cssAttr:
                 if str(context.cssAttr["-pdf-page-break"]).lower() == "before":
                     context.addStory(PageBreak())
             if "-pdf-frame-break" in context.cssAttr:
                 if str(context.cssAttr["-pdf-frame-break"]).lower() == "before":
                     context.addStory(FrameBreak())
                 if str(context.cssAttr["-pdf-frame-break"]).lower() == "after":
@@ -613,61 +533,50 @@
         # Save previous frag styles
         context.pushFrag()
 
         # Map styles to Reportlab fragment properties
         CSS2Frag(context, kw, isBlock)
 
         # EXTRAS
-        transform_attrs(context.frag,
-                        (
-                            ("keepWithNext", "-pdf-keep-with-next"),
-                            ("outline", "-pdf-outline"),
-                            #("borderLeftColor", "-pdf-outline-open"),
-                        ),
-                        context.cssAttr,
-                        getBool
-                        )
-
+        if "-pdf-keep-with-next" in context.cssAttr:
+            context.frag.keepWithNext = getBool(context.cssAttr["-pdf-keep-with-next"])
+        if "-pdf-outline" in context.cssAttr:
+            context.frag.outline = getBool(context.cssAttr["-pdf-outline"])
         if "-pdf-outline-level" in context.cssAttr:
-            context.frag.outlineLevel = int(
-                context.cssAttr["-pdf-outline-level"])
-
+            context.frag.outlineLevel = int(context.cssAttr["-pdf-outline-level"])
+        if "-pdf-outline-open" in context.cssAttr:
+            context.frag.outlineOpen = getBool(context.cssAttr["-pdf-outline-open"])
         if "-pdf-word-wrap" in context.cssAttr:
             context.frag.wordWrap = context.cssAttr["-pdf-word-wrap"]
 
         # handle keep-in-frame
         keepInFrameMode = None
         keepInFrameMaxWidth = 0
         keepInFrameMaxHeight = 0
         if "-pdf-keep-in-frame-mode" in context.cssAttr:
-            value = str(
-                context.cssAttr["-pdf-keep-in-frame-mode"]).strip().lower()
+            value = str(context.cssAttr["-pdf-keep-in-frame-mode"]).strip().lower()
             if value in ("shrink", "error", "overflow", "truncate"):
                 keepInFrameMode = value
             else:
                 keepInFrameMode = "shrink"
             # Added because we need a default value.
-
         if "-pdf-keep-in-frame-max-width" in context.cssAttr:
-            keepInFrameMaxWidth = getSize(
-                "".join(context.cssAttr["-pdf-keep-in-frame-max-width"]))
+            keepInFrameMaxWidth = getSize("".join(context.cssAttr["-pdf-keep-in-frame-max-width"]))
         if "-pdf-keep-in-frame-max-height" in context.cssAttr:
-            keepInFrameMaxHeight = getSize(
-                "".join(context.cssAttr["-pdf-keep-in-frame-max-height"]))
+            keepInFrameMaxHeight = getSize("".join(context.cssAttr["-pdf-keep-in-frame-max-height"]))
 
         # ignore nested keep-in-frames, tables have their own KIF handling
         keepInFrame = keepInFrameMode is not None and context.keepInFrameIndex is None
         if keepInFrame:
             # keep track of current story index, so we can wrap everythink
             # added after this point in a KeepInFrame
             context.keepInFrameIndex = len(context.story)
 
         # BEGIN tag
-        klass = globals().get("pisaTag%s" %
-                              node.tagName.replace(":", "").upper(), None)
+        klass = globals().get("pisaTag%s" % node.tagName.replace(":", "").upper(), None)
         obj = None
 
         # Static block
         elementId = attr.get("id", None)
         staticFrame = context.frameStatic.get(elementId, None)
         if staticFrame:
             context.frag.insideStaticFrame += 1
@@ -711,16 +620,15 @@
             context.story = context.story[:context.keepInFrameIndex]
             context.story.append(
                 KeepInFrame(
                     content=substory,
                     maxWidth=keepInFrameMaxWidth,
                     maxHeight=keepInFrameMaxHeight,
                     mode=keepInFrameMode))
-            # mode wasn't being used; it is necessary for tables or images at
-            # end of page.
+            # mode wasn't being used; it is necessary for tables or images at end of page.
             context.keepInFrameIndex = None
 
         # Static block, END
         if staticFrame:
             context.addPara()
             for frame in staticFrame:
                 frame.pisaStaticStory = context.story
@@ -736,65 +644,71 @@
     else:
         # context.debug(1, indent, "???", node, node.nodeType, repr(node))
         # Loop over children
         for node in node.childNodes:
             pisaLoop(node, context, path, **kw)
 
 
-def pisaParser(src, context, default_css="", xhtml=False, encoding="utf8", xml_output=None):
+def pisaParser(src, context, default_css="", xhtml=False, encoding=None, xml_output=None):
     """
     - Parse HTML and get miniDOM
     - Extract CSS informations, add default CSS, parse CSS
     - Handle the document DOM itself and build reportlab story
     - Return Context object
     """
 
     global CSSAttrCache
     CSSAttrCache = {}
 
     if xhtml:
-        log.warning("xhtml parameter will be removed on next release 0.2.8")
-        # TODO: XHTMLParser doesn't seem to exist...
+        #TODO: XHTMLParser doesn't see to exist...
         parser = html5lib.XHTMLParser(tree=treebuilders.getTreeBuilder("dom"))
     else:
         parser = html5lib.HTMLParser(tree=treebuilders.getTreeBuilder("dom"))
-    parser_kwargs = {}
-    if isinstance(src, str):
+
+    if isinstance(src, six.text_type):
         # If an encoding was provided, do not change it.
         if not encoding:
             encoding = "utf-8"
         src = src.encode(encoding)
         src = pisaTempFile(src, capacity=context.capacity)
-        # To pass the encoding used to convert the text_type src to binary_type
-        # on to html5lib's parser to ensure proper decoding
-        parser_kwargs['transport_encoding'] = encoding
 
     # # Test for the restrictions of html5lib
     # if encoding:
     #     # Workaround for html5lib<0.11.1
     #     if hasattr(inputstream, "isValidEncoding"):
     #         if encoding.strip().lower() == "utf8":
     #             encoding = "utf-8"
     #         if not inputstream.isValidEncoding(encoding):
     #             log.error("%r is not a valid encoding e.g. 'utf8' is not valid but 'utf-8' is!", encoding)
     #     else:
     #         if inputstream.codecName(encoding) is None:
     #             log.error("%r is not a valid encoding", encoding)
     document = parser.parse(
-        src, **parser_kwargs
-    )  # encoding=encoding)
+        src,
+        )#encoding=encoding)
 
     if xml_output:
-        xml_output.write(document.toprettyxml(encoding=encoding))
+        if encoding:
+            xml_output.write(document.toprettyxml(encoding=encoding))
+        else:
+            xml_output.write(document.toprettyxml(encoding="utf8"))
+
 
     if default_css:
         context.addDefaultCSS(default_css)
 
     pisaPreLoop(document, context)
+    #try:
     context.parseCSS()
+    #except:
+    #    context.cssText = DEFAULT_CSS
+    #    context.parseCSS()
+    # context.debug(9, pprint.pformat(context.css))
+
     pisaLoop(document, context)
     return context
 
 
 # Shortcuts
 
 HTML2PDF = pisaParser
```

## Comparing `xhtml2pdf/pdf.py` & `xhtml2pdf-0.2b1/xhtml2pdf/pdf.py`

 * *Files 14% similar despite different names*

```diff
@@ -10,56 +10,55 @@
 #
 # Unless required by applicable law or agreed to in writing, software
 # distributed under the License is distributed on an "AS IS" BASIS,
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
+import six
 import logging
-from io import BytesIO
-from xhtml2pdf.util import pypdf
-from xhtml2pdf.files import getFile, pisaTempFile
+
+
+from xhtml2pdf.util import pisaTempFile, getFile, PyPDF2
+
 
 log = logging.getLogger("xhtml2pdf")
 
 
 class pisaPDF:
     def __init__(self, capacity=-1):
         self.capacity = capacity
         self.files = []
 
     def addFromURI(self, url, basepath=None):
         obj = getFile(url, basepath)
-        data = obj.getFileContent()
-        if data:
-            self.files.append(BytesIO(data))
+        if obj and (not obj.notFound()):
+            self.files.append(obj.getFile())
 
     addFromFileName = addFromURI
 
     def addFromFile(self, f):
         if hasattr(f, "read"):
             self.files.append(f)
         else:
             self.addFromURI(f)
 
     def addFromString(self, data):
-        f = getFile(data.encode(), capacity=self.capacity).getFileContent()
-        if f:
-            self.files.append(f)
+        self.files.append(pisaTempFile(data, capacity=self.capacity))
 
     def addDocument(self, doc):
         if hasattr(doc.dest, "read"):
             self.files.append(doc.dest)
 
     def join(self, file=None):
-        output = pypdf.PdfWriter()
+        output = PyPDF2.PdfFileWriter()
         for pdffile in self.files:
-            pdf = pypdf.PdfReader(pdffile)
-            for pageNumber in range(len(pdf.pages)):
-                output.add_page(pdf.pages[pageNumber])
+            input = PyPDF2.PdfFileReader(pdffile)
+            for pageNumber in six.moves.range(input.getNumPages()):
+                output.addPage(input.getPage(pageNumber))
 
         if file is not None:
             output.write(file)
             return file
         out = pisaTempFile(capacity=self.capacity)
         output.write(out)
         return out.getvalue()
```

## Comparing `xhtml2pdf/pisa.py` & `xhtml2pdf-0.2b1/xhtml2pdf/pisa.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,37 +1,43 @@
 # -*- coding: utf-8 -*-
+"""
+Copyright 2010 Dirk Holtwick, holtwick.it
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
 
-# Copyright 2010 Dirk Holtwick, holtwick.it
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+"""
 
+from xhtml2pdf.default import DEFAULT_CSS
+from xhtml2pdf.document import pisaDocument
+from xhtml2pdf.util import getFile
+from xhtml2pdf import __version__
 import getopt
 import glob
 import logging
 import os
+import six
 import sys
-
-from xhtml2pdf import __version__
-from xhtml2pdf.config.httpconfig import httpConfig
-from xhtml2pdf.default import DEFAULT_CSS
-from xhtml2pdf.document import pisaDocument
-from xhtml2pdf.files import getFile
-
-import urllib.parse as urlparse
-
+import tempfile
+try:
+    import urllib2
+except ImportError:
+    import urllib.request as urllib2
+try:
+    import urlparse
+except ImportError:
+    import urllib.parse as urlparse
 
 log = logging.getLogger("xhtml2pdf")
 
 # Backward compatibility
 CreatePDF = pisaDocument
 
 USAGE = ("""
@@ -75,42 +81,17 @@
   --warn, -w:
     Show warnings
   --xml, --xhtml, -x:
     Force parsing in XML Mode
     (automatically used if file ends with ".xml")
   --html:
     Force parsing in HTML Mode (default)
-    
-[HTTP Connection options]
-
-  --http_nosslcheck:
-    No check ssl certificate.
-    
-See http.client.HTTPSConnection documentation for this parameters 
-
-  --http_key_file
-  --http_cert_file
-  --http_source_address
-  --http_timeout
 """).strip()
 
-COPYRIGHT = """
-Copyright 2010 Dirk Holtwick, holtwick.it
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-   http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License."""
+COPYRIGHT = __doc__
 
 LOG_FORMAT = "%(levelname)s [%(name)s] %(message)s"
 LOG_FORMAT_DEBUG = "%(levelname)s [%(name)s] %(pathname)s line %(lineno)d: %(message)s"
 
 
 def usage():
     print (USAGE)
@@ -131,21 +112,34 @@
 
     def __del__(self):
         for path in self.tfileList:
             os.remove(path)
 
     def getFileName(self, name, relative=None):
         url = urlparse.urljoin(relative or self.src, name)
-        instance = getFile(url)
-        filetmpdownloaded = instance.getNamedFile()
-        path = filetmpdownloaded.name
+        path = urlparse.urlsplit(url)[2]
+        suffix = ""
+        if "." in path:
+            new_suffix = "." + path.split(".")[-1].lower()
+            if new_suffix in (".css", ".gif", ".jpg", ".png"):
+                suffix = new_suffix
+        path = tempfile.mktemp(prefix="pisa-", suffix=suffix)
+        ufile = urllib2.urlopen(url)
+        tfile = open(path, "wb")
+        while True:
+            data = ufile.read(1024)
+            if not data:
+                break
+            tfile.write(data)
+        ufile.close()
+        tfile.close()
         self.tfileList.append(path)
 
         if not self.quiet:
-            print ("  Loading %s to %s" % (url, path))
+            print ("  Loading", url, "to", path)
 
         return path
 
 
 def command():
     if "--profile" in sys.argv:
         print ("*** PROFILING ENABLED")
@@ -179,123 +173,118 @@
             "xml-dump",
             "xhtml",
             "xml",
             "html",
             "encoding=",
             "system",
             "profile",
-            "http_nosslcheck",
-            "http_key_file",
-            "http_cert_file",
-            "http_source_address",
-            "http_timeout"
         ])
     except getopt.GetoptError:
         usage()
         sys.exit(2)
 
     errors = 0
     startviewer = 0
     quiet = 0
     debug = 0
     tempdir = None
-    file_format = "pdf"
+    format = "pdf"
     css = None
     xhtml = None
     encoding = None
     xml_output = None
     base_dir = None
 
     log_level = logging.ERROR
     log_format = LOG_FORMAT
 
     for o, a in opts:
+
         if o in ("-h", "--help"):
             # Hilfe anzeigen
             usage()
             sys.exit()
 
-        elif o in("--version",):
-            print(__version__)
-            sys.exit(0)
-
-        elif o in ("--copyright"):
-            print (COPYRIGHT)
-            sys.exit(0)
-
-        elif o in ("--system",):
-            print (COPYRIGHT)
-            print ()
-            print ("SYSTEM INFORMATIONS")
-            print ("--------------------------------------------")
-            print ("OS:                %s" % sys.platform)
-            print ("Python:            %s" % sys.version)
-            print ("html5lib:          ?")
-            import reportlab
-
-            print ("Reportlab:         %s" % reportlab.Version)
-            sys.exit(0)
-
-        elif o in ("-s", "--start-viewer", "--start"):
+        if o in ("-s", "--start-viewer", "--start"):
             # Anzeigeprogramm starten
             startviewer = 1
 
-        elif o in ("-q", "--quiet"):
+        if o in ("-q", "--quiet"):
             # Output unterdr�cken
             quiet = 1
 
-        elif o in ("-w", "--warn"):
+        if o in ("-w", "--warn"):
             # Warnings
             log_level = min(log_level, logging.WARN)  # If also -d ignore -w
 
-        elif o in ("-d", "--debug"):
+        if o in ("-d", "--debug"):
             # Debug
             log_level = logging.DEBUG
             log_format = LOG_FORMAT_DEBUG
 
             if a:
                 log_level = int(a)
 
-        elif o in ("-t", "--format"):
+        if o in("--version",):
+            print(__version__)
+            sys.exit(0)
+
+        if o in ("--copyright"):
+            print (COPYRIGHT)
+            sys.exit(0)
+
+        if o in ("--system",):
+            print (COPYRIGHT)
+            print ()
+            print ("SYSTEM INFORMATIONS")
+            print ("--------------------------------------------")
+            print ("OS:                ", sys.platform)
+            print ("Python:            ", sys.version)
+            print ("html5lib:          ", "?")
+            import reportlab
+
+            print ("Reportlab:         ", reportlab.Version)
+            sys.exit(0)
+
+        if o in ("-t", "--format"):
             # Format XXX ???
-            file_format = a
+            format = a
 
-        elif o in ("-b", "--base"):
+        if o in ("-b", "--base"):
             base_dir = a
 
-        elif o in ("--encoding",) and a:
+        if o in ("--encoding",) and a:
             # Encoding
             encoding = a
 
-        elif o in ("-c", "--css"):
+        if o in ("-c", "--css"):
             # CSS
-            with open(a, "r") as file_handler:
-                css = file_handler.read()
+            css = open(a, "r").read()
 
-        elif o in ("--css-dump",):
+        if o in ("--css-dump",):
             # CSS dump
             print (DEFAULT_CSS)
             return
 
-        elif o in ("--xml-dump",):
+        if o in ("--xml-dump",):
             xml_output = sys.stdout
 
-        elif o in ("-x", "--xml", "--xhtml"):
+        if o in ("-x", "--xml", "--xhtml"):
             xhtml = True
-        
         elif o in ("--html",):
             xhtml = False
 
-        elif httpConfig.is_http_config(o, a):
-            continue
-
     if not quiet:
-        logging.basicConfig(
-            level=log_level,
-            format=log_format)
+        try:
+            logging.basicConfig(
+                level=log_level,
+                format=log_format)
+        except:
+            # XXX Logging doesn't work for Python 2.3
+            logging.basicConfig()
 
     if len(args) not in (1, 2):
         usage()
         sys.exit(2)
 
     if len(args) == 2:
         a_src, a_dest = args
@@ -323,33 +312,32 @@
             fsrc = sys.stdin
             wpath = os.getcwd()
             if base_dir:
                 wpath = base_dir
         else:
             if src.startswith("http:") or src.startswith("https:"):
                 wpath = src
-                fsrc = getFile(src).getFileContent()
+                fsrc = getFile(src).getFile()
                 src = "".join(urlparse.urlsplit(src)[1:3]).replace("/", "-")
             else:
                 fsrc = wpath = os.path.abspath(src)
-                with open(fsrc, "rb") as file_handler:
-                    fsrc = file_handler.read()
+                fsrc = open(fsrc, "rb")
 
         if a_dest is None:
             dest_part = src
             if dest_part.lower().endswith(".html") or dest_part.lower().endswith(".htm"):
                 dest_part = ".".join(src.split(".")[:-1])
-            dest = dest_part + "." + file_format.lower()
-            for i in range(10):
+            dest = dest_part + "." + format.lower()
+            for i in six.moves.range(10):
                 try:
                     open(dest, "wb").close()
                     break
                 except:
                     pass
-                dest = dest_part + "-%d.%s" % (i, file_format.lower())
+                dest = dest_part + "-%d.%s" % (i, format.lower())
         else:
             dest = a_dest
 
         fdestclose = 0
 
         if dest == "-" or base_dir:
             if sys.platform == "win32":
@@ -359,46 +347,46 @@
             fdest = sys.stdout
             startviewer = 0
         else:
             dest = os.path.abspath(dest)
             try:
                 open(dest, "wb").close()
             except:
-                print ("File '%s' seems to be in use of another application." % dest)
+                print ("File '%s' seems to be in use of another application.") % dest
                 sys.exit(2)
             fdest = open(dest, "wb")
             fdestclose = 1
 
         if not quiet:
             print ("Converting {} to {}...".format(src, dest))
 
         pisaDocument(
             fsrc,
             fdest,
             debug=debug,
             path=wpath,
             errout=sys.stdout,
             tempdir=tempdir,
-            format=file_format,
+            format=format,
             link_callback=lc,
             default_css=css,
             xhtml=xhtml,
             encoding=encoding,
-            xml_output=xml_output
+            xml_output=xml_output,
         )
 
         if xml_output:
             xml_output.getvalue()
 
         if fdestclose:
             fdest.close()
 
         if (not errors) and startviewer:
             if not quiet:
-                print ("Open viewer for file %s" % dest)
+                print ("Open viewer for file %s") % dest
             startViewer(dest)
 
 
 def startViewer(filename):
     """
     Helper for opening a PDF file
     """
@@ -433,24 +421,22 @@
 
 def makeDataURI(data=None, mimetype=None, filename=None):
     import base64
 
     if not mimetype:
         if filename:
             import mimetypes
+
+
             mimetype = mimetypes.guess_type(filename)[0].split(";")[0]
         else:
             raise Exception("You need to provide a mimetype or a filename for makeDataURI")
-
-    encoded_data = base64.encodebytes(data).split()
-
-    return "data:" + mimetype + ";base64," + "".join(encoded_data)
+    return "data:" + mimetype + ";base64," + "".join(base64.encodestring(data).split())
 
 
 def makeDataURIFromFile(filename):
-    with open(filename, "rb") as file_handler:
-        data = file_handler.read()
+    data = open(filename, "rb").read()
     return makeDataURI(data, filename=filename)
 
 
 if __name__ == "__main__":
     command()
```

## Comparing `xhtml2pdf/reportlab_paragraph.py` & `xhtml2pdf-0.2b1/xhtml2pdf/reportlab_paragraph.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,29 +1,50 @@
 # -*- coding: utf-8 -*-
 # Copyright ReportLab Europe Ltd. 2000-2008
 # see license.txt for license details
 # history http://www.reportlab.co.uk/cgi-bin/viewcvs.cgi/public/reportlab/trunk/reportlab/platypus/paragraph.py
 # Modifications by Dirk Holtwick, 2008
 
+
+#validate version sys.version[0] == 2 -> is python 2
+#validate version sys.version[0] == 3 -> is python 3
 import re
+import six
 import sys
-from copy import deepcopy
-from operator import truth
+
+###############################################################
+###############################################################
+###############################################################
+#if not python 2, the internal behavior of strings is changed
+is_python2 = True
+if sys.version[0] != '2':
+    is_python2 = False
+    class byte(bytes):
+        def __init__(self,stream):
+            super().__init__(stream,'utf-8')
+    basestring = byte
+    unicode = byte #python 3
+    str = byte
+
+###############################################################
+###############################################################
+###############################################################
+
 from string import whitespace
-from reportlab.graphics import renderPDF
-from reportlab.lib.abag import ABag
+from operator import truth
+from reportlab.pdfbase.pdfmetrics import stringWidth, getAscentDescent
+from reportlab.platypus.paraparser import ParaParser
+from reportlab.platypus.flowables import Flowable
 from reportlab.lib.colors import Color
-from reportlab.lib.enums import TA_CENTER, TA_JUSTIFY, TA_LEFT, TA_RIGHT
+from reportlab.lib.enums import TA_LEFT, TA_RIGHT, TA_CENTER, TA_JUSTIFY
 from reportlab.lib.textsplit import ALL_CANNOT_START
-from reportlab.pdfbase.pdfmetrics import getAscentDescent, stringWidth
-from reportlab.platypus.flowables import Flowable
-from reportlab.platypus.paraparser import ParaParser
-from reportlab.rl_settings import _FUZZ
+from copy import deepcopy
+from reportlab.lib.abag import ABag
+
 
-from xhtml2pdf.util import getSize
 PARAGRAPH_DEBUG = False
 LEADING_FACTOR = 1.0
 
 _wsc_re_split = re.compile('[%s]+' % re.escape(''.join((
     u'\u0009',  # HORIZONTAL TABULATION
     u'\u000A',  # LINE FEED
     u'\u000B',  # VERTICAL TABULATION
@@ -124,15 +145,15 @@
     setXPos(tx, -offset)
     return offset
 
 
 def _centerDrawParaLine(tx, offset, extraspace, words, last=0):
     m = offset + 0.5 * extraspace
     setXPos(tx, m)
-    tx._textOut(b" ".join(words), 1)
+    tx._textOut(" ".join(words), 1)
     setXPos(tx, -m)
     return m
 
 
 def _rightDrawParaLine(tx, offset, extraspace, words, last=0):
     m = offset + extraspace
     setXPos(tx, m)
@@ -216,15 +237,15 @@
                 tx.setTextOrigin(x0, cur_y)
                 xs.cur_y = cur_y
         tx._olb = cur_y - descent
         tx._oleading = leading
 
     # Letter spacing
     if xs.style.letterSpacing != 'normal':
-        tx.setCharSpace(getSize("".join(xs.style.letterSpacing)))
+        tx.setCharSpace(int(xs.style.letterSpacing))
 
     ws = getattr(tx, '_wordSpace', 0)
     nSpaces = 0
     words = line.words
     for f in words:
         if hasattr(f, 'cbDefn'):
             cbDefn = f.cbDefn
@@ -234,19 +255,15 @@
                 w = cbDefn.width
                 h = cbDefn.height
                 txfs = tx._fontsize
                 if txfs is None:
                     txfs = xs.style.fontSize
                 iy0, iy1 = imgVRange(h, cbDefn.valign, txfs)
                 cur_x_s = cur_x + nSpaces * ws
-                drawing = cbDefn.image.getDrawing(w, h)
-                if drawing:
-                    renderPDF.draw(drawing, tx._canvas, cur_x_s, cur_y + iy0)
-                else:
-                    tx._canvas.drawImage(cbDefn.image.getImage(), cur_x_s, cur_y + iy0, w, h, mask='auto')
+                tx._canvas.drawImage(cbDefn.image.getImage(), cur_x_s, cur_y + iy0, w, h, mask='auto')
                 cur_x += w
                 cur_x_s += w
                 setXPos(tx, cur_x_s - tx._x0)
             elif kind == 'barcode':
                 barcode = cbDefn.barcode
                 w = cbDefn.width
                 h = cbDefn.height
@@ -294,32 +311,30 @@
                     if xs.backgroundColor is not None:
                         xs.backgrounds.append((xs.background_x, cur_x_s, xs.backgroundColor, xs.backgroundFontSize))
                     xs.background_x = cur_x_s
                     xs.backgroundColor = f.backColor
                     xs.backgroundFontSize = f.fontSize
 
             # Underline
-            if not (hasattr(xs, 'underline') and xs.underline) \
-                    and (hasattr(f, 'underline') and f.underline):
+            if not xs.underline and f.underline:
                 xs.underline = 1
                 xs.underline_x = cur_x_s
                 xs.underlineColor = f.textColor
             elif xs.underline:
                 if not f.underline:
                     xs.underline = 0
                     xs.underlines.append((xs.underline_x, cur_x_s, xs.underlineColor))
                     xs.underlineColor = None
                 elif xs.textColor != xs.underlineColor:
                     xs.underlines.append((xs.underline_x, cur_x_s, xs.underlineColor))
                     xs.underlineColor = xs.textColor
                     xs.underline_x = cur_x_s
 
             # Strike
-            if not (hasattr(xs, 'strike') and xs.strike) \
-                    and (hasattr(f, 'strike') and f.strike):
+            if not xs.strike and f.strike:
                 xs.strike = 1
                 xs.strike_x = cur_x_s
                 xs.strikeColor = f.textColor
                 # XXX Modified for XHTML2PDF
                 xs.strikeFontSize = f.fontSize
             elif xs.strike:
                 if not f.strike:
@@ -359,15 +374,15 @@
     # XXX Modified for XHTML2PDF
     # Underline
     if xs.underline:
         xs.underlines.append((xs.underline_x, cur_x_s, xs.underlineColor))
 
     # XXX Modified for XHTML2PDF
     # Backcolor
-    if words and hasattr(f, "backColor"):
+    if hasattr(f, "backColor"):
         if xs.backgroundColor is not None:
             xs.backgrounds.append((xs.background_x, cur_x_s, xs.backgroundColor, xs.backgroundFontSize))
 
     # XXX Modified for XHTML2PDF
     # Strike
     if xs.strike:
         xs.strikes.append((xs.strike_x, cur_x_s, xs.strikeColor, xs.strikeFontSize))
@@ -398,15 +413,15 @@
     setXPos(tx, -m)
 
 
 def _justifyDrawParaLineX( tx, offset, line, last=0):
     setXPos(tx, offset)
     extraSpace = line.extraSpace
     nSpaces = line.wordCount - 1
-    if last or not nSpaces or abs(extraSpace) <= 1e-8 or (hasattr(line, "lineBreak") and line.lineBreak):
+    if last or not nSpaces or abs(extraSpace) <= 1e-8 or line.lineBreak:
         _putFragLine(offset, tx, line)  # no space modification
     else:
         tx.setWordSpace(extraSpace / float(nSpaces))
         _putFragLine(offset, tx, line)
         tx.setWordSpace(0)
     setXPos(tx, -offset)
 
@@ -418,46 +433,37 @@
 
     if (hasattr(f, 'cbDefn') or hasattr(g, 'cbDefn')
         or hasattr(f, 'lineBreak') or hasattr(g, 'lineBreak')): return 0
     for a in ('fontName', 'fontSize', 'textColor', 'backColor', 'rise', 'underline', 'strike', 'link'):
         if getattr(f, a, None) != getattr(g, a, None): return 0
     return 1
 
-def reverse_sentence(sentence):
-    words = str(sentence).split(' ')
-    reverse_sentence = ' '.join(reversed(words))
-    reverse_sentence = reverse_sentence[::-1]
-    return reverse_sentence
 
-def _getFragWords(frags, reverse=False):
+def _getFragWords(frags):
     """
     given a Parafrag list return a list of fragwords
         [[size, (f00,w00), ..., (f0n,w0n)],....,[size, (fm0,wm0), ..., (f0n,wmn)]]
         each pair f,w represents a style and some string
         each sublist represents a word
     """
     R = []
     W = []
     n = 0
     hangingStrip = False
     for f in frags:
         text = f.text
         if type(text) is bytes:
             text = text.decode('utf8')
-        if reverse:
-            text=reverse_sentence(text)
-
         # of paragraphs
         if text != '':
             if hangingStrip:
                 hangingStrip = False
                 text = text.lstrip()
+
             S = split(text)
-            if reverse:
-                S.reverse()
             if S == []:
                 S = ['']
             if W != [] and text[0] in whitespace:
                 W.insert(0, n)
                 R.append(W)
                 W = []
                 n = 0
@@ -543,15 +549,15 @@
     """
     draw a bullet text could be a simple string or a frag list
     """
 
     tx2 = canvas.beginText(style.bulletIndent, cur_y + getattr(style, "bulletOffsetY", 0))
     tx2.setFont(style.bulletFontName, style.bulletFontSize)
     tx2.setFillColor(hasattr(style, 'bulletColor') and style.bulletColor or style.textColor)
-    if isinstance(bulletText, str):
+    if isinstance(bulletText, basestring):
         tx2.textOut(bulletText)
     else:
         for f in bulletText:
             if hasattr(f, "image"):
                 image = f.image
                 width = image.drawWidth
                 height = image.drawHeight
@@ -577,15 +583,15 @@
 
 
 def _handleBulletWidth(bulletText, style, maxWidths):
     """
     work out bullet width and adjust maxWidths[0] if neccessary
     """
     if bulletText:
-        if isinstance(bulletText, str):
+        if isinstance(bulletText, basestring):
             bulletWidth = stringWidth(bulletText, style.bulletFontName, style.bulletFontSize)
         else:
             #it's a list of fragments
             bulletWidth = 0
             for f in bulletText:
                 bulletWidth = bulletWidth + stringWidth(f.text, f.fontName, f.fontSize)
         bulletRight = style.bulletIndent + bulletWidth + 0.6 * style.bulletFontSize
@@ -664,14 +670,16 @@
     tx._canvas.line(t_off, y, t_off + textlen + ws, y)
 
 
 _scheme_re = re.compile('^[a-zA-Z][-+a-zA-Z0-9]+$')
 
 
 def _doLink(tx, link, rect):
+    if isinstance(link, unicode) and is_python2:
+        link = link.encode('utf8')
     parts = link.split(':', 1)
     scheme = len(parts) == 2 and parts[0].lower() or ''
     if _scheme_re.match(scheme) and scheme != 'document':
         kind = scheme.lower() == 'pdf' and 'GoToR' or 'URI'
         if kind == 'GoToR': link = parts[1]
         tx._canvas.linkURL(link, rect, relative=1, kind=kind)
     else:
@@ -764,28 +772,28 @@
 
 
 def textTransformFrags(frags, style):
     tt = style.textTransform
     if tt:
         tt = tt.lower()
         if tt == 'lowercase':
-            tt = str.lower
+            tt = unicode.lower
         elif tt == 'uppercase':
-            tt = str.upper
+            tt = unicode.upper
         elif tt == 'capitalize':
-            tt = str.title
+            tt = unicode.title
         elif tt == 'none':
             return
         else:
             raise ValueError('ParaStyle.textTransform value %r is invalid' % style.textTransform)
         n = len(frags)
         if n == 1:
             #single fragment the easy case
             frags[0].text = tt(frags[0].text.decode('utf8')).encode('utf8')
-        elif tt is str.title:
+        elif tt is unicode.title:
             pb = True
             for f in frags:
                 t = f.text
                 if not t: continue
                 u = t.decode('utf8')
                 if u.startswith(u' ') or pb:
                     u = tt(u)
@@ -798,21 +806,21 @@
         else:
             for f in frags:
                 t = f.text
                 if not t: continue
                 f.text = tt(t.decode('utf8')).encode('utf8')
 
 
-class cjkU(str):
+class cjkU(unicode):
     """
     simple class to hold the frag corresponding to a str
     """
 
     def __new__(cls, value, frag, encoding):
-        self = str.__new__(cls, value)
+        self = unicode.__new__(cls, value)
         self._frag = frag
         if hasattr(frag, 'cbDefn'):
             w = getattr(frag.cbDefn, 'width', 0)
             self._width = w
         else:
             self._width = stringWidth(value, frag.fontName, frag.fontSize)
         return self
@@ -856,18 +864,20 @@
 
 
 def cjkFragSplit(frags, maxWidths, calcBounds, encoding='utf8'):
     """
     This attempts to be wordSplit for frags using the dumb algorithm
     """
 
+    from reportlab.rl_config import _FUZZ
+
     U = []  # get a list of single glyphs with their widths etc etc
     for f in frags:
         text = f.text
-        if not isinstance(text, str):
+        if not isinstance(text, unicode):
             text = text.decode(encoding)
         if text:
             U.extend([cjkU(t, f, encoding) for t in text])
         else:
             U.append(cjkU(text, f, encoding))
 
     lines = []
@@ -956,17 +966,15 @@
             addMapping('Vera', 0, 0, 'Vera')    #normal
             addMapping('Vera', 0, 1, 'Vera-Italic')    #italic
             addMapping('Vera', 1, 0, 'Vera-Bold')    #bold
             addMapping('Vera', 1, 1, 'Vera-BoldItalic')    #italic and bold
 
         It will also be able to handle any MathML specified Greek characters.
     """
-    def __init__(self, text, style, bulletText=None, frags=None, caseSensitive=1,
-        encoding='utf8', dir='ltr'):
-        self.dir = dir
+    def __init__(self, text, style, bulletText=None, frags=None, caseSensitive=1, encoding='utf8'):
         self.caseSensitive = caseSensitive
         self.encoding = encoding
         self._setup(text, style, bulletText, frags, cleanBlockQuotedText)
 
     def __repr__(self):
         n = self.__class__.__name__
         L = [n + "("]
@@ -1246,18 +1254,15 @@
         else:
             if hasattr(self, 'blPara') and getattr(self, '_splitpara', 0):
                 #NB this is an utter hack that awaits the proper information
                 #preserving splitting algorithm
                 return self.blPara
             n = 0
             words = []
-            frag_words = _getFragWords(frags, reverse=self.dir == 'rtl')
-            if self.dir == 'rtl':
-                frag_words.reverse()
-            for w in frag_words:
+            for w in _getFragWords(frags):
                 f = w[-1][0]
                 fontName = f.fontName
                 fontSize = f.fontSize
                 spaceWidth = stringWidth(' ', fontName, fontSize)
 
                 if not words:
                     currentWidth = -spaceWidth   # hack to get around extra space for word 1
@@ -1273,19 +1278,15 @@
 
                 #test to see if this frag is a line break. If it is we will only act on it
                 #if the current width is non-negative or the previous thing was a deliberate lineBreak
                 lineBreak = hasattr(f, 'lineBreak')
                 endLine = (newWidth > maxWidth and n > 0) or lineBreak
                 if not endLine:
                     if lineBreak: continue      #throw it away
-                    if type(w[1][1]) != str:
-                        nText = str(w[1][1], 'utf-8')
-                    else:
-                        nText = w[1][1]
-
+                    nText = w[1][1]
                     if nText: n += 1
                     fontSize = f.fontSize
                     if calcBounds:
                         cbDefn = getattr(f, 'cbDefn', None)
                         if getattr(cbDefn, 'width', 0):
                             descent, ascent = imgVRange(cbDefn.height, cbDefn.valign, fontSize)
                         else:
@@ -1551,17 +1552,17 @@
                 if autoLeading == 'max':
                     leading = max(leading, LEADING_FACTOR * f.fontSize)
                 elif autoLeading == 'min':
                     leading = LEADING_FACTOR * f.fontSize
 
                 #now the font for the rest of the paragraph
                 tx.setFont(f.fontName, f.fontSize, leading)
-                ws = getattr(tx, '_wordSpace', 0)
+                ws = getattr(tx, '_wordSpace', 0)  
                 t_off = dpl(tx, offset, ws, lines[0][1], noJustifyLast and nLines == 1)
-                if (hasattr(f, 'underline') and f.underline) or f.link or (hasattr(f, 'strike') and f.strike):
+                if f.underline or f.link or f.strike:
                     xs = tx.XtraState = ABag()
                     xs.cur_y = cur_y
                     xs.f = f
                     xs.style = style
                     xs.lines = lines
                     xs.underlines = []
                     xs.underlineColor = None
@@ -1585,23 +1586,23 @@
                     if underline:
                         _do_under_line(0, dx, ws, tx)
                     if strike:
                         _do_under_line(0, dx, ws, tx, lm=0.125)
                     if link: _do_link_line(0, dx, ws, tx)
 
                     #now the middle of the paragraph, aligned with the left margin which is our origin.
-                    for i in range(1, nLines):
+                    for i in six.moves.range(1, nLines):
                         ws = lines[i][0]
                         t_off = dpl(tx, _offsets[i], ws, lines[i][1], noJustifyLast and i == lim)
                         if dpl != _justifyDrawParaLine: ws = 0
                         if underline: _do_under_line(i, t_off + leftIndent, ws, tx)
                         if strike: _do_under_line(i, t_off + leftIndent, ws, tx, lm=0.125)
                         if link: _do_link_line(i, t_off + leftIndent, ws, tx)
                 else:
-                    for i in range(1, nLines):
+                    for i in six.moves.range(1, nLines):
                         dpl(tx, _offsets[i], lines[i][0], lines[i][1], noJustifyLast and i == lim)
             else:
                 f = lines[0]
                 cur_y = self.height - getattr(f, 'ascent', f.fontSize)    # TODO fix XPreformatted to remove this hack
                 # default?
                 dpl = _leftDrawParaLineX
                 if bulletText:
@@ -1649,15 +1650,15 @@
                 xs.autoLeading = autoLeading
 
                 tx._fontname, tx._fontsize = None, None
                 dpl(tx, offset, lines[0], noJustifyLast and nLines == 1)
                 _do_post_text(tx)
 
                 #now the middle of the paragraph, aligned with the left margin which is our origin.
-                for i in range(1, nLines):
+                for i in six.moves.range(1, nLines):
                     f = lines[i]
                     dpl(tx, _offsets[i], f, noJustifyLast and i == lim)
                     _do_post_text(tx)
 
             canvas.drawText(tx)
             canvas.restoreState()
 
@@ -1705,44 +1706,44 @@
             line = lines[l]
             if hasattr(line, 'words'):
                 words = line.words
             else:
                 words = line[1]
             nwords = len(words)
             print ('line%d: %d(%s)\n  ') % (l, nwords, str(getattr(line, 'wordCount', 'Unknown'))),
-            for w in range(nwords):
+            for w in six.moves.range(nwords):
                 print ("%d:'%s'") % (w, getattr(words[w], 'text', words[w])),
             print()
 
     def fragDump(w):
         R = ["'%s'" % w[1]]
         for a in ('fontName', 'fontSize', 'textColor', 'rise', 'underline', 'strike', 'link', 'cbDefn', 'lineBreak'):
             if hasattr(w[0], a):
                 R.append('%s=%r' % (a, getattr(w[0], a)))
         return ', '.join(R)
 
     def dumpParagraphFrags(P):
         print ('dumpParagraphFrags(<Paragraph @ %d>) minWidth() = %.2f') % (id(P), P.minWidth())
         frags = P.frags
         n = len(frags)
-        for l in range(n):
+        for l in six.moves.range(n):
             print ("frag%d: '%s' %s") % (
             l, frags[l].text, ' '.join(['%s=%s' % (k, getattr(frags[l], k)) for k in frags[l].__dict__ if k != text]))
 
         l = 0
         cum = 0
         for W in _getFragWords(frags):
             cum += W[0]
             print ("fragword%d: cum=%3d size=%d") % (l, cum, W[0]),
             for w in W[1:]:
                 print ('(%s)') % fragDump(w),
             print()
             l += 1
 
-    from reportlab.lib.styles import ParagraphStyle, getSampleStyleSheet
+    from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
     from reportlab.lib.units import cm
 
     TESTS = sys.argv[1:]
     if TESTS == []:
         TESTS = ['4']
 
     def flagged(i, TESTS=TESTS):
```

## Comparing `xhtml2pdf/tables.py` & `xhtml2pdf-0.2b1/xhtml2pdf/tables.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,8 +1,15 @@
 # -*- coding: utf-8 -*-
+from reportlab.platypus.tables import TableStyle
+from xhtml2pdf.util import getSize, getBorderStyle, getAlign
+from xhtml2pdf.tags import pisaTag
+from xhtml2pdf.xhtml2pdf_reportlab import PmlTable, PmlKeepInFrame
+import copy
+import logging
+import six
 
 # Copyright 2010 Dirk Holtwick, holtwick.it
 #
 # Licensed under the Apache License, Version 2.0 (the "License");
 # you may not use this file except in compliance with the License.
 # You may obtain a copy of the License at
 #
@@ -10,22 +17,14 @@
 #
 # Unless required by applicable law or agreed to in writing, software
 # distributed under the License is distributed on an "AS IS" BASIS,
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
-import copy
-import logging
-from reportlab.platypus.tables import TableStyle
-
-from xhtml2pdf.tags import pisaTag
-from xhtml2pdf.util import getAlign, getBorderStyle, getSize, set_value
-from xhtml2pdf.xhtml2pdf_reportlab import PmlKeepInFrame, PmlTable
-
 log = logging.getLogger("xhtml2pdf")
 
 
 def _width(value=None):
     if value is None:
         return None
     value = str(value)
@@ -40,15 +39,14 @@
     value = str(value)
     if value.endswith("%"):
         return value
     return getSize(value)
 
 
 class TableData:
-
     def __init__(self):
         self.data = []
         self.styles = []
         self.span = []
         self.mode = ""
         self.padding = 0
         self.col = 0
@@ -113,41 +111,35 @@
                             "squared"))
         if getBorderStyle(
                 c.frag.borderBottomStyle) and c.frag.borderBottomWidth and c.frag.borderBottomColor is not None:
             self.add_style(('LINEBELOW', (begin[0], end[1]), end,
                             c.frag.borderBottomWidth,
                             c.frag.borderBottomColor,
                             "squared"))
-        self.add_style(
-            ('LEFTPADDING', begin, end, c.frag.paddingLeft or self.padding))
-        self.add_style(
-            ('RIGHTPADDING', begin, end, c.frag.paddingRight or self.padding))
-        self.add_style(
-            ('TOPPADDING', begin, end, c.frag.paddingTop or self.padding))
-        self.add_style(
-            ('BOTTOMPADDING', begin, end, c.frag.paddingBottom or self.padding))
+        self.add_style(('LEFTPADDING', begin, end, c.frag.paddingLeft or self.padding))
+        self.add_style(('RIGHTPADDING', begin, end, c.frag.paddingRight or self.padding))
+        self.add_style(('TOPPADDING', begin, end, c.frag.paddingTop or self.padding))
+        self.add_style(('BOTTOMPADDING', begin, end, c.frag.paddingBottom or self.padding))
 
 
 class pisaTagTABLE(pisaTag):
 
     def set_borders(self, frag, attrs):
-
-        set_value(frag,
-                  ('borderLeftColor', 'borderRightColor', 'borderTopColor',
-                   'borderBottomColor'), attrs.bordercolor)
-
-        set_value(frag,
-                  ('borderLeftWidth', 'borderRightWidth', 'borderTopWidth',
-                   'borderBottomWidth'),
-                  attrs.border)
-        set_value(frag,
-                  ('borderBottomStyle', 'borderLeftStyle', 'borderTopStyle',
-                   'borderRightStyle'),
-                  "solid"
-                  )
+        frag.borderLeftWidth = attrs.border
+        frag.borderLeftColor = attrs.bordercolor
+        frag.borderLeftStyle = "solid"
+        frag.borderRightWidth = attrs.border
+        frag.borderRightColor = attrs.bordercolor
+        frag.borderRightStyle = "solid"
+        frag.borderTopWidth = attrs.border
+        frag.borderTopColor = attrs.bordercolor
+        frag.borderTopStyle = "solid"
+        frag.borderBottomWidth = attrs.border
+        frag.borderBottomColor = attrs.bordercolor
+        frag.borderBottomStyle = "solid"
 
     def start(self, c):
         c.addPara()
 
         attrs = self.attr
 
         c.tableData, self.tableData = TableData(), c.tableData
@@ -172,20 +164,30 @@
 
         # Add missing columns so that each row has the same count of columns
         # This prevents errors in Reportlab table
 
         try:
             maxcols = max([len(row) for row in data] or [0])
         except ValueError:
-            log.warning(c.warning("<table> rows seem to be inconsistent"))
+            log.warn(c.warning("<table> rows seem to be inconsistent"))
             maxcols = [0]
 
         for i, row in enumerate(data):
             data[i] += [''] * (maxcols - len(row))
 
+        cols_with_no_width = [tup for tup in enumerate(tdata.colw) if tup[1] is None or tup[1] == 0.0]
+
+        if cols_with_no_width:  # any col width not defined
+            log.debug(list(enumerate(tdata.colw)))
+            fair_division = str(100 / float(len(cols_with_no_width))) + '%'
+            log.debug("Fair division: {}".format(fair_division))
+            for i, _ in cols_with_no_width:
+                log.debug("Setting {} to {}".format(i, fair_division))
+                tdata.colw[i] = fair_division
+
         log.debug("Col widths: {}".format(list(tdata.colw)))
         if tdata.data:
             # log.debug("Table styles %r", tdata.styles)
             t = PmlTable(
                 data,
                 colWidths=tdata.colw,
                 rowHeights=tdata.rowh,
@@ -201,43 +203,39 @@
             t.spaceAfter = c.frag.spaceAfter
 
             # XXX Maybe we need to copy some more properties?
             t.keepWithNext = c.frag.keepWithNext
             # t.hAlign = tdata.align
             c.addStory(t)
         else:
-            log.warning(c.warning("<table> is empty"))
+            log.warn(c.warning("<table> is empty"))
 
         # Cleanup and re-swap table data
         c.clearFrag()
         c.tableData, self.tableData = self.tableData, None
 
 
 class pisaTagTR(pisaTag):
-
     def start(self, c):
         tdata = c.tableData
         row = tdata.row
         begin = (0, row)
         end = (-1, row)
 
         tdata.add_cell_styles(c, begin, end, "tr")
         c.frag.vAlign = self.attr.valign or c.frag.vAlign
-        if c.frag.backColor:
-            tdata.add_style(('BACKGROUND', begin, end, c.frag.backColor))
-            
+
         tdata.col = 0
         tdata.data.append([])
 
     def end(self, c):
         c.tableData.row += 1
 
 
 class pisaTagTD(pisaTag):
-
     def start(self, c):
 
         if self.attr.align is not None:
             c.frag.alignment = getAlign(self.attr.align)
 
         c.clearFrag()
         self.story = c.swapStory()
@@ -262,27 +260,26 @@
         end = (col, row)
         if cspan:
             end = (end[0] + cspan - 1, end[1])
         if rspan:
             end = (end[0], end[1] + rspan - 1)
         if begin != end:
             tdata.add_style(('SPAN', begin, end))
-            for x in range(begin[0], end[0] + 1):
-                for y in range(begin[1], end[1] + 1):
+            for x in six.moves.range(begin[0], end[0] + 1):
+                for y in six.moves.range(begin[1], end[1] + 1):
                     if x != begin[0] or y != begin[1]:
                         tdata.add_empty(x, y)
 
         # Set Border and padding styles
         tdata.add_cell_styles(c, begin, end, "td")
 
         # Calculate widths
         # Add empty placeholders for new columns
         if (col + 1) > len(tdata.colw):
-            tdata.colw = tdata.colw + \
-                ((col + 1 - len(tdata.colw)) * [_width()])
+            tdata.colw = tdata.colw + ((col + 1 - len(tdata.colw)) * [_width()])
 
         # Get value of with, if no spanning
         if not cspan:
             width = c.frag.width or self.attr.width
             # If is value, the set it in the right place in the arry
             if width is not None:
                 tdata.colw[col] = _width(width)
@@ -291,51 +288,49 @@
                 # If there are no child nodes, nothing within the column can change the
                 # width.  Set the column width to the sum of the right and left padding
                 # rather than letting it default.
                 log.debug(width)
                 if len(self.node.childNodes) == 0:
                     width = c.frag.paddingLeft + c.frag.paddingRight
                     log.debug("Col {} has width {}".format(col, width))
-                    if width:
-                        tdata.colw[col] = _width(width)
+                    tdata.colw[col] = _width(width)
                 else:
                     # Child nodes are present, we cannot do anything about the
                     # width except set it externally.
                     pass
 
         # Calculate heights
         if row + 1 > len(tdata.rowh):
-            tdata.rowh = tdata.rowh + \
-                ((row + 1 - len(tdata.rowh)) * [_width()])
+            tdata.rowh = tdata.rowh + ((row + 1 - len(tdata.rowh)) * [_width()])
         if not rspan:
             height = c.frag.height or self.attr.get('height', None)
             if height is not None:
                 tdata.rowh[row] = _height(height)
                 tdata.add_style(('FONTSIZE', begin, end, 1.0))
                 tdata.add_style(('LEADING', begin, end, 1.0))
 
         # Vertical align
         valign = self.attr.valign or c.frag.vAlign
         if valign is not None:
             tdata.add_style(('VALIGN', begin, end, valign.upper()))
 
         # Reset border, otherwise the paragraph block will have borders too
         frag = c.frag
-
-        set_value(frag,
-                  ('borderLeftWidth', 'borderRightWidth',
-                   'borderTopWidth', 'borderBottomWidth'),
-                  0)
-
-        set_value(frag,
-                  ('borderLeftColor', 'borderLeftStyle', 'borderRightColor',
-                   'borderRightStyle', 'borderTopColor', 'borderTopStyle',
-                   'borderBottomColor', 'borderBottomStyle'),
-                  None
-                  )
+        frag.borderLeftWidth = 0
+        frag.borderLeftColor = None
+        frag.borderLeftStyle = None
+        frag.borderRightWidth = 0
+        frag.borderRightColor = None
+        frag.borderRightStyle = None
+        frag.borderTopWidth = 0
+        frag.borderTopColor = None
+        frag.borderTopStyle = None
+        frag.borderBottomWidth = 0
+        frag.borderBottomColor = None
+        frag.borderBottomStyle = None
 
     def end(self, c):
         tdata = c.tableData
 
         c.addPara()
         cell = c.story
```

## Comparing `xhtml2pdf/tags.py` & `xhtml2pdf-0.2b1/xhtml2pdf/tags.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,8 +1,25 @@
 # -*- coding: utf-8 -*-
+from __future__ import print_function, unicode_literals
+from reportlab.graphics.barcode import createBarcodeDrawing
+from reportlab.lib.pagesizes import A4
+from reportlab.lib.units import inch, mm
+from reportlab.platypus.doctemplate import NextPageTemplate, FrameBreak
+from reportlab.platypus.flowables import Spacer, HRFlowable, PageBreak, Flowable
+from reportlab.platypus.frames import Frame
+from reportlab.platypus.paraparser import tt2ps, ABag
+from xhtml2pdf import xhtml2pdf_reportlab
+from xhtml2pdf.util import getColor, getSize, getAlign, dpi96
+from xhtml2pdf.xhtml2pdf_reportlab import PmlImage, PmlPageTemplate
+import copy
+import logging
+import re
+import warnings
+import six
+import string
 
 # Copyright 2010 Dirk Holtwick, holtwick.it
 #
 # Licensed under the Apache License, Version 2.0 (the "License");
 # you may not use this file except in compliance with the License.
 # You may obtain a copy of the License at
 #
@@ -10,40 +27,14 @@
 #
 # Unless required by applicable law or agreed to in writing, software
 # distributed under the License is distributed on an "AS IS" BASIS,
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
-from __future__ import print_function, unicode_literals
-
-import copy
-import json
-import logging
-import re
-import string
-import warnings
-
-from reportlab.graphics.barcode import createBarcodeDrawing
-from reportlab.graphics.charts.legends import Legend
-from reportlab.graphics.charts.textlabels import Label
-from reportlab.graphics.shapes import Drawing, Rect
-from reportlab.lib.pagesizes import A4
-from reportlab.lib.units import inch, mm
-from reportlab.platypus.doctemplate import FrameBreak, NextPageTemplate
-from reportlab.platypus.flowables import Flowable, HRFlowable, PageBreak, Spacer
-from reportlab.platypus.frames import Frame
-from reportlab.platypus.paraparser import ABag, tt2ps
-
-from .charts import DoughnutChart, PieChart, HorizontalLine, VerticalBar, HorizontalBar, LegendedPieChart
-from xhtml2pdf import xhtml2pdf_reportlab
-from xhtml2pdf.util import dpi96, getAlign, getColor, getSize
-from xhtml2pdf.xhtml2pdf_reportlab import PmlImage, PmlPageTemplate
-from .paragraph import PageNumberFlowable
-
 log = logging.getLogger("xhtml2pdf")
 
 
 def deprecation(message):
     warnings.warn("<" + message + "> is deprecated!", DeprecationWarning, stacklevel=2)
 
 
@@ -69,16 +60,14 @@
     We can also asume that there is a BODY tag because html5lib
     adds it for us. Here we take the base font size for later calculations
     in the FONT tag.
     """
 
     def start(self, c):
         c.baseFontSize = c.frag.fontSize
-        if 'dir' in self.attr and self.attr['dir']:
-            c.setDir(self.attr['dir'])
         # print("base font size", c.baseFontSize)
 
 
 class pisaTagTITLE(pisaTag):
     def end(self, c):
         c.meta["title"] = c.text
         c.clearFrag()
@@ -107,15 +96,15 @@
 
 class pisaTagSUB(pisaTag):
     def start(self, c):
         c.frag.sub = 1
 
 
 class pisaTagA(pisaTag):
-    rxLink = r"^(#|[a-z]+\:).*"
+    rxLink = re.compile("^(#|[a-z]+\:).*")
 
 
     def start(self, c):
         attr = self.attr
         # XXX Also support attr.id ?
         if attr.name:
             # Important! Make sure that cbDefn is not inherited by other
@@ -127,15 +116,15 @@
             afrag.italic = 0
             afrag.cbDefn = ABag(
                 kind="anchor",
                 name=attr.name,
                 label="anchor")
             c.fragAnchor.append(afrag)
             c.anchorName.append(attr.name)
-        if attr.href and re.match(self.rxLink, attr.href):
+        if attr.href and self.rxLink.match(attr.href):
             c.frag.link = attr.href
 
     def end(self, c):
         pass
 
 
 class pisaTagFONT(pisaTag):
@@ -155,16 +144,14 @@
 
 
 class pisaTagP(pisaTag):
     def start(self, c):
         # save the type of tag; it's used in PmlBaseDoc.afterFlowable()
         # to check if we need to add an outline-entry
         # c.frag.tag = self.tag
-        if 'dir' in self.attr and self.attr['dir']:
-            c.setDir(self.attr['dir'])
         if self.attr.align is not None:
             c.frag.alignment = getAlign(self.attr.align)
 
 
 class pisaTagDIV(pisaTagP):
     pass
 
@@ -191,15 +178,15 @@
 
 class pisaTagH6(pisaTagP):
     pass
 
 
 def listDecimal(c):
     c.listCounter += 1
-    return str("%d." % c.listCounter)
+    return six.text_type("%d." % c.listCounter)
 
 
 roman_numeral_map = (
     (1000, 'M'),
     (900, 'CM'),
     (500, 'D'),
     (400, 'CD'),
@@ -223,15 +210,15 @@
         i -= integer * count
     return ''.join(result)
 
 
 def listUpperRoman(c):
     c.listCounter += 1
     roman = int_to_roman(c.listCounter)
-    return str("%s." % roman)
+    return six.text_type("%s." % roman)
 
 
 def listLowerRoman(c):
     return listUpperRoman(c).lower()
 
 
 def listUpperAlpha(c):
@@ -240,15 +227,15 @@
     try:
         alpha = string.ascii_uppercase[index]
     except IndexError:
         # needs to start over and double the character
         # this will probably fail for anything past the 2nd time
         alpha = string.ascii_uppercase[index - 26]
         alpha *= 2
-    return str("%s." % alpha)
+    return six.text_type("%s." % alpha)
 
 
 def listLowerAlpha(c):
     return listUpperAlpha(c).lower()
 
 
 _bullet = u"\u2022"
@@ -285,17 +272,15 @@
         c.addPara()
         # XXX Simulate margin for the moment
         c.addStory(Spacer(width=1, height=c.fragBlock.spaceAfter))
         c.listCounter = self.counter
 
 
 class pisaTagOL(pisaTagUL):
-    def start(self, c):
-        start = self.attr.start - 1 if self.attr.start else 0
-        self.counter, c.listCounter = c.listCounter, start
+    pass
 
 
 class pisaTagLI(pisaTag):
     def start(self, c):
         lst = _list_style_type.get(c.frag.listStyleType or "disc", _bullet)
         frag = copy.copy(c.frag)
 
@@ -340,199 +325,193 @@
 
 
 class pisaTagIMG(pisaTag):
     def start(self, c):
         attr = self.attr
         log.debug("Parsing img tag, src: {}".format(attr.src))
         log.debug("Attrs: {}".format(attr))
+        if attr.src and (not attr.src.notFound()):
 
-        if attr.src:
-            filedata = attr.src.getData()
-            if filedata:
-                try:
-                    align = attr.align or c.frag.vAlign or "baseline"
-                    width = c.frag.width
-                    height = c.frag.height
-
-                    if attr.width:
-                        width = attr.width * dpi96
-                    if attr.height:
-                        height = attr.height * dpi96
-
-                    img = PmlImage(
-                        filedata,
-                        width=None,
-                        height=None)
-
-                    img.pisaZoom = c.frag.zoom
-
-                    img.drawHeight *= dpi96
-                    img.drawWidth *= dpi96
-
-                    if (width is None) and (height is not None):
-                        factor = getSize(height, default=img.drawHeight) / img.drawHeight
-                        img.drawWidth *= factor
-                        img.drawHeight = getSize(height, default=img.drawHeight)
-                    elif (height is None) and (width is not None):
-                        factor = getSize(width, default=img.drawWidth) / img.drawWidth
-                        img.drawHeight *= factor
-                        img.drawWidth = getSize(width, default=img.drawWidth)
-                    elif (width is not None) and (height is not None):
-                        img.drawWidth = getSize(width, default=img.drawWidth)
-                        img.drawHeight = getSize(height, default=img.drawHeight)
-
-                    img.drawWidth *= img.pisaZoom
-                    img.drawHeight *= img.pisaZoom
-
-                    img.spaceBefore = c.frag.spaceBefore
-                    img.spaceAfter = c.frag.spaceAfter
-
-                    # print "image", id(img), img.drawWidth, img.drawHeight
-
-                    '''
-                    TODO:
-    
-                    - Apply styles
-                    - vspace etc.
-                    - Borders
-                    - Test inside tables
-                    '''
-
-                    c.force = True
-                    if align in ["left", "right"]:
-
-                        c.image = img
-                        c.imageData = dict(
-                            align=align
-                        )
-
-                    else:
-
-                        # Important! Make sure that cbDefn is not inherited by other
-                        # fragments because of a bug in Reportlab!
-                        # afrag = c.frag.clone()
-
-                        valign = align
-                        if valign in ["texttop"]:
-                            valign = "top"
-                        elif valign in ["absmiddle"]:
-                            valign = "middle"
-                        elif valign in ["absbottom", "baseline"]:
-                            valign = "bottom"
-
-                        afrag = c.frag.clone()
-                        afrag.text = ""
-                        afrag.fontName = "Helvetica" # Fix for a nasty bug!!!
-                        afrag.cbDefn = ABag(
-                            kind="img",
-                            image=img, # .getImage(), # XXX Inline?
-                            valign=valign,
-                            fontName="Helvetica",
-                            fontSize=img.drawHeight,
-                            width=img.drawWidth,
-                            height=img.drawHeight)
+            try:
+                align = attr.align or c.frag.vAlign or "baseline"
+                width = c.frag.width
+                height = c.frag.height
+
+                if attr.width:
+                    width = attr.width * dpi96
+                if attr.height:
+                    height = attr.height * dpi96
 
-                        c.fragList.append(afrag)
-                        c.fontSize = img.drawHeight
+                img = PmlImage(
+                    attr.src.getData(),
+                    width=None,
+                    height=None)
 
-                except Exception:  # TODO: Kill catch-all
-                    log.warning(c.warning("Error in handling image"), exc_info=1)
-            else:
-                log.warning(c.warning("Need a valid file name!"))
+                img.pisaZoom = c.frag.zoom
+
+                img.drawHeight *= dpi96
+                img.drawWidth *= dpi96
+
+                if (width is None) and (height is not None):
+                    factor = getSize(height, default=img.drawHeight) / img.drawHeight
+                    img.drawWidth *= factor
+                    img.drawHeight = getSize(height, default=img.drawHeight)
+                elif (height is None) and (width is not None):
+                    factor = getSize(width, default=img.drawWidth) / img.drawWidth
+                    img.drawHeight *= factor
+                    img.drawWidth = getSize(width, default=img.drawWidth)
+                elif (width is not None) and (height is not None):
+                    img.drawWidth = getSize(width, default=img.drawWidth)
+                    img.drawHeight = getSize(height, default=img.drawHeight)
+
+                img.drawWidth *= img.pisaZoom
+                img.drawHeight *= img.pisaZoom
+
+                img.spaceBefore = c.frag.spaceBefore
+                img.spaceAfter = c.frag.spaceAfter
+
+                # print "image", id(img), img.drawWidth, img.drawHeight
+
+                '''
+                TODO:
+
+                - Apply styles
+                - vspace etc.
+                - Borders
+                - Test inside tables
+                '''
+
+                c.force = True
+                if align in ["left", "right"]:
+
+                    c.image = img
+                    c.imageData = dict(
+                        align=align
+                    )
+
+                else:
+
+                    # Important! Make sure that cbDefn is not inherited by other
+                    # fragments because of a bug in Reportlab!
+                    # afrag = c.frag.clone()
+
+                    valign = align
+                    if valign in ["texttop"]:
+                        valign = "top"
+                    elif valign in ["absmiddle"]:
+                        valign = "middle"
+                    elif valign in ["absbottom", "baseline"]:
+                        valign = "bottom"
+
+                    afrag = c.frag.clone()
+                    afrag.text = ""
+                    afrag.fontName = "Helvetica" # Fix for a nasty bug!!!
+                    afrag.cbDefn = ABag(
+                        kind="img",
+                        image=img, # .getImage(), # XXX Inline?
+                        valign=valign,
+                        fontName="Helvetica",
+                        fontSize=img.drawHeight,
+                        width=img.drawWidth,
+                        height=img.drawHeight)
+
+                    c.fragList.append(afrag)
+                    c.fontSize = img.drawHeight
+
+            except Exception:  # TODO: Kill catch-all
+                log.warn(c.warning("Error in handling image"), exc_info=1)
         else:
-            log.warning(c.warning("Need a valid file name!"))
+            log.warn(c.warning("Need a valid file name!"))
+
 
 class pisaTagHR(pisaTag):
     def start(self, c):
         c.addPara()
         c.addStory(HRFlowable(
             color=self.attr.color,
             thickness=self.attr.size,
             width=self.attr.get('width', "100%") or "100%",
             spaceBefore=c.frag.spaceBefore,
             spaceAfter=c.frag.spaceAfter
         ))
 
 # --- Forms
 
-class pisaTagINPUT(pisaTag):
 
-    def _render(self, c, attr):
-        width = 10
-        height = 10
-        if attr.type == "text":
-            width = 100
-            height = 12
-        c.addStory(xhtml2pdf_reportlab.PmlInput(attr.name,
-                                                input_type=attr.type,
-                                                default=attr.value,
-                                                width=width,
-                                                height=height,
-        ))
+if 0:
 
-    def end(self, c):
-        c.addPara()
-        attr = self.attr
-        if attr.name:
-            self._render(c, attr)
-        c.addPara()
+    class pisaTagINPUT(pisaTag):
 
-class pisaTagTEXTAREA(pisaTagINPUT):
-    #
-    def _render(self, c, attr):
-        multiline = 1 if int(attr.rows) > 1 else 0
-        height = int(attr.rows) * 15
-        width = int(attr.cols) * 5
-
-        # this does not currently support the ability to pre-populate the text field with data that appeared within the <textarea></textarea> tags
-        c.addStory(xhtml2pdf_reportlab.PmlInput(attr.name,
-                                                input_type="text",
-                                                default="",
-                                                width=width,
-                                                height=height,
-                                                multiline=multiline))
-
-
-class pisaTagSELECT(pisaTagINPUT):
-
-    def start(self, c):
-        c.select_options = ["One", "Two", "Three"]
-
-    def _render(self, c, attr):
-        c.addStory(xhtml2pdf_reportlab.PmlInput(attr.name,
-                                                input_type="select",
-                                                default=c.select_options[0],
-                                                options=c.select_options,
-                                                width=100,
-                                                height=40))
-        c.select_options = None
+        def _render(self, c, attr):
+            width = 10
+            height = 10
+            if attr.type == "text":
+                width = 100
+                height = 12
+            c.addStory(xhtml2pdf_reportlab.PmlInput(attr.name,
+                                                    type=attr.type,
+                                                    default=attr.value,
+                                                    width=width,
+                                                    height=height,
+            ))
 
-class pisaTagOPTION(pisaTag):
+        def end(self, c):
+            c.addPara()
+            attr = self.attr
+            if attr.name:
+                self._render(c, attr)
+            c.addPara()
 
-    pass
+    class pisaTagTEXTAREA(pisaTagINPUT):
+
+        def _render(self, c, attr):
+            c.addStory(xhtml2pdf_reportlab.PmlInput(attr.name,
+                                                    default="",
+                                                    width=100,
+                                                    height=100))
+
+    class pisaTagSELECT(pisaTagINPUT):
+
+        def start(self, c):
+            c.select_options = ["One", "Two", "Three"]
+
+        def _render(self, c, attr):
+            c.addStory(xhtml2pdf_reportlab.PmlInput(attr.name,
+                                                    type="select",
+                                                    default=c.select_options[0],
+                                                    options=c.select_options,
+                                                    width=100,
+                                                    height=40))
+            c.select_options = None
+
+    class pisaTagOPTION(pisaTag):
+
+        pass
 
 
 class pisaTagPDFNEXTPAGE(pisaTag):
     """
     <pdf:nextpage name="" />
     """
 
     def start(self, c):
+        # deprecation("pdf:nextpage")
         c.addPara()
         if self.attr.name:
             c.addStory(NextPageTemplate(self.attr.name))
         c.addStory(PageBreak())
 
 
 class pisaTagPDFNEXTTEMPLATE(pisaTag):
     """
     <pdf:nexttemplate name="" />
     """
 
     def start(self, c):
+        # deprecation("pdf:frame")
         c.addStory(NextPageTemplate(self.attr["name"]))
 
 
 class pisaTagPDFNEXTFRAME(pisaTag):
     """
     <pdf:nextframe name="" />
     """
@@ -548,39 +527,33 @@
     """
 
     def start(self, c):
         c.addPara()
         c.addStory(Spacer(1, self.attr.height))
 
 
-
 class pisaTagPDFPAGENUMBER(pisaTag):
     """
     <pdf:pagenumber example="" />
     """
 
     def start(self, c):
-        flow = PageNumberFlowable()
-        pn=c.addPageNumber(flow)
-        c.addStory(flow)
         c.frag.pageNumber = True
-        c.addFrag(pn)
+        c.addFrag(self.attr.example)
         c.frag.pageNumber = False
 
+
 class pisaTagPDFPAGECOUNT(pisaTag):
     """
     <pdf:pagecount />
     """
 
     def start(self, c):
-        flow = PageNumberFlowable()
-        pc = c.getPageCount(flow)
-        c.addStory(flow)
         c.frag.pageCount = True
-        c.addFrag(pc)
+        c.addFrag()
         c.frag.pageCount = False
 
     def end(self, c):
         c.addPageCount()
 
 
 class pisaTagPDFTOC(pisaTag):
@@ -638,25 +611,26 @@
         <pdf:frame...>
     </pdf:template>
     """
 
     def start(self, c):
         deprecation("pdf:template")
         attrs = self.attr
+        #print attrs
         name = attrs["name"]
         c.frameList = []
         c.frameStaticList = []
         if name in c.templateList:
-            log.warning(c.warning("template '%s' has already been defined", name))
+            log.warn(c.warning("template '%s' has already been defined", name))
 
     def end(self, c):
         attrs = self.attr
         name = attrs["name"]
         if len(c.frameList) <= 0:
-            log.warning(c.warning("missing frame definitions for template"))
+            log.warn(c.warning("missing frame definitions for template"))
 
         pt = PmlPageTemplate(
             id=name,
             frames=c.frameList,
             pagesize=A4,
         )
         pt.pisaStaticList = c.frameStaticList
@@ -664,25 +638,20 @@
         pt.pisaBackground = self.attr.background
 
         c.templateList[name] = pt
         c.template = None
         c.frameList = []
         c.frameStaticList = []
 
-class pisaTagPDFLANGUAGE(pisaTag):
-    """
-    <pdf:language name=""/>
-    """
-    def start(self, c):
-        setattr(c,'language',self.attr.name)
 
 class pisaTagPDFFONT(pisaTag):
     """
     <pdf:fontembed name="" src="" />
     """
+
     def start(self, c):
         deprecation("pdf:font")
         c.loadFont(self.attr.name, self.attr.src, self.attr.encoding)
 
 
 class pisaTagPDFBARCODE(pisaTag):
     _codeName = {
@@ -780,79 +749,7 @@
             kind="barcode",
             barcode=barcode,
             width=width,
             height=height,
             valign=valign,
         )
         c.fragList.append(afrag)
-
-
-class pisaTagCANVAS(pisaTag):
-
-    def __init__(self, node, attr):
-        super().__init__(node, attr)
-        self.chart = None
-        self.shapes = {
-            'horizontalbar': HorizontalBar,
-            'verticalbar': VerticalBar,
-            'horizontalline': HorizontalLine,
-            'pie': PieChart,
-            'doughnut': DoughnutChart,
-            'legendedPie': LegendedPieChart
-        }
-
-    def start(self, c):
-        pass
-
-    def end(self, c):
-
-        data = None
-        width = 350
-        height = 150
-
-        try:
-            data = json.loads(c.text)
-        except json.JSONDecodeError:
-            print("JSON Decode Error")
-
-        if data:
-
-            nodetype = dict(c.node.attributes).get('type')
-            nodewidth = dict(c.node.attributes).get('width')
-            nodeheight = dict(c.node.attributes).get('height')
-            canvastype = None
-
-            if nodetype is not None:
-                canvastype = nodetype.nodeValue
-
-            if canvastype:
-                c.clearFrag()
-
-            if nodewidth:
-                width = int(nodewidth.nodeValue)
-            if nodeheight:
-                height = int(nodeheight.nodeValue)
-
-            self.chart = self.shapes[data['type']]()
-            draw = Drawing(width, height)  # CONTAINER
-            draw.background = Rect(115, 25, width, height, strokeWidth=1, strokeColor="#868686", fillColor="#f8fce8")
-
-            # REQUIRED DATA
-            self.chart.set_properties(data)
-
-
-            #OPTIONAL DATA
-            if "title" in data:
-                title = Label()
-                self.chart.set_title_properties(data['title'], title)
-                draw.add(title)
-
-            if "legend" in data:
-                if data["legend"]:
-                    legend = Legend()
-                    self.chart.set_legend(data['legend'], legend)
-                    self.chart.load_data_legend(data, legend)
-                    draw.add(legend)
-
-            # ADD CHART TO DRAW OBJECT
-            draw.add(self.chart)
-            c.addStory(draw)
```

## Comparing `xhtml2pdf/util.py` & `xhtml2pdf-0.2b1/xhtml2pdf/util.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,8 +1,36 @@
 # -*- coding: utf-8 -*-
+from reportlab.lib.colors import Color, toColor
+from reportlab.lib.enums import TA_LEFT, TA_CENTER, TA_RIGHT, TA_JUSTIFY
+from reportlab.lib.units import inch, cm
+import base64
+try:
+    import httplib
+except ImportError:
+    import http.client as httplib
+import logging
+import mimetypes
+import os.path
+import re
+import reportlab
+import shutil
+import six
+import string
+import sys
+import tempfile
+
+try:
+    import urllib.request as urllib2
+except ImportError:
+    import urllib2
+
+try:
+    import urllib.parse as urlparse
+except ImportError:
+    import urlparse
 
 # Copyright 2010 Dirk Holtwick, holtwick.it
 #
 # Licensed under the Apache License, Version 2.0 (the "License");
 # you may not use this file except in compliance with the License.
 # You may obtain a copy of the License at
 #
@@ -10,45 +38,40 @@
 #
 # Unless required by applicable law or agreed to in writing, software
 # distributed under the License is distributed on an "AS IS" BASIS,
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
-import logging
-import re
-import sys
-from copy import copy
-
-import arabic_reshaper
-import reportlab
-import reportlab.pdfbase._cidfontdata
-from bidi.algorithm import get_display
-from reportlab.lib.colors import Color, toColor
-from reportlab.lib.enums import TA_CENTER, TA_JUSTIFY, TA_LEFT, TA_RIGHT
-from reportlab.lib.units import cm, inch
-from reportlab.pdfbase import pdfmetrics
-from reportlab.pdfbase.cidfonts import UnicodeCIDFont
+rgb_re = re.compile("^.*?rgb[a]?[(]([0-9]+).*?([0-9]+).*?([0-9]+)(?:.*?(?:[01]\.(?:[0-9]+)))?[)].*?[ ]*$")
 
-import xhtml2pdf.default
-
-rgb_re = re.compile(
-    r"^.*?rgb[a]?[(]([0-9]+).*?([0-9]+).*?([0-9]+)(?:.*?(?:[01]\.(?:[0-9]+)))?[)].*?[ ]*$")
+_reportlab_version = tuple(map(int, reportlab.Version.split('.')))
+if _reportlab_version < (2, 1):
+    raise ImportError("Reportlab Version 2.1+ is needed!")
 
 log = logging.getLogger("xhtml2pdf")
 
-import pypdf
-from reportlab.graphics import renderPM
-from reportlab.graphics import renderSVG
+try:
+    import PyPDF2
+except ImportError:
+    PyPDF2 = None
+
+try:
+    from reportlab.graphics import renderPM
+except ImportError:
+    renderPM = None
+
+try:
+    from reportlab.graphics import renderSVG
+except ImportError:
+    renderSVG = None
 
 #=========================================================================
 # Memoize decorator
 #=========================================================================
-
-
 class memoized(object):
 
     """
     A kwargs-aware memoizer, better than the one in python :)
 
     Don't pass in too large kwargs, since this turns them into a tuple of
     tuples. Also, avoid mutable types (as usual for memoizers)
@@ -64,15 +87,15 @@
         self.func = func
         self.__doc__ = self.func.__doc__  # To avoid great confusion
         self.__name__ = self.func.__name__  # This also avoids great confusion
 
     def __call__(self, *args, **kwargs):
         # Make sure the following line is not actually slower than what you're
         # trying to memoize
-        args_plus = tuple(kwargs.items())
+        args_plus = tuple(six.iteritems(kwargs))
         key = (args, args_plus)
         try:
             if key not in self.cache:
                 res = self.func(*args, **kwargs)
                 self.cache[key] = res
             return self.cache[key]
         except TypeError:
@@ -82,86 +105,36 @@
 
 def ErrorMsg():
     """
     Helper to get a nice traceback as string
     """
     import traceback
 
-    limit = None
-    _type, value, tb = sys.exc_info()
-    _list = traceback.format_tb(tb, limit) + \
-        traceback.format_exception_only(_type, value)
+    type = value = tb = limit = None
+    type, value, tb = sys.exc_info()
+    list = traceback.format_tb(tb, limit) + \
+        traceback.format_exception_only(type, value)
     return "Traceback (innermost last):\n" + "%-20s %s" % (
-        " ".join(_list[:-1]),
-        _list[-1])
+        string.join(list[: - 1], ""),
+        list[- 1])
 
 
 def toList(value):
     if type(value) not in (list, tuple):
         return [value]
     return list(value)
 
 
-def transform_attrs(obj, keys, container, func, extras=None):
-    """
-    Allows to apply one function to set of keys cheching if key is in container,
-    also trasform ccs key to report lab keys.
-
-    extras = Are extra params for func, it will be call like func(*[param1, param2])
-
-    obj = frag
-    keys = [(reportlab, css), ... ]
-    container = cssAttr
-    """
-    cpextras = extras
-
-    for reportlab, css in keys:
-        extras = cpextras
-        if extras is None:
-            extras = []
-        elif not isinstance(extras, list):
-            extras = [extras]
-        if css in container:
-            extras.insert(0, container[css])
-            setattr(obj,
-                    reportlab,
-                    func(*extras)
-                    )
-
-
-def copy_attrs(obj1, obj2, attrs):
-    """
-    Allows copy a list of attributes from object2 to object1.
-    Useful for copy ccs attributes to fragment
-    """
-    for attr in attrs:
-        value = getattr(obj2, attr) if hasattr(obj2, attr) else None
-        if value is None and isinstance(obj2, dict) and attr in obj2:
-            value = obj2[attr]
-        setattr(obj1, attr, value)
-
-
-def set_value(obj, attrs, value, _copy=False):
-    """
-    Allows set the same value to a list of attributes
-    """
-    for attr in attrs:
-        if _copy:
-            value = copy(value)
-        setattr(obj, attr, value)
-
-
 @memoized
 def getColor(value, default=None):
     """
     Convert to color value.
     This returns a Color object instance from a text bit.
     """
-    if value is None:
-        return
+
     if isinstance(value, Color):
         return value
     value = str(value).strip().lower()
     if value == "transparent" or value == "none":
         return default
     if value in COLOR_BY_NAME:
         return COLOR_BY_NAME[value]
@@ -246,29 +219,30 @@
         value = str(value).strip().lower().replace(",", ".")
         if value[-2:] == 'cm':
             return float(value[:-2].strip()) * cm
         elif value[-2:] == 'mm':
             return float(value[:-2].strip()) * mm  # 1mm = 0.1cm
         elif value[-2:] == 'in':
             return float(value[:-2].strip()) * inch  # 1pt == 1/72inch
+        elif value[-2:] == 'inch':
+            return float(value[:-4].strip()) * inch  # 1pt == 1/72inch
         elif value[-2:] == 'pt':
             return float(value[:-2].strip())
         elif value[-2:] == 'pc':
             return float(value[:-2].strip()) * 12.0  # 1pc == 12pt
         elif value[-2:] == 'px':
             # XXX W3C says, use 96pdi
             # http://www.w3.org/TR/CSS21/syndata.html#length-units
             return float(value[:-2].strip()) * dpi96
-        elif value in ("none", "0", '0.0', "auto"):
+        elif value[-1:] == 'i':  # 1pt == 1/72inch
+            return float(value[:-1].strip()) * inch
+        elif value in ("none", "0", "auto"):
             return 0.0
         elif relative:
-            if value[-3:] == 'rem':  # XXX
-                # 1rem = 1 * fontSize
-                return float(value[:-3].strip()) * relative
-            elif value[-2:] == 'em':  # XXX
+            if value[-2:] == 'em':  # XXX
                 # 1em = 1 * fontSize
                 return float(value[:-2].strip()) * relative
             elif value[-2:] == 'ex':  # XXX
                 # 1ex = 1/2 fontSize
                 return float(value[:-2].strip()) * (relative / 2.0)
             elif value[-1:] == '%':
                 # 1% = (fontSize * 1) / 100
@@ -284,19 +258,19 @@
                     return max(MIN_FONT_SIZE, base * _absoluteSizeTable[value])
                 return max(MIN_FONT_SIZE, relative * _absoluteSizeTable[value])
             else:
                 return max(MIN_FONT_SIZE, relative * float(value))
         try:
             value = float(value)
         except ValueError:
-            log.warning("getSize: Not a float %r", value)
+            log.warn("getSize: Not a float %r", value)
             return default  # value = 0
         return max(0, value)
     except Exception:
-        log.warning("getSize %r %r", original, relative, exc_info=1)
+        log.warn("getSize %r %r", original, relative, exc_info=1)
         return default
 
 
 @memoized
 def getCoords(x, y, w, h, pagesize):
     """
     As a stupid programmer I like to use the upper left
@@ -383,20 +357,14 @@
     return getCoords(x, y, None, None, pagesize)
 
 
 def getBool(s):
     " Is it a boolean? "
     return str(s).lower() in ("y", "yes", "1", "true")
 
-def getFloat(s):
-    try:
-        s = float(s)
-    except:
-        pass
-    return s
 
 _uid = 0
 
 
 def getUID():
     " Unique ID "
     global _uid
@@ -412,19 +380,306 @@
     "justify": TA_JUSTIFY,
 }
 
 
 def getAlign(value, default=TA_LEFT):
     return _alignments.get(str(value).lower(), default)
 
+GAE = "google.appengine" in sys.modules
+
+if GAE:
+    STRATEGIES = (
+        six.BytesIO,
+        six.BytesIO)
+else:
+    STRATEGIES = (
+        six.BytesIO,
+        tempfile.NamedTemporaryFile)
+
+
+class pisaTempFile(object):
+
+    """
+    A temporary file implementation that uses memory unless
+    either capacity is breached or fileno is requested, at which
+    point a real temporary file will be created and the relevant
+    details returned
+
+    If capacity is -1 the second strategy will never be used.
+
+    Inspired by:
+    http://code.activestate.com/recipes/496744/
+    """
+
+    STRATEGIES = STRATEGIES
+
+    CAPACITY = 10 * 1024
+
+    def __init__(self, buffer="", capacity=CAPACITY):
+        """Creates a TempFile object containing the specified buffer.
+        If capacity is specified, we use a real temporary file once the
+        file gets larger than that size.  Otherwise, the data is stored
+        in memory.
+        """
+
+        self.capacity = capacity
+        self.strategy = int(len(buffer) > self.capacity)
+        try:
+            self._delegate = self.STRATEGIES[self.strategy]()
+        except IndexError:
+            # Fallback for Google AppEnginge etc.
+            self._delegate = self.STRATEGIES[0]()
+        self.write(buffer)
+        # we must set the file's position for preparing to read
+        self.seek(0)
+
+    def makeTempFile(self):
+        """
+        Switch to next startegy. If an error occured,
+        stay with the first strategy
+        """
+
+        if self.strategy == 0:
+            try:
+                new_delegate = self.STRATEGIES[1]()
+                new_delegate.write(self.getvalue())
+                self._delegate = new_delegate
+                self.strategy = 1
+                log.warn("Created temporary file %s", self.name)
+            except:
+                self.capacity = - 1
+
+    def getFileName(self):
+        """
+        Get a named temporary file
+        """
+
+        self.makeTempFile()
+        return self.name
+
+    def fileno(self):
+        """
+        Forces this buffer to use a temporary file as the underlying.
+        object and returns the fileno associated with it.
+        """
+        self.makeTempFile()
+        return self._delegate.fileno()
+
+    def getvalue(self):
+        """
+        Get value of file. Work around for second strategy.
+        Always returns bytes
+        """
+
+        if self.strategy == 0:
+            return self._delegate.getvalue()
+        self._delegate.flush()
+        self._delegate.seek(0)
+        value = self._delegate.read()
+        if not isinstance(value, six.binary_type):
+            value = value.encode('utf-8')
+        return value
+
+    def write(self, value):
+        """
+        If capacity != -1 and length of file > capacity it is time to switch
+        """
+
+        if self.capacity > 0 and self.strategy == 0:
+            len_value = len(value)
+            if len_value >= self.capacity:
+                needs_new_strategy = True
+            else:
+                self.seek(0, 2)  # find end of file
+                needs_new_strategy = \
+                    (self.tell() + len_value) >= self.capacity
+            if needs_new_strategy:
+                self.makeTempFile()
+
+        if not isinstance(value, six.binary_type):
+            value = value.encode('utf-8')
+
+        self._delegate.write(value)
+
+    def __getattr__(self, name):
+        try:
+            return getattr(self._delegate, name)
+        except AttributeError:
+            # hide the delegation
+            e = "object '%s' has no attribute '%s'" \
+                % (self.__class__.__name__, name)
+            raise AttributeError(e)
 
 
 _rx_datauri = re.compile(
     "^data:(?P<mime>[a-z]+/[a-z]+);base64,(?P<data>.*)$", re.M | re.DOTALL)
 
+
+class pisaFileObject:
+
+    """
+    XXX
+    """
+
+    def __init__(self, uri, basepath=None):
+        self.basepath = basepath
+        self.mimetype = None
+        self.file = None
+        self.data = None
+        self.uri = None
+        self.local = None
+        self.tmp_file = None
+        uri = uri or str()
+        if type(uri) != str:
+            uri = uri.decode("utf-8")
+        log.debug("FileObject %r, Basepath: %r", uri, basepath)
+
+        # Data URI
+        if uri.startswith("data:"):
+            m = _rx_datauri.match(uri)
+            self.mimetype = m.group("mime")
+            self.data = base64.b64decode(m.group("data").encode("utf-8"))
+
+        else:
+            # Check if we have an external scheme
+            if basepath and not urlparse.urlparse(uri).scheme:
+                urlParts = urlparse.urlparse(basepath)
+            else:
+                urlParts = urlparse.urlparse(uri)
+
+            log.debug("URLParts: {}".format((urlParts, urlParts.scheme)))
+
+            if urlParts.scheme == 'file':
+                if basepath and uri.startswith('/'):
+                    uri = urlparse.urljoin(basepath, uri[1:])
+                urlResponse = urllib2.urlopen(uri)
+                self.mimetype = urlResponse.info().get(
+                    "Content-Type", '').split(";")[0]
+                self.uri = urlResponse.geturl()
+                self.file = urlResponse
+
+            # Drive letters have len==1 but we are looking
+            # for things like http:
+            elif urlParts.scheme in ('http', 'https'):
+
+                log.debug("Sending request for {} with httplib".format(uri))
+
+                # External data
+                if basepath:
+                    uri = urlparse.urljoin(basepath, uri)
+
+                log.debug("Uri parsed: {}".format(uri))
+
+                #path = urlparse.urlsplit(url)[2]
+                #mimetype = getMimeType(path)
+
+                # Using HTTPLIB
+                server, path = urllib2.splithost(uri[uri.find("//"):])
+                if uri.startswith("https://"):
+                    conn = httplib.HTTPSConnection(server)
+                else:
+                    conn = httplib.HTTPConnection(server)
+                conn.request("GET", path)
+                r1 = conn.getresponse()
+                # log.debug("HTTP %r %r %r %r", server, path, uri, r1)
+                if (r1.status, r1.reason) == (200, "OK"):
+                    self.mimetype = r1.getheader(
+                        "Content-Type", '').split(";")[0]
+                    self.uri = uri
+                    log.debug("here")
+                    if r1.getheader("content-encoding") == "gzip":
+                        import gzip
+
+                        self.file = gzip.GzipFile(
+                            mode="rb", fileobj=six.StringIO(r1.read()))
+                    else:
+                        self.file = r1
+                else:
+                    log.debug("Received non-200 status: {}".format((r1.status, r1.reason)))
+                    try:
+                        urlResponse = urllib2.urlopen(uri)
+                    except urllib2.HTTPError as e:
+                        log.error("Could not process uri: {}".format(e))
+                        return
+                    self.mimetype = urlResponse.info().get(
+                        "Content-Type", '').split(";")[0]
+                    self.uri = urlResponse.geturl()
+                    self.file = urlResponse
+
+            else:
+
+                log.debug("Unrecognized scheme, assuming local file path")
+
+                # Local data
+                if basepath:
+                    uri = os.path.normpath(os.path.join(basepath, uri))
+
+                if os.path.isfile(uri):
+                    self.uri = uri
+                    self.local = uri
+                
+                    self.setMimeTypeByName(uri)
+                    if self.mimetype.startswith('text'):
+                        self.file = open(uri, "r") #removed bytes... lets hope it goes ok :/
+                    else:
+                        self.file = open(uri, "rb") #removed bytes... lets hope it goes ok :/
+
+    def getFile(self):
+        if self.file is not None:
+            return self.file
+        if self.data is not None:
+            return pisaTempFile(self.data)
+        return None
+
+    def getNamedFile(self):
+        if self.notFound():
+            return None
+        if self.local:
+            return str(self.local)
+        if not self.tmp_file:
+            self.tmp_file = tempfile.NamedTemporaryFile()
+            if self.file:
+                shutil.copyfileobj(self.file, self.tmp_file)
+            else:
+                self.tmp_file.write(self.getData())
+            self.tmp_file.flush()
+        return self.tmp_file.name
+
+    def getData(self):
+        if self.data is not None:
+            return self.data
+        if self.file is not None:
+            try:
+                self.data = self.file.read()
+            except:
+                if self.mimetype.startswith('text'):
+                    self.file = open(self.file.name, "rb") #removed bytes... lets hope it goes ok :/
+                    self.data = self.file.read().decode('utf-8')
+                else:
+                    raise
+            return self.data
+        return None
+
+    def notFound(self):
+        return (self.file is None) and (self.data is None)
+
+    def setMimeTypeByName(self, name):
+        " Guess the mime type "
+        mimetype = mimetypes.guess_type(name)[0]
+        if mimetype is not None:
+            self.mimetype = mimetypes.guess_type(name)[0].split(";")[0]
+
+
+def getFile(*a, **kw):
+    file = pisaFileObject(*a, **kw)
+    if file.notFound():
+        return None
+    return file
+
+
 COLOR_BY_NAME = {
     'activeborder': Color(212, 208, 200),
     'activecaption': Color(10, 36, 106),
     'aliceblue': Color(.941176, .972549, 1),
     'antiquewhite': Color(.980392, .921569, .843137),
     'appworkspace': Color(128, 128, 128),
     'aqua': Color(0, 1, 1),
@@ -594,54 +849,7 @@
     'whitesmoke': Color(.960784, .960784, .960784),
     'window': Color(255, 255, 255),
     'windowframe': Color(0, 0, 0),
     'windowtext': Color(0, 0, 0),
     'yellow': Color(1, 1, 0),
     'yellowgreen': Color(.603922, .803922, .196078)
 }
-
-
-def get_default_asian_font():
-    lower_font_list = []
-    upper_font_list = []
-
-    font_dict = copy(reportlab.pdfbase._cidfontdata.defaultUnicodeEncodings)
-    fonts = font_dict.keys()
-
-    for font in fonts:
-        upper_font_list.append(font)
-        lower_font_list.append(font.lower())
-    default_asian_font = {lower_font_list[i]: upper_font_list[i] for i in range(len(lower_font_list))}
-
-    return default_asian_font
-
-
-def set_asian_fonts(fontname):
-    font_dict = copy(reportlab.pdfbase._cidfontdata.defaultUnicodeEncodings)
-    fonts = font_dict.keys()
-    if fontname in fonts:
-        pdfmetrics.registerFont(UnicodeCIDFont(fontname))
-
-
-def detect_language(name):
-    asian_language_list = xhtml2pdf.default.DEFAULT_LANGUAGE_LIST
-    if name in asian_language_list:
-        return name
-
-
-def arabic_format(text, language):
-    # Note: right now all of the languages are treated the same way.
-    # But maybe in the future we have to for example implement something
-    # for "hebrew" that isn't used in "arabic"
-    if detect_language(language) in ('arabic', 'hebrew', 'persian', 'urdu', 'pashto', 'sindhi'):
-        ar = arabic_reshaper.reshape(text)
-        return get_display(ar)
-    else:
-        return None
-
-
-def frag_text_language_check(context, frag_text):
-    if hasattr(context, 'language'):
-        language = context.__getattribute__('language')
-        detect_language_result = arabic_format(frag_text, language)
-        if detect_language_result:
-            return detect_language_result
```

## Comparing `xhtml2pdf/wsgi.py` & `xhtml2pdf-0.2b1/xhtml2pdf/wsgi.py`

 * *Files 1% similar despite different names*

```diff
@@ -10,32 +10,32 @@
 #
 # Unless required by applicable law or agreed to in writing, software
 # distributed under the License is distributed on an "AS IS" BASIS,
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
-import logging
+import xhtml2pdf.pisa as pisa
+from six import StringIO
 
-from io import StringIO
+import logging
 
-import xhtml2pdf.pisa as pisa
 
 log = logging.getLogger("xhtml2pdf.wsgi")
 
 
 class Filter(object):
     def __init__(self, app):
         self.app = app
 
     def __call__(self, environ, start_response):
         script_name = environ.get('SCRIPT_NAME', '')
         path_info = environ.get('PATH_INFO', '')
         sent = []
-        written_response = StringIO()
+        written_response = StringIO.StringIO()
 
         def replacement_start_response(status, headers, exc_info=None):
             if not self.should_filter(status, headers):
                 return start_response(status, headers, exc_info)
             else:
                 sent[:] = [status, headers, exc_info]
                 return written_response.write
@@ -73,15 +73,15 @@
         return False
 
 
 class PisaMiddleware(HTMLFilter):
     def filter(self, script_name, path_info, environ, status, headers, body):
         topdf = environ.get("pisa.topdf", "")
         if topdf:
-            dst = StringIO()
+            dst = StringIO.StringIO()
             pisa.CreatePDF(body, dst, show_error_as_pdf=True)
             headers = [
                 ("content-type", "application/pdf"),
                 ("content-disposition", "attachment; filename=" + topdf)
             ]
             body = dst.getvalue()
         return status, headers, body
```

## Comparing `xhtml2pdf/xhtml2pdf_reportlab.py` & `xhtml2pdf-0.2b1/xhtml2pdf/xhtml2pdf_reportlab.py`

 * *Files 4% similar despite different names*

```diff
@@ -10,51 +10,46 @@
 #
 # Unless required by applicable law or agreed to in writing, software
 # distributed under the License is distributed on an "AS IS" BASIS,
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
-import copy
-import logging
-import sys
 from hashlib import md5
-from html import escape as html_escape
-from io import BytesIO, StringIO
-
-import PIL.Image as PILImage
-import reportlab.pdfbase.pdfform as pdfform
 from reportlab.lib.enums import TA_RIGHT
 from reportlab.lib.styles import ParagraphStyle
-from reportlab.lib.utils import (LazyImageReader, flatten,
-                                 haveImages, open_for_read)
-from reportlab.platypus.doctemplate import (BaseDocTemplate, IndexingFlowable,
-                                            PageTemplate)
-from reportlab.platypus.flowables import (CondPageBreak, Flowable, KeepInFrame,
-                                          ParagraphAndImage)
+from reportlab.lib.utils import flatten, open_for_read, getStringIO, \
+    LazyImageReader, haveImages
+from reportlab.platypus.doctemplate import BaseDocTemplate, PageTemplate, IndexingFlowable
+from reportlab.platypus.flowables import Flowable, CondPageBreak, \
+    KeepInFrame, ParagraphAndImage
 from reportlab.platypus.tableofcontents import TableOfContents
 from reportlab.platypus.tables import Table, TableStyle
-from reportlab.rl_config import register_reset
-
-from xhtml2pdf.builders.watermarks import WaterMarks
 from xhtml2pdf.reportlab_paragraph import Paragraph
-from xhtml2pdf.util import getBorderStyle, getUID
-from xhtml2pdf.files import pisaTempFile
+from xhtml2pdf.util import getUID, getBorderStyle
+
+import six
+import sys
+
+import cgi
+import copy
+import logging
+import reportlab.pdfbase.pdfform as pdfform
 
 try:
-    from reportlab.graphics import renderPDF, renderPM
-    from svglib.svglib import svg2rlg
-except ImportError:
-    svg2rlg = None
-    renderPM = None
+    import PIL.Image as PILImage
+except:
+    try:
+        import Image as PILImage
+    except:
+        PILImage = None
 
 log = logging.getLogger("xhtml2pdf")
 
 MAX_IMAGE_RATIO = 0.95
-PRODUCER = "xhtml2pdf <https://github.com/xhtml2pdf/xhtml2pdf/>"
 
 
 class PTCycle(list):
     def __init__(self):
         self._restart = 0
         self._idx = 0
         list.__init__(self)
@@ -94,15 +89,18 @@
 class PmlBaseDoc(BaseDocTemplate):
     """
     We use our own document template to get access to the canvas
     and set some informations once.
     """
 
     def beforePage(self):
-        self.canv._doc.info.producer = PRODUCER
+
+        # Tricky way to set producer, because of not real privateness in Python
+        info = "pisa HTML to PDF <http://www.htmltopdf.org>"
+        self.canv._doc.info.producer = info
 
         '''
         # Convert to ASCII because there is a Bug in Reportlab not
         # supporting other than ASCII. Send to list on 23.1.2007
         author = toString(self.pml_data.get("author", "")).encode("ascii","ignore")
         subject = toString(self.pml_data.get("subject", "")).encode("ascii","ignore")
         title = toString(self.pml_data.get("title", "")).encode("ascii","ignore")
@@ -119,15 +117,15 @@
         '''
 
     def afterFlowable(self, flowable):
         # Does the flowable contain fragments?
         if getattr(flowable, "outline", False):
             self.notify('TOCEntry', (
                 flowable.outlineLevel,
-                html_escape(copy.deepcopy(flowable.text), 1),
+                cgi.escape(copy.deepcopy(flowable.text), 1),
                 self.page))
 
     def handle_nextPageTemplate(self, pt):
         '''
         if pt has also templates for even and odd page convert it to list
         '''
         has_left_template = self._has_template_for_name(pt + '_left')
@@ -146,32 +144,32 @@
                     return
             raise ValueError("can't find template('%s')" % pt)
         elif isinstance(pt, int):
             if hasattr(self, '_nextPageTemplateCycle'):
                 del self._nextPageTemplateCycle
             self._nextPageTemplateIndex = pt
         elif isinstance(pt, (list, tuple)):
-            # used for alternating left/right pages
-            # collect the refs to the template objects, complain if any are bad
+            #used for alternating left/right pages
+            #collect the refs to the template objects, complain if any are bad
             c = PTCycle()
             for ptn in pt:
-                # special case name used to short circuit the iteration
+            #special case name used to short circuit the iteration
                 if ptn == '*':
                     c._restart = len(c)
                     continue
                 for t in self.pageTemplates:
                     if t.id == ptn.strip():
                         c.append(t)
                         break
             if not c:
                 raise ValueError("No valid page templates in cycle")
             elif c._restart > len(c):
                 raise ValueError("Invalid cycle restart position")
 
-            # ensure we start on the first one$
+            #ensure we start on the first one$
             self._nextPageTemplateCycle = c.cyclicIterator()
         else:
             raise TypeError("Argument pt should be string or integer or list")
 
     def _has_template_for_name(self, name):
         for template in self.pageTemplates:
             if template.id == name.strip():
@@ -195,16 +193,14 @@
 
         ### Background Image ###
         self.img = None
         self.ph = 0
         self.h = 0
         self.w = 0
 
-        self.backgroundids = []
-
     def isFirstFlow(self, canvas):
         if self._first_flow:
             if canvas.getPageNumber() <= self._page_count:
                 self._first_flow = False
             else:
                 self._page_count = canvas.getPageNumber()
                 canvas._doctemplate._page_count = canvas.getPageNumber()
@@ -216,26 +212,56 @@
     def isLandscape(self):
         return self.pageorientation == self.LANDSCAPE
 
     def beforeDrawPage(self, canvas, doc):
         canvas.saveState()
         try:
 
-            if doc.pageTemplate.id not in self.backgroundids:
-                pisaBackground = None
-                if hasattr(self, "pisaBackground") and self.pisaBackground and (not self.pisaBackground.notFound()):
-                    if self.pisaBackground.getMimeType().startswith("image/"):
-                        pisaBackground = WaterMarks.generate_pdf_background(self.pisaBackground,
-                                                                            self.pagesize, self.isPortrait(),
-                                                                            context=self.backgroundContext)
-                    else:
-                        pisaBackground = self.pisaBackground
-                    self.backgroundids.append(doc.pageTemplate.id)
-                if pisaBackground:
-                    self.pisaBackgroundList.append((canvas.getPageNumber(), pisaBackground, self.backgroundContext))
+            # Background
+            pisaBackground = None
+            if (self.isFirstFlow(canvas)
+                and hasattr(self, "pisaBackground")
+                and self.pisaBackground
+                and (not self.pisaBackground.notFound())):
+
+                # Is image not PDF
+                if self.pisaBackground.mimetype.startswith("image/"):
+
+                    try:
+                        self.img = PmlImageReader(six.StringIO(self.pisaBackground.getData()))
+                        iw, ih = self.img.getSize()
+                        pw, self.ph = canvas._pagesize
+
+                        width = pw  # min(iw, pw) # max
+                        wfactor = float(width) / iw
+                        height = self.ph  # min(ih, ph) # max
+                        hfactor = float(height) / ih
+                        factor_min = min(wfactor, hfactor)
+
+                        if self.isPortrait():
+                            self.w = iw * factor_min
+                            self.h = ih * factor_min
+                        elif self.isLandscape():
+                            factor_max = max(wfactor, hfactor)
+                            self.h = ih * factor_max
+                            self.w = iw * factor_min
+                    except:
+                        log.exception("Draw background")
+
+                # PDF!
+                else:
+                    pisaBackground = self.pisaBackground
+
+            if pisaBackground:
+                self.pisaBackgroundList.append(pisaBackground)
+            else:
+                if self.isPortrait():
+                    canvas.drawImage(self.img, 0, self.ph - self.h, self.w, self.h)
+                elif self.isLandscape():
+                    canvas.drawImage(self.img, 0, 0, self.w, self.h)
 
             def pageNumbering(objList):
                 for obj in flatten(objList):
                     if isinstance(obj, PmlParagraph):
                         for frag in obj.frags:
                             if frag.pageNumber:
                                 frag.text = str(pagenumber)
@@ -247,18 +273,14 @@
                         flat_cells = [item for sublist in obj._cellvalues for item in sublist]
                         pageNumbering(flat_cells)
 
             try:
 
                 # Paint static frames
                 pagenumber = canvas.getPageNumber()
-                if pagenumber > self._page_count:
-                    self._page_count = canvas.getPageNumber()
-                    canvas._doctemplate._page_count = canvas.getPageNumber()
-                
                 for frame in self.pisaStaticList:
                     frame = copy.deepcopy(frame)
                     story = frame.pisaStaticStory
                     pageNumbering(story)
 
                     frame.addFromList(story, canvas)
 
@@ -275,58 +297,59 @@
     """
     Wraps up either PIL or Java to get data from bitmaps
     """
     _cache = {}
 
     def __init__(self, fileName):
         if isinstance(fileName, PmlImageReader):
-            self.__dict__ = fileName.__dict__  # borgize
+            self.__dict__ = fileName.__dict__   # borgize
             return
-            # start wih lots of null private fields, to be populated by
-        # the relevant engine.
+            #start wih lots of null private fields, to be populated by
+        #the relevant engine.
         self.fileName = fileName
         self._image = None
         self._width = None
         self._height = None
         self._transparent = None
         self._data = None
         imageReaderFlags = 0
         if PILImage and isinstance(fileName, PILImage.Image):
             self._image = fileName
             self.fp = getattr(fileName, 'fp', None)
             try:
-                self.fileName = fileName
+                self.fileName = self._image.fileName
             except AttributeError:
                 self.fileName = 'PILIMAGE_%d' % id(self)
         else:
             try:
                 self.fp = open_for_read(fileName, 'b')
-                if isinstance(self.fp, BytesIO().__class__):
+                if isinstance(self.fp, six.BytesIO().__class__):
                     # avoid messing with already internal files
                     imageReaderFlags = 0
                 if imageReaderFlags > 0:  # interning
                     data = self.fp.read()
                     if imageReaderFlags & 2:  # autoclose
                         try:
                             self.fp.close()
                         except:
                             pass
                     if imageReaderFlags & 4:  # cache the data
                         if not self._cache:
+                            from rl_config import register_reset
                             register_reset(self._cache.clear)
 
                         data = self._cache.setdefault(md5(data).digest(), data)
-                    self.fp = StringIO(data)
-                elif imageReaderFlags == - 1 and isinstance(fileName, str):
-                    # try Ralf Schmitt's re-opening technique of avoiding too many open files
+                    self.fp = getStringIO(data)
+                elif imageReaderFlags == - 1 and isinstance(fileName, six.text_type):
+                    #try Ralf Schmitt's re-opening technique of avoiding too many open files
                     self.fp.close()
                     del self.fp  # will become a property in the next statement
                     self.__class__ = LazyImageReader
                 if haveImages:
-                    # detect which library we are using and open the image
+                    #detect which library we are using and open the image
                     if not self._image:
                         self._image = self._read_image(self.fp)
                     if getattr(self._image, 'format', None) == 'JPEG':
                         self.jpeg_fh = self._jpeg_fh
                 else:
                     from reportlab.pdfbase.pdfutils import readJPEGInfo
 
@@ -345,16 +368,16 @@
                     ev.args = ev.args[: - 1] + (a,)
                     raise RuntimeError("{0} {1} {2}".format(et, ev, tb))
                 else:
                     raise
 
     def _read_image(self, fp):
         if sys.platform[0:4] == 'java':
-            from java.io import ByteArrayInputStream
             from javax.imageio import ImageIO
+            from java.io import ByteArrayInputStream
             input_stream = ByteArrayInputStream(fp.read())
             return ImageIO.read(input_stream)
         elif PILImage:
             return PILImage.open(fp)
 
     def _jpeg_fh(self):
         fp = self.fp
@@ -429,17 +452,16 @@
                 palette = palette.data
             else:
                 return None
 
             # 8-bit PNGs could give an empty string as transparency value, so
             # we have to be careful here.
             try:
-                return list(palette[transparency:transparency + 3])
-            except Exception as e:
-                log.debug(str(e), exc_info=e)
+                return map(ord, palette[transparency:transparency + 3])
+            except:
                 return None
         else:
             return None
 
     def __str__(self):
         try:
             fn = self.fileName.read()
@@ -455,27 +477,20 @@
 
 class PmlImage(Flowable, PmlMaxHeightMixIn):
 
     def __init__(self, data, width=None, height=None, mask="auto", mimetype=None, **kw):
         self.kw = kw
         self.hAlign = 'CENTER'
         self._mask = mask
-        self._imgdata = data.getvalue() if isinstance(data, pisaTempFile) else data
+        self._imgdata = data
         # print "###", repr(data)
         self.mimetype = mimetype
-
-        # Resolve size
-        drawing = self.getDrawing()
-        if drawing:
-            _, _, self.imageWidth, self.imageHeight = drawing.getBounds() or (0, 0, 0, 0)
-        else:
-            img = self.getImage()
-            if img:
-                self.imageWidth, self.imageHeight = img.getSize()
-
+        img = self.getImage()
+        if img:
+            self.imageWidth, self.imageHeight = img.getSize()
         self.drawWidth = width or self.imageWidth
         self.drawHeight = height or self.imageHeight
 
     def wrap(self, availWidth, availHeight):
         " This can be called more than once! Do not overwrite important data like drawWidth "
         availHeight = self.setMaxHeight(availHeight)
         # print "image wrap", id(self), availWidth, availHeight, self.drawWidth, self.drawHeight
@@ -485,63 +500,19 @@
         hfactor = float(height) / self.drawHeight
         factor = min(wfactor, hfactor)
         self.dWidth = self.drawWidth * factor
         self.dHeight = self.drawHeight * factor
         # print "imgage result", factor, self.dWidth, self.dHeight
         return self.dWidth, self.dHeight
 
-    def getDrawing(self, width=None, height=None):
-        """ If this image is a vector image and the library is available, returns a ReportLab Drawing."""
-        if svg2rlg:
-            try:
-                drawing = svg2rlg(BytesIO(self._imgdata))
-            except Exception:
-                return None
-            if drawing:
-
-                # Apply size
-                scale_x = 1
-                scale_y = 1
-                if getattr(self, "drawWidth", None) is not None:
-                    if width is None:
-                        width = self.drawWidth
-                    scale_x = width / drawing.width
-                if getattr(self, "drawHeight", None) is not None:
-                    if height is None:
-                        height = self.drawHeight
-                    scale_y = height / drawing.height
-                if scale_x != 1 or scale_y != 1:
-                    drawing.scale(scale_x, scale_y)
-
-                return drawing
-        return None
-
-    def getDrawingRaster(self):
-        """ If this image is a vector image and the libraries are available, returns a PNG raster. """
-        if svg2rlg and renderPM:
-            svg = self.getDrawing()
-            if svg:
-                imgdata = BytesIO()
-                renderPM.drawToFile(svg, imgdata, fmt="PNG")
-                return imgdata
-        return None
-
     def getImage(self):
-        """ Returns a raster image. """
-        vectorRaster = self.getDrawingRaster()
-        imgdata = vectorRaster or BytesIO(self._imgdata)
-        img = PmlImageReader(imgdata)
+        img = PmlImageReader(six.BytesIO(self._imgdata))
         return img
 
     def draw(self):
-        # TODO this code should work, but untested
-        # drawing = self.getDrawing(self.dWidth, self.dHeight)
-        # if drawing and renderPDF:
-        #     renderPDF.draw(drawing, self.canv, 0, 0)
-        # else:
         img = self.getImage()
         self.canv.drawImage(
             img,
             0, 0,
             self.dWidth,
             self.dHeight,
             mask=self._mask)
@@ -597,29 +568,29 @@
 
         # Modify maxium image sizes
         self._calcImageMaxSizes(availWidth, availHeight)
 
         # call the base class to do wrapping and calculate the size
         Paragraph.wrap(self, availWidth, availHeight)
 
-        # self.height = max(1, self.height)
-        # self.width = max(1, self.width)
+        #self.height = max(1, self.height)
+        #self.width = max(1, self.width)
 
         # increase the calculated size by the padding
         self.width = self.width + self.deltaWidth
         self.height = self.height + self.deltaHeight
 
         return self.width, self.height
 
     def split(self, availWidth, availHeight):
 
         if len(self.frags) <= 0:
             return []
 
-        # the split information is all inside self.blPara
+        #the split information is all inside self.blPara
         if not hasattr(self, 'deltaWidth'):
             self.wrap(availWidth, availHeight)
 
         availWidth -= self.deltaWidth
         availHeight -= self.deltaHeight
 
         return Paragraph.split(self, availWidth, availHeight)
@@ -849,15 +820,15 @@
             if i:  # Not for first element
                 tableStyle.append((
                     'TOPPADDING',
                     (0, i), (- 1, i),
                     max(lastMargin, leftColStyle.spaceBefore)))
                 # print leftColStyle.leftIndent
             lastMargin = leftColStyle.spaceAfter
-            # right col style is right aligned
+            #right col style is right aligned
             rightColStyle = ParagraphStyle(name='leftColLevel%d' % level,
                                            parent=leftColStyle,
                                            leftIndent=0,
                                            alignment=TA_RIGHT)
             leftPara = Paragraph(text, leftColStyle)
             rightPara = Paragraph(str(pageNum), rightColStyle)
             tableData.append([leftPara, rightPara])
@@ -892,39 +863,37 @@
         if self.canv.getPageNumber() % 2:
             self.width = availWidth
             self.height = availHeight
             return availWidth, availHeight
         self.width = self.height = 0
         return 0, 0
 
-
 # --- Pdf Form
 
 
 class PmlInput(Flowable):
-    def __init__(self, name, input_type="text", width=10, height=10, default="",
-                 options=None, multiline=0):
+    def __init__(self, name, type="text", width=10, height=10, default="",
+                 options=None):
         self.width = width
         self.height = height
-        self.type = input_type
+        self.type = type
         self.name = name
         self.default = default
         self.options = options if options is not None else []
-        self.multiline = multiline
 
     def wrap(self, *args):
         return self.width, self.height
 
     def draw(self):
         c = self.canv
 
         c.saveState()
         c.setFont("Helvetica", 10)
         if self.type == "text":
-            pdfform.textFieldRelative(c, self.name, 0, 0, self.width, self.height, multiline=self.multiline)
+            pdfform.textFieldRelative(c, self.name, 0, 0, self.width, self.height)
             c.rect(0, 0, self.width, self.height)
         elif self.type == "radio":
             c.rect(0, 0, self.width, self.height)
         elif self.type == "checkbox":
             if self.default:
                 pdfform.buttonFieldRelative(c, self.name, "Yes", 0, 0)
             else:
```

## Comparing `xhtml2pdf/w3c/css.py` & `xhtml2pdf-0.2b1/xhtml2pdf/w3c/css.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,16 +1,18 @@
 #!/usr/bin/env python
-
-# Copyright (C) 2002-2004  TechGame Networks, LLC.
-#
-# This library is free software; you can redistribute it and/or
-# modify it under the terms of the BSD style License as found in the
-# LICENSE file included with this distribution.
-#
-#  Modified by Dirk Holtwick <holtwick@web.de>, 2007-2008
+##~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+# #~ Copyright (C) 2002-2004  TechGame Networks, LLC.
+# #~
+# #~ This library is free software; you can redistribute it and/or
+# #~ modify it under the terms of the BSD style License as found in the
+# #~ LICENSE file included with this distribution.
+# #
+# #  Modified by Dirk Holtwick <holtwick@web.de>, 2007-2008
+##~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+from __future__ import absolute_import
 
 """CSS-2.1 engine
 
 Primary classes:
     * CSSElementInterfaceAbstract
         Provide a concrete implementation for the XML element model used.
 
@@ -27,74 +29,83 @@
         CSSParser requests.
 
 Dependencies:
     python 2.3 (or greater)
     sets, cssParser, re (via cssParser)
 """
 
-import copy
 import os
+import sys
+import copy
+import six
+
 
 from . import cssParser
 from . import cssSpecial
 
 
-# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 # ~ To replace any for with list comprehension
-# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 def stopIter(value):
     raise StopIteration(*value)
 
 
-# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 # ~ Constants / Variables / Etc.
-# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 CSSParseError = cssParser.CSSParseError
 
-
-# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 # ~ Definitions
-# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 class CSSElementInterfaceAbstract(object):
     def getAttr(self, name, default=NotImplemented):
         raise NotImplementedError('Subclass responsibility')
 
+
     def getIdAttr(self):
         return self.getAttr('id', '')
 
+
     def getClassAttr(self):
         return self.getAttr('class', '')
 
+
     def getInlineStyle(self):
         raise NotImplementedError('Subclass responsibility')
 
+
     def matchesNode(self):
         raise NotImplementedError('Subclass responsibility')
 
+
     def inPseudoState(self, name, params=()):
         raise NotImplementedError('Subclass responsibility')
 
+
     def iterXMLParents(self):
         """Results must be compatible with CSSElementInterfaceAbstract"""
         raise NotImplementedError('Subclass responsibility')
 
+
     def getPreviousSibling(self):
         raise NotImplementedError('Subclass responsibility')
 
-
-# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 class CSSCascadeStrategy(object):
     author = None
     user = None
     userAgenr = None
 
+
     def __init__(self, author=None, user=None, userAgent=None):
         if author is not None:
             self.author = author
         if user is not None:
             self.user = user
         if userAgent is not None:
             self.userAgenr = userAgent
@@ -104,15 +115,16 @@
             author = self.author
         if user is None:
             user = self.user
         if userAgent is None:
             userAgent = self.userAgenr
         return self.__class__(author, user, userAgent)
 
-    # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
     def iterCSSRulesets(self, inline=None):
         if self.userAgenr is not None:
             yield self.userAgenr[0]
             yield self.userAgenr[1]
 
         if self.user is not None:
@@ -125,38 +137,41 @@
         if inline:
             yield inline[0]
             yield inline[1]
 
         if self.user is not None:
             yield self.user[1]
 
-    # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
     def findStyleFor(self, element, attrName, default=NotImplemented):
         """Attempts to find the style setting for attrName in the CSSRulesets.
 
         Note: This method does not attempt to resolve rules that return
         "inherited", "default", or values that have units (including "%").
         This is left up to the client app to re-query the CSS in order to
         implement these semantics.
         """
         rule = self.findCSSRulesFor(element, attrName)
         return self._extractStyleForRule(rule, attrName, default)
 
+
     def findStylesForEach(self, element, attrNames, default=NotImplemented):
         """Attempts to find the style setting for attrName in the CSSRulesets.
 
         Note: This method does not attempt to resolve rules that return
         "inherited", "default", or values that have units (including "%").
         This is left up to the client app to re-query the CSS in order to
         implement these semantics.
         """
         rules = self.findCSSRulesForEach(element, attrNames)
         return [(attrName, self._extractStyleForRule(rule, attrName, default))
-                for attrName, rule in rules.items()]
+                for attrName, rule in six.iteritems(rules)]
+
 
     def findCSSRulesFor(self, element, attrName):
         rules = []
 
         inline = element.getInlineStyle()
 
         # Generator are wonderfull but sometime slow...
@@ -180,104 +195,136 @@
 
         if self.user is not None:
             rules += self.user[1].findCSSRuleFor(element, attrName)
 
         rules.sort()
         return rules
 
+
     def findCSSRulesForEach(self, element, attrNames):
         rules = dict((name, []) for name in attrNames)
 
         inline = element.getInlineStyle()
         for ruleset in self.iterCSSRulesets(inline):
-            for attrName, attrRules in rules.items():
+            for attrName, attrRules in six.iteritems(rules):
                 attrRules += ruleset.findCSSRuleFor(element, attrName)
 
-        for attrRules in rules.items():
+        for attrRules in six.itervalues(rules):
             attrRules.sort()
         return rules
 
-    # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
     def _extractStyleForRule(self, rule, attrName, default=NotImplemented):
         if rule:
             # rule is packed in a list to differentiate from "no rule" vs "rule
             # whose value evalutates as False"
             style = rule[-1][1]
             return style[attrName]
         elif default is not NotImplemented:
             return default
         raise LookupError("Could not find style for '%s' in %r" % (attrName, rule))
 
-
-# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 # ~ CSS Selectors
-# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 class CSSSelectorBase(object):
     inline = False
     _hash = None
     _specificity = None
 
+
     def __init__(self, completeName='*'):
         if not isinstance(completeName, tuple):
             completeName = (None, '*', completeName)
         self.completeName = completeName
 
+
     def _updateHash(self):
         self._hash = hash((self.fullName, self.specificity(), self.qualifiers))
 
+
     def __hash__(self):
         if self._hash is None:
             return object.__hash__(self)
         return self._hash
 
+
     def getNSPrefix(self):
         return self.completeName[0]
 
+
     nsPrefix = property(getNSPrefix)
 
+
     def getName(self):
         return self.completeName[2]
 
+
     name = property(getName)
 
+
     def getNamespace(self):
         return self.completeName[1]
 
+
     namespace = property(getNamespace)
 
+
     def getFullName(self):
         return self.completeName[1:3]
 
+
     fullName = property(getFullName)
 
+
     def __repr__(self):
         strArgs = (self.__class__.__name__,) + self.specificity() + (self.asString(),)
         return '<%s %d:%d:%d:%d %s >' % strArgs
 
+
     def __str__(self):
         return self.asString()
 
-    def _as_comparison_key(self):
-        return (self.specificity(), self.fullName, self.qualifiers)
-
     def __eq__(self, other):
         """Python 3"""
-        return self._as_comparison_key() == other._as_comparison_key()
+        return (
+            self.specificity() == other.specificity() and
+            self.fullName == other.fullName and
+            self.qualifiers == other.qualifiers
+        )
 
     def __lt__(self, other):
         """Python 3"""
-        return self._as_comparison_key() < other._as_comparison_key()
+        return not self.__eq__(other) and (
+            self.specificity() < other.specificity() or
+            self.fullName < other.fullName or
+            self.qualifiers < other.qualifiers
+        )
+
+    def __cmp__(self, other):
+        """Python 2"""
+        result = cmp(self.specificity(), other.specificity())  # silence pyflakes
+        if result != 0:
+            return result
+        result = cmp(self.fullName, other.fullName)  # silence pyflakes
+        if result != 0:
+            return result
+        result = cmp(self.qualifiers, other.qualifiers)  # silence pyflakes
+        return result
+
 
     def specificity(self):
         if self._specificity is None:
             self._specificity = self._calcSpecificity()
         return self._specificity
 
+
     def _calcSpecificity(self):
         """from http://www.w3.org/TR/CSS21/cascade.html#specificity"""
         hashCount = 0
         qualifierCount = 0
         elementCount = int(self.name != '*')
         for q in self.qualifiers:
             if q.isHash():
@@ -291,14 +338,15 @@
             elif q.isCombiner():
                 i, h, q, e = q.selector.specificity()
                 hashCount += h
                 qualifierCount += q
                 elementCount += e
         return self.inline, hashCount, qualifierCount, elementCount
 
+
     def matches(self, element=None):
         if element is None:
             return False
 
         # with  CSSDOMElementInterface.matchesNode(self, (namespace, tagName)) replacement:
         if self.fullName[1] not in ('*', element.domElement.tagName):
             return False
@@ -307,161 +355,189 @@
 
         for qualifier in self.qualifiers:
             if not qualifier.matches(element):
                 return False
         else:
             return True
 
+
     def asString(self):
         result = []
         if self.nsPrefix is not None:
             result.append('%s|%s' % (self.nsPrefix, self.name))
         else:
             result.append(self.name)
 
         for q in self.qualifiers:
             if q.isCombiner():
                 result.insert(0, q.asString())
             else:
                 result.append(q.asString())
         return ''.join(result)
 
-
-# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 class CSSInlineSelector(CSSSelectorBase):
     inline = True
 
-
-# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 class CSSMutableSelector(CSSSelectorBase, cssParser.CSSSelectorAbstract):
     qualifiers = []
 
+
     def asImmutable(self):
         return CSSImmutableSelector(self.completeName, [q.asImmutable() for q in self.qualifiers])
 
+
     def combineSelectors(klass, selectorA, op, selectorB):
         selectorB.addCombination(op, selectorA)
         return selectorB
 
+
     combineSelectors = classmethod(combineSelectors)
 
+
     def addCombination(self, op, other):
         self._addQualifier(CSSSelectorCombinationQualifier(op, other))
 
+
     def addHashId(self, hashId):
         self._addQualifier(CSSSelectorHashQualifier(hashId))
 
+
     def addClass(self, class_):
         self._addQualifier(CSSSelectorClassQualifier(class_))
 
+
     def addAttribute(self, attrName):
         self._addQualifier(CSSSelectorAttributeQualifier(attrName))
 
+
     def addAttributeOperation(self, attrName, op, attrValue):
         self._addQualifier(CSSSelectorAttributeQualifier(attrName, op, attrValue))
 
+
     def addPseudo(self, name):
         self._addQualifier(CSSSelectorPseudoQualifier(name))
 
+
     def addPseudoFunction(self, name, params):
         self._addQualifier(CSSSelectorPseudoQualifier(name, params))
 
-    # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
     def _addQualifier(self, qualifier):
         if self.qualifiers:
             self.qualifiers.append(qualifier)
         else:
             self.qualifiers = [qualifier]
 
-
-# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 class CSSImmutableSelector(CSSSelectorBase):
     def __init__(self, completeName='*', qualifiers=()):
         # print completeName, qualifiers
         self.qualifiers = tuple(qualifiers)
         CSSSelectorBase.__init__(self, completeName)
         self._updateHash()
 
+
     def fromSelector(klass, selector):
         return klass(selector.completeName, selector.qualifiers)
 
-    fromSelector = classmethod(fromSelector)
 
+    fromSelector = classmethod(fromSelector)
 
-# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
-# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 # ~ CSS Selector Qualifiers -- see CSSImmutableSelector
-# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 class CSSSelectorQualifierBase(object):
     def isHash(self):
         return False
 
+
     def isClass(self):
         return False
 
+
     def isAttr(self):
         return False
 
+
     def isPseudo(self):
         return False
 
+
     def isCombiner(self):
         return False
 
+
     def asImmutable(self):
         return self
 
+
     def __str__(self):
         return self.asString()
 
 
 class CSSSelectorHashQualifier(CSSSelectorQualifierBase):
     def __init__(self, hashId):
         self.hashId = hashId
 
+
     def isHash(self):
         return True
 
+
     def __hash__(self):
         return hash((self.hashId,))
 
+
     def asString(self):
         return '#' + self.hashId
 
+
     def matches(self, element):
         return element.getIdAttr() == self.hashId
 
     def __eq__(self, other):
         """Python 3"""
         return self.hashId == other.hashId
 
     def __lt__(self, other):
         """Python 3"""
         return self.hashId < other.hashId
 
+    def __cmp__(self, other):
+        """Python 2"""
+        return cmp(self.hashId, other.hashId)
+
 
 class CSSSelectorClassQualifier(CSSSelectorQualifierBase):
     def __init__(self, classId):
         self.classId = classId
 
+
     def isClass(self):
         return True
 
+
     def __hash__(self):
         return hash((self.classId,))
 
+
     def asString(self):
         return '.' + self.classId
 
+
     def matches(self, element):
         # return self.classId in element.getClassAttr().split()
         attrValue = element.domElement.attributes.get('class')
         if attrValue is not None:
             return self.classId in attrValue.value.split()
         return False
 
@@ -469,25 +545,30 @@
         """Python 3"""
         return self.classId == other.classId
 
     def __lt__(self, other):
         """Python 3"""
         return self.classId < other.classId
 
+    def __cmp__(self, other):
+        """Python 2"""
+        return cmp(self.classId, other.classId)
+
 
 class CSSSelectorAttributeQualifier(CSSSelectorQualifierBase):
     name, op, value = None, None, NotImplemented
 
     def __init__(self, attrName, op=None, attrValue=NotImplemented):
         self.name = attrName
         if op is not self.op:
             self.op = op
         if attrValue is not self.value:
             self.value = attrValue
 
+
     def isAttr(self):
         return True
 
     def __hash__(self):
         return hash((self.name, self.op, self.value))
 
     def asString(self):
@@ -537,63 +618,77 @@
 
 
 class CSSSelectorCombinationQualifier(CSSSelectorQualifierBase):
     def __init__(self, op, selector):
         self.op = op
         self.selector = selector
 
+
     def isCombiner(self):
         return True
 
+
     def __hash__(self):
         return hash((self.op, self.selector))
 
+
     def asImmutable(self):
         return self.__class__(self.op, self.selector.asImmutable())
 
+
     def asString(self):
         return '%s%s' % (self.selector.asString(), self.op)
 
     def matches(self, element):
-        op, selector = self.op, self.selector
-        if op == ' ':
-            return any(selector.matches(parent) for parent in element.iterXMLParents())
-        elif op == '>':
-            parent = next(element.iterXMLParents(), None)
-            if parent is None:
-                return False
-            return selector.matches(parent)
-        elif op == '+':
-            return selector.matches(element.getPreviousSibling())
+        if self.op == ' ':
+            if element is not None:
+                if element.matchesNode(self.selector.fullName):
+                    try:
+                        for parent in element.iterXMLParents():
+                            [None for qualifier in self.selector.qualifiers if
+                             qualifier.matches(parent) and stopIter((None,))]
+                    except StopIteration:
+                        return True
+            return False
+        elif self.op == '>':
+            if element is not None:
+                if element.matchesNode(self.selector.fullName):
+                    if self.selector.qualifiers[0].matches(element):
+                        return True
+            return False
+        elif self.op == '+':
+            return self.selector.matches(element.getPreviousSibling())
 
 
-# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 # ~ CSS Misc
-# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 class CSSTerminalFunction(object):
     def __init__(self, name, params):
         self.name = name
-        self.params = [param if isinstance(param, str) else str(param) for param in params]
+        self.params = params
+
 
     def __repr__(self):
         return '<CSS function: %s(%s)>' % (self.name, ', '.join(self.params))
 
 
 class CSSTerminalOperator(tuple):
     def __new__(klass, *args):
         return tuple.__new__(klass, args)
 
+
     def __repr__(self):
         return 'op' + tuple.__repr__(self)
 
-
-# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 # ~ CSS Objects
-# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 class CSSDeclarations(dict):
     pass
 
     def __eq__(self, other):
         """Python 3"""
         return False
@@ -601,126 +696,142 @@
     def __lt__(self, other):
         """Python 3"""
         return False
 
 
 class CSSRuleset(dict):
     def findCSSRulesFor(self, element, attrName):
-        ruleResults = [(nodeFilter, declarations) for nodeFilter, declarations in self.items() if
+        ruleResults = [(nodeFilter, declarations) for nodeFilter, declarations in six.iteritems(self) if
                        (attrName in declarations) and (nodeFilter.matches(element))]
         ruleResults.sort()
         return ruleResults
 
+
     def findCSSRuleFor(self, element, attrName):
         # rule is packed in a list to differentiate from "no rule" vs "rule
         # whose value evalutates as False"
         return self.findCSSRulesFor(element, attrName)[-1:]
 
+
     def mergeStyles(self, styles):
         " XXX Bugfix for use in PISA "
-        for k, v in styles.items():
+        for k, v in six.iteritems(styles):
             if k in self and self[k]:
                 self[k] = copy.copy(self[k])
                 self[k].update(v)
             else:
                 self[k] = v
 
 
 class CSSInlineRuleset(CSSRuleset, CSSDeclarations):
     def findCSSRulesFor(self, element, attrName):
         if attrName in self:
             return [(CSSInlineSelector(), self)]
         return []
 
+
     def findCSSRuleFor(self, *args, **kw):
         # rule is packed in a list to differentiate from "no rule" vs "rule
         # whose value evalutates as False"
         return self.findCSSRulesFor(*args, **kw)[-1:]
 
-
-# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 # ~ CSS Builder
-# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 class CSSBuilder(cssParser.CSSBuilderAbstract):
     RulesetFactory = CSSRuleset
     SelectorFactory = CSSMutableSelector
     MediumSetFactory = set
     DeclarationsFactory = CSSDeclarations
     TermFunctionFactory = CSSTerminalFunction
     TermOperatorFactory = CSSTerminalOperator
     xmlnsSynonyms = {}
     mediumSet = None
     trackImportance = True
     charset = None
 
+
     def __init__(self, mediumSet=mediumSet, trackImportance=trackImportance):
         self.setMediumSet(mediumSet)
         self.setTrackImportance(trackImportance)
 
+
     def isValidMedium(self, mediums):
         if not mediums:
             return False
         if 'all' in mediums:
             return True
 
         mediums = self.MediumSetFactory(mediums)
         return bool(self.getMediumSet().intersection(mediums))
 
+
     def getMediumSet(self):
         return self.mediumSet
 
+
     def setMediumSet(self, mediumSet):
         self.mediumSet = self.MediumSetFactory(mediumSet)
 
+
     def updateMediumSet(self, mediumSet):
         self.getMediumSet().update(mediumSet)
 
+
     def getTrackImportance(self):
         return self.trackImportance
 
+
     def setTrackImportance(self, trackImportance=True):
         self.trackImportance = trackImportance
 
-    # ~ helpers ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+    #~ helpers ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
     def _pushState(self):
         _restoreState = self.__dict__
         self.__dict__ = self.__dict__.copy()
         self._restoreState = _restoreState
         self.namespaces = {}
 
+
     def _popState(self):
         self.__dict__ = self._restoreState
 
+
     def _declarations(self, declarations, DeclarationsFactory=None):
         DeclarationsFactory = DeclarationsFactory or self.DeclarationsFactory
         if self.trackImportance:
             normal, important = [], []
             for d in declarations:
                 if d[-1]:
                     important.append(d[:-1])
                 else:
                     normal.append(d[:-1])
             return DeclarationsFactory(normal), DeclarationsFactory(important)
         else:
             return DeclarationsFactory(declarations)
 
+
     def _xmlnsGetSynonym(self, uri):
         # Don't forget to substitute our namespace synonyms!
         return self.xmlnsSynonyms.get(uri or None, uri) or None
 
-    # ~ css results ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+    #~ css results ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
     def beginStylesheet(self):
         self._pushState()
 
+
     def endStylesheet(self):
         self._popState()
 
+
     def stylesheet(self, stylesheetElements, stylesheetImports):
         # XXX Updated for PISA
         if self.trackImportance:
             normal, important = self.RulesetFactory(), self.RulesetFactory()
             for normalStylesheet, importantStylesheet in stylesheetImports:
                 normal.mergeStyles(normalStylesheet)
                 important.mergeStyles(importantStylesheet)
@@ -733,27 +844,32 @@
             for stylesheet in stylesheetImports:
                 result.mergeStyles(stylesheet)
 
             for styleElement in stylesheetElements:
                 result.mergeStyles(styleElement)
             return result
 
+
     def beginInline(self):
         self._pushState()
 
+
     def endInline(self):
         self._popState()
 
+
     def specialRules(self, declarations):
         return cssSpecial.parseSpecialRules(declarations)
 
+
     def inline(self, declarations):
         declarations = self.specialRules(declarations)
         return self._declarations(declarations, CSSInlineRuleset)
 
+
     def ruleset(self, selectors, declarations):
 
         # XXX Modified for pisa!
         declarations = self.specialRules(declarations)
         # XXX Modified for pisa!
 
         if self.trackImportance:
@@ -767,71 +883,83 @@
                     important[s] = importantDecl
             return normal, important
         else:
             declarations = self._declarations(declarations)
             result = [(s.asImmutable(), declarations) for s in selectors]
             return self.RulesetFactory(result)
 
-    # ~ css namespaces ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+    #~ css namespaces ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
     def resolveNamespacePrefix(self, nsPrefix, name):
         if nsPrefix == '*':
             return (nsPrefix, '*', name)
         xmlns = self.namespaces.get(nsPrefix, None)
         xmlns = self._xmlnsGetSynonym(xmlns)
         return (nsPrefix, xmlns, name)
 
-    # ~ css @ directives ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+    #~ css @ directives ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
     def atCharset(self, charset):
         self.charset = charset
 
+
     def atImport(self, import_, mediums, cssParser):
         if self.isValidMedium(mediums):
             return cssParser.parseExternal(import_)
         return None
 
+
     def atNamespace(self, nsprefix, uri):
         self.namespaces[nsprefix] = uri
 
+
     def atMedia(self, mediums, ruleset):
         if self.isValidMedium(mediums):
             return ruleset
         return None
 
+
     def atPage(self, page, pseudopage, declarations):
         """
         This is overriden by xhtml2pdf.context.pisaCSSBuilder
         """
         return self.ruleset([self.selector('*')], declarations)
 
+
     def atFontFace(self, declarations):
         """
         This is overriden by xhtml2pdf.context.pisaCSSBuilder
         """
         return self.ruleset([self.selector('*')], declarations)
 
+
     def atIdent(self, atIdent, cssParser, src):
         return src, NotImplemented
 
-    # ~ css selectors ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+    #~ css selectors ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
     def selector(self, name):
         return self.SelectorFactory(name)
 
+
     def combineSelectors(self, selectorA, op, selectorB):
         return self.SelectorFactory.combineSelectors(selectorA, op, selectorB)
 
-    # ~ css declarations ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+    #~ css declarations ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
     def property(self, name, value, important=False):
         if self.trackImportance:
             return (name, value, important)
         return (name, value)
 
+
     def combineTerms(self, termA, op, termB):
         if op in (',', ' '):
             if isinstance(termA, list):
                 termA.append(termB)
                 return termA
             return [termA, termB]
         elif op is None and termB is None:
@@ -840,54 +968,66 @@
             if isinstance(termA, list):
                 # Bind these "closer" than the list operators -- i.e. work on
                 # the (recursively) last element of the list
                 termA[-1] = self.combineTerms(termA[-1], op, termB)
                 return termA
             return self.TermOperatorFactory(termA, op, termB)
 
+
     def termIdent(self, value):
         return value
 
+
     def termNumber(self, value, units=None):
         if units:
             return value, units
         return value
 
+
     def termRGB(self, value):
         return value
 
+
     def termURI(self, value):
         return value
 
+
     def termString(self, value):
         return value
 
+
     def termUnicodeRange(self, value):
         return value
 
+
     def termFunction(self, name, value):
         return self.TermFunctionFactory(name, value)
 
+
     def termUnknown(self, src):
         return src, NotImplemented
 
-
-# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 # ~ CSS Parser -- finally!
-# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 class CSSParser(cssParser.CSSParser):
     CSSBuilderFactory = CSSBuilder
 
+
     def __init__(self, cssBuilder=None, create=True, **kw):
         if not cssBuilder and create:
             assert cssBuilder is None
             cssBuilder = self.createCSSBuilder(**kw)
         cssParser.CSSParser.__init__(self, cssBuilder)
 
+
     def createCSSBuilder(self, **kw):
         return self.CSSBuilderFactory(**kw)
 
+
     def parseExternal(self, cssResourceName):
         if os.path.isfile(cssResourceName):
-            return self.parseFile(cssResourceName)
+            cssFile = open(cssResourceName, 'r')
+            return self.parseFile(cssFile, True)
         raise RuntimeError("Cannot resolve external CSS file: \"%s\"" % cssResourceName)
+
```

## Comparing `xhtml2pdf/w3c/cssDOMElementInterface.py` & `xhtml2pdf-0.2b1/xhtml2pdf/w3c/cssDOMElementInterface.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,19 +1,20 @@
 #!/usr/bin/env python
+##~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+##~ Copyright (C) 2002-2004  TechGame Networks, LLC.
+##~
+##~ This library is free software; you can redistribute it and/or
+##~ modify it under the terms of the BSD style License as found in the
+##~ LICENSE file included with this distribution.
+##
+##  Modified by Dirk Holtwick <holtwick@web.de>, 2007-2008
+##~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+from __future__ import absolute_import
 
-# Copyright (C) 2002-2004  TechGame Networks, LLC.
-#
-# This library is free software; you can redistribute it and/or
-# modify it under the terms of the BSD style License as found in the
-# LICENSE file included with this distribution.
-#
-# Modified by Dirk Holtwick <holtwick@web.de>, 2007-2008
-
-from . import css  # python 3
-
+from . import css #python 3
 
 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 #~ Definitions
 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 class CSSDOMElementInterface(css.CSSElementInterfaceAbstract):
     """An implementation of css.CSSElementInterfaceAbstract for xml.dom Element Nodes"""
```

## Comparing `xhtml2pdf/w3c/cssParser.py` & `xhtml2pdf-0.2b1/xhtml2pdf/w3c/cssParser.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,26 +1,23 @@
 #!/usr/bin/env python
 
-# Copyright (C) 2002-2004 TechGame Networks, LLC.
-#
-# This library is free software; you can redistribute it and/or
-# modify it under the terms of the BSD style License as found in the
-# LICENSE file included with this distribution.
-#
-# Modified by Dirk Holtwick <holtwick@web.de>, 2007-2008
-
-from reportlab.lib.pagesizes import landscape
-
-import xhtml2pdf.default
-from xhtml2pdf.util import getSize
-
-try:
-    from future_builtins import filter
-except ImportError:
-    pass
+##~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+##~ Copyright (C) 2002-2004  TechGame Networks, LLC.
+##~
+##~ This library is free software; you can redistribute it and/or
+##~ modify it under the terms of the BSD style License as found in the
+##~ LICENSE file included with this distribution.
+##
+##  Modified by Dirk Holtwick <holtwick@web.de>, 2007-2008
+##~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+from __future__ import absolute_import
+
+
+# Added by benjaoming to fix python3 tests
+from __future__ import unicode_literals
 
 """CSS-2.1 parser.
 
 The CSS 2.1 Specification this parser was derived from can be found at http://www.w3.org/TR/CSS21/
 
 Primary Classes:
     * CSSParser
@@ -34,14 +31,16 @@
 
 Dependencies:
     python 2.3 (or greater)
     re
 """
 
 import re
+import six
+
 from . import cssSpecial
 
 
 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 #~ Definitions
 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
@@ -249,16 +248,14 @@
                 self.ctxsrc[self.srcCtxIdx:self.srcCtxIdx + 20]) + ')'
         else:
             return Exception.__str__(self) + ':: ' + repr(self.src[:40])
 
 
     def setFullCSSSource(self, fullsrc, inline=False):
         self.fullsrc = fullsrc
-        if type(self.fullsrc) == bytes:
-            self.fullsrc = str(self.fullsrc, 'utf-8')
         if inline:
             self.inline = inline
         if self.fullsrc:
             self.srcFullIdx = self.fullsrc.find(self.src)
             if self.srcFullIdx < 0:
                 del self.srcFullIdx
             self.ctxsrcFullIdx = self.fullsrc.find(self.ctxsrc)
@@ -323,115 +320,118 @@
     ParseError = CSSParseError
 
     AttributeOperators = ['=', '~=', '|=', '&=', '^=', '!=', '<>']
     SelectorQualifiers = ('#', '.', '[', ':')
     SelectorCombiners = ['+', '>']
     ExpressionOperators = ('/', '+', ',')
 
-    # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-    # ~ Regular expressions
-    # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+    #~ Regular expressions
+    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
-    if True:  # makes the following code foldable
+    if True: # makes the following code foldable
         _orRule = lambda *args: '|'.join(args)
         _reflags = re.I | re.M | re.U
         i_hex = '[0-9a-fA-F]'
         i_nonascii = '[\200-\377]'
-        i_unicode = r'\\(?:%s){1,6}\s?' % i_hex
-        i_escape = _orRule(i_unicode, r'\\[ -~\200-\377]')
+        i_unicode = '\\\\(?:%s){1,6}\s?' % i_hex
+        i_escape = _orRule(i_unicode, '\\\\[ -~\200-\377]')
         # i_nmstart = _orRule('[A-Za-z_]', i_nonascii, i_escape)
-        i_nmstart = _orRule(r'\-[^0-9]|[A-Za-z_]', i_nonascii,
-                            i_escape)  # XXX Added hyphen, http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
+        i_nmstart = _orRule('\-[^0-9]|[A-Za-z_]', i_nonascii,
+                            i_escape) # XXX Added hyphen, http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
         i_nmchar = _orRule('[-0-9A-Za-z_]', i_nonascii, i_escape)
         i_ident = '((?:%s)(?:%s)*)' % (i_nmstart, i_nmchar)
         re_ident = re.compile(i_ident, _reflags)
         # Caution: treats all characters above 0x7f as legal for an identifier.
         i_unicodeid = r'([^\u0000-\u007f]+)'
         re_unicodeid = re.compile(i_unicodeid, _reflags)
         i_unicodestr1 = r'(\'[^\u0000-\u007f]+\')'
         i_unicodestr2 = r'(\"[^\u0000-\u007f]+\")'
         i_unicodestr = _orRule(i_unicodestr1, i_unicodestr2)
         re_unicodestr = re.compile(i_unicodestr, _reflags)
-        i_element_name = r'((?:%s)|\*)' % (i_ident[1:-1],)
+        i_element_name = '((?:%s)|\*)' % (i_ident[1:-1],)
         re_element_name = re.compile(i_element_name, _reflags)
-        i_namespace_selector = r'((?:%s)|\*|)\|(?!=)' % (i_ident[1:-1],)
+        i_namespace_selector = '((?:%s)|\*|)\|(?!=)' % (i_ident[1:-1],)
         re_namespace_selector = re.compile(i_namespace_selector, _reflags)
-        i_class = r'\.' + i_ident
+        i_class = '\\.' + i_ident
         re_class = re.compile(i_class, _reflags)
         i_hash = '#((?:%s)+)' % i_nmchar
         re_hash = re.compile(i_hash, _reflags)
-        i_rgbcolor = '(#%s{8}|#%s{6}|#%s{3})' % (i_hex, i_hex, i_hex)
+        i_rgbcolor = '(#%s{6}|#%s{3})' % (i_hex, i_hex)
         re_rgbcolor = re.compile(i_rgbcolor, _reflags)
         i_nl = '\n|\r\n|\r|\f'
-        i_escape_nl = r'\\(?:%s)' % i_nl
+        i_escape_nl = '\\\\(?:%s)' % i_nl
         i_string_content = _orRule('[\t !#$%&(-~]', i_escape_nl, i_nonascii, i_escape)
         i_string1 = '\"((?:%s|\')*)\"' % i_string_content
         i_string2 = '\'((?:%s|\")*)\'' % i_string_content
         i_string = _orRule(i_string1, i_string2)
         re_string = re.compile(i_string, _reflags)
-        i_uri = (r'url\(\s*(?:(?:%s)|((?:%s)+))\s*\)'
+        i_uri = ('url\\(\s*(?:(?:%s)|((?:%s)+))\s*\\)'
                  % (i_string, _orRule('[!#$%&*-~]', i_nonascii, i_escape)))
         # XXX For now
         # i_uri = '(url\\(.*?\\))'
         re_uri = re.compile(i_uri, _reflags)
-        i_num = r'(([-+]?[0-9]+(?:\.[0-9]+)?)|([-+]?\.[0-9]+))'  # XXX Added out paranthesis, because e.g. .5em was not parsed correctly
+        i_num = '(([-+]?[0-9]+(?:\\.[0-9]+)?)|([-+]?\\.[0-9]+))' # XXX Added out paranthesis, because e.g. .5em was not parsed correctly
         re_num = re.compile(i_num, _reflags)
         i_unit = '(%%|%s)?' % i_ident
         re_unit = re.compile(i_unit, _reflags)
-        i_function = i_ident + r'\('
+        i_function = i_ident + '\\('
         re_function = re.compile(i_function, _reflags)
         i_functionterm = '[-+]?' + i_function
         re_functionterm = re.compile(i_functionterm, _reflags)
-        i_unicoderange1 = r"(?:U\+%s{1,6}-%s{1,6})" % (i_hex, i_hex)
-        i_unicoderange2 = r"(?:U\+\?{1,6}|{h}(\?{0,5}|{h}(\?{0,4}|{h}(\?{0,3}|{h}(\?{0,2}|{h}(\??|{h}))))))"
+        i_unicoderange1 = "(?:U\\+%s{1,6}-%s{1,6})" % (i_hex, i_hex)
+        i_unicoderange2 = "(?:U\\+\?{1,6}|{h}(\?{0,5}|{h}(\?{0,4}|{h}(\?{0,3}|{h}(\?{0,2}|{h}(\??|{h}))))))"
         i_unicoderange = i_unicoderange1 # '(%s|%s)' % (i_unicoderange1, i_unicoderange2)
         re_unicoderange = re.compile(i_unicoderange, _reflags)
 
         # i_comment = '(?:\/\*[^*]*\*+([^/*][^*]*\*+)*\/)|(?://.*)'
         # gabriel: only C convention for comments is allowed in CSS
-        i_comment = r'(?:\/\*[^*]*\*+([^/*][^*]*\*+)*\/)'
+        i_comment = '(?:\/\*[^*]*\*+([^/*][^*]*\*+)*\/)'
         re_comment = re.compile(i_comment, _reflags)
-        i_important = r'!\s*(important)'
+        i_important = '!\s*(important)'
         re_important = re.compile(i_important, _reflags)
         del _orRule
 
-    # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-    # ~ Public
-    # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+    #~ Public
+    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
     def __init__(self, cssBuilder=None):
         self.setCSSBuilder(cssBuilder)
 
 
-    # ~ CSS Builder to delegate to ~~~~~~~~~~~~~~~~~~~~~~~~
+    #~ CSS Builder to delegate to ~~~~~~~~~~~~~~~~~~~~~~~~
 
     def getCSSBuilder(self):
         """A concrete instance implementing CSSBuilderAbstract"""
         return self._cssBuilder
 
 
     def setCSSBuilder(self, cssBuilder):
         """A concrete instance implementing CSSBuilderAbstract"""
         self._cssBuilder = cssBuilder
 
 
     cssBuilder = property(getCSSBuilder, setCSSBuilder)
 
-    # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-    # ~ Public CSS Parsing API
-    # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+    #~ Public CSS Parsing API
+    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
-    def parseFile(self, srcFile):
+    def parseFile(self, srcFile, closeFile=False):
         """Parses CSS file-like objects using the current cssBuilder.
         Use for external stylesheets."""
 
-        with open(srcFile, "r") as file_handler:
-            file_content = file_handler.read()
+        try:
+            result = self.parse(srcFile.read())
+        finally:
+            if closeFile:
+                srcFile.close()
+        return result
 
-        return self.parse(file_content)
 
     def parse(self, src):
         """Parses CSS string source using the current cssBuilder.
         Use for embedded stylesheets."""
 
         self.cssBuilder.beginStylesheet()
         try:
@@ -476,17 +476,17 @@
         if attributes:
             kwAttributes.update(attributes)
 
         self.cssBuilder.beginInline()
         try:
             properties = []
             try:
-                for propertyName, src in kwAttributes.items():
-                    src, single_property = self._parseDeclarationProperty(src.strip(), propertyName)
-                    properties.append(single_property)
+                for propertyName, src in six.iteritems(kwAttributes):
+                    src, property = self._parseDeclarationProperty(src.strip(), propertyName)
+                    properties.append(property)
 
             except self.ParseError as err:
                 err.setFullCSSSource(src, inline=True)
                 raise
 
             result = self.cssBuilder.inline(properties)
         finally:
@@ -504,28 +504,25 @@
         results = self.parseAttributes(temp=attrValue)
         if 'temp' in results[1]:
             return results[1]['temp']
         else:
             return results[0]['temp']
 
 
-    # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-    # ~ Internal _parse methods
-    # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+    #~ Internal _parse methods
+    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
     def _parseStylesheet(self, src):
         """stylesheet
         : [ CHARSET_SYM S* STRING S* ';' ]?
             [S|CDO|CDC]* [ import [S|CDO|CDC]* ]*
             [ [ ruleset | media | page | font_face ] [S|CDO|CDC]* ]*
         ;
         """
-        # FIXME: BYTES to STR 
-        if type(src) == bytes:
-            src=src.decode()
         # Get rid of the comments
         src = self.re_comment.sub('', src)
 
         # [ CHARSET_SYM S* STRING S* ';' ]?
         src = self._parseAtCharset(src)
 
         # [S|CDO|CDC]*
@@ -566,15 +563,15 @@
             elif src.startswith('-->'):
                 src = src[3:]
             else:
                 break
         return src
 
 
-    # ~ CSS @ directives ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+    #~ CSS @ directives ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
     def _parseAtCharset(self, src):
         """[ CHARSET_SYM S* STRING S* ';' ]?"""
         if isAtRuleIdent(src, 'charset'):
             src = stripAtRuleIdent(src)
             charset, src = self._getString(src)
             src = src.lstrip()
@@ -683,38 +680,35 @@
         ;
         """
         ctxsrc = src
         src = src[len('@media '):].lstrip()
         mediums = []
         while src and src[0] != '{':
             medium, src = self._getIdent(src)
+            if medium is None:
+                raise self.ParseError('@media rule expected media identifier', src, ctxsrc)
             # make "and ... {" work
-            if medium in (None, 'and'):
-                # default to mediatype "all"
-                if medium is None:
-                    mediums.append('all')
+            if medium == 'and':
                 # strip up to curly bracket
-                pattern = re.compile('.*?[{]', re.DOTALL)
-
-
+                pattern = re.compile('.*({.*)')
                 match = re.match(pattern, src)
                 src = src[match.end()-1:]
                 break
             mediums.append(medium)
             if src[0] == ',':
                 src = src[1:].lstrip()
             else:
                 src = src.lstrip()
 
         if not src.startswith('{'):
             raise self.ParseError('Ruleset opening \'{\' not found', src, ctxsrc)
         src = src[1:].lstrip()
 
         stylesheetElements = []
-        # while src and not src.startswith('}'):
+        #while src and not src.startswith('}'):
         #    src, ruleset = self._parseRuleset(src)
         #    stylesheetElements.append(ruleset)
         #    src = src.lstrip()
 
         # Containing @ where not found and parsed
         while src and not src.startswith('}'):
             if src.startswith('@'):
@@ -739,29 +733,24 @@
 
     def _parseAtPage(self, src):
         """page
         : PAGE_SYM S* IDENT? pseudo_page? S*
             '{' S* declaration [ ';' S* declaration ]* '}' S*
         ;
         """
-
-        data = {}
-        pageBorder = None
-        isLandscape = False
-
         ctxsrc = src
         src = src[len('@page'):].lstrip()
         page, src = self._getIdent(src)
         if src[:1] == ':':
             pseudopage, src = self._getIdent(src[1:])
             page = page + '_' + pseudopage
         else:
             pseudopage = None
 
-        # src, properties = self._parseDeclarationGroup(src.lstrip())
+        #src, properties = self._parseDeclarationGroup(src.lstrip())
 
         # Containing @ where not found and parsed
         stylesheetElements = []
         src = src.lstrip()
         properties = []
 
         # XXX Extended for PDF use
@@ -775,59 +764,17 @@
                 # @media, @page, @font-face
                 src, atResults = self._parseAtKeyword(src)
                 if atResults is not None:
                     stylesheetElements.extend(atResults)
             else:
                 src, nproperties = self._parseDeclarationGroup(src.lstrip(), braces=False)
                 properties += nproperties
-
-                # Set pagesize, orientation (landscape, portrait)
-                data = {}
-                pageBorder = None
-
-                if properties:
-                    result = self.cssBuilder.ruleset([self.cssBuilder.selector('*')], properties)
-                    try:
-                        data = result[0].values()[0]
-                    except Exception:
-                        data = result[0].popitem()[1]
-                    pageBorder = data.get("-pdf-frame-border", None)
-
-                if "-pdf-page-size" in data:
-                    self.c.pageSize = xhtml2pdf.default.PML_PAGESIZES.get(
-                        str(data["-pdf-page-size"]).lower(), self.c.pageSize)
-
-                isLandscape = False
-                if "size" in data:
-                    size = data["size"]
-                    if not isinstance(size, list):
-                        size = [size]
-                    sizeList = []
-                    for value in size:
-                        valueStr = str(value).lower()
-                        if isinstance(value, tuple):
-                            sizeList.append(getSize(value))
-                        elif valueStr == "landscape":
-                            isLandscape = True
-                        elif valueStr == "portrait":
-                            isLandscape = False
-                        elif valueStr in xhtml2pdf.default.PML_PAGESIZES:
-                            self.c.pageSize = xhtml2pdf.default.PML_PAGESIZES[valueStr]
-                        else:
-                            raise RuntimeError("Unknown size value for @page")
-
-                    if len(sizeList) == 2:
-                        self.c.pageSize = tuple(sizeList)
-
-                    if isLandscape:
-                        self.c.pageSize = landscape(self.c.pageSize)
-
             src = src.lstrip()
 
-        result = [self.cssBuilder.atPage(page, pseudopage, data, isLandscape, pageBorder)]
+        result = [self.cssBuilder.atPage(page, pseudopage, properties)]
 
         return src[1:].lstrip(), result
 
 
     def _parseAtFrame(self, src):
         """
         XXX Proprietary for PDF
@@ -836,31 +783,30 @@
         box, src = self._getIdent(src)
         src, properties = self._parseDeclarationGroup(src.lstrip())
         result = [self.cssBuilder.atFrame(box, properties)]
         return src.lstrip(), result
 
 
     def _parseAtFontFace(self, src):
-        src = src[len('@font-face'):].lstrip()
+        src = src[len('@font-face '):].lstrip()
         src, properties = self._parseDeclarationGroup(src)
         result = [self.cssBuilder.atFontFace(properties)]
         return src, result
 
 
     def _parseAtIdent(self, src):
         ctxsrc = src
         atIdent, src = self._getIdent(src[1:])
         if atIdent is None:
             raise self.ParseError('At-rule expected an identifier for the rule', src, ctxsrc)
 
         src, result = self.cssBuilder.atIdent(atIdent, self, src)
 
         if result is NotImplemented:
-            # An at-rule consists of everything up to and including the next semicolon (;)
-            # or the next block, whichever comes first
+            # An at-rule consists of everything up to and including the next semicolon (;) or the next block, whichever comes first
 
             semiIdx = src.find(';')
             if semiIdx < 0:
                 semiIdx = None
             blockIdx = src[:semiIdx].find('{')
             if blockIdx < 0:
                 blockIdx = None
@@ -881,29 +827,29 @@
                     src, stylesheet = self._parseStylesheet(src)
             else:
                 raise self.ParserError('Unable to ignore @-rule block', src, ctxsrc)
 
         return src.lstrip(), result
 
 
-    # ~ ruleset - see selector and declaration groups ~~~~
+    #~ ruleset - see selector and declaration groups ~~~~
 
     def _parseRuleset(self, src):
         """ruleset
         : selector [ ',' S* selector ]*
             '{' S* declaration [ ';' S* declaration ]* '}' S*
         ;
         """
         src, selectors = self._parseSelectorGroup(src)
         src, properties = self._parseDeclarationGroup(src.lstrip())
         result = self.cssBuilder.ruleset(selectors, properties)
         return src, result
 
 
-    # ~ selector parsing ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+    #~ selector parsing ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
     def _parseSelectorGroup(self, src):
         selectors = []
         while src[:1] not in ('{', '}', ']', '(', ')', ';', ''):
             src, selector = self._parseSelector(src)
             if selector is None:
                 break
@@ -1052,37 +998,37 @@
             selector.addPseudoFunction(name, term)
         else:
             selector.addPseudo(name)
 
         return src, selector
 
 
-    # ~ declaration and expression parsing ~~~~~~~~~~~~~~~
+    #~ declaration and expression parsing ~~~~~~~~~~~~~~~
 
     def _parseDeclarationGroup(self, src, braces=True):
         ctxsrc = src
         if src.startswith('{'):
             src, braces = src[1:], True
         elif braces:
             raise self.ParseError('Declaration group opening \'{\' not found', src, ctxsrc)
 
         properties = []
         src = src.lstrip()
         while src[:1] not in ('', ',', '{', '}', '[', ']', '(', ')', '@'): # XXX @?
-            src, single_property = self._parseDeclaration(src)
+            src, property = self._parseDeclaration(src)
 
             # XXX Workaround for styles like "*font: smaller"
             if src.startswith("*"):
                 src = "-nothing-" + src[1:]
                 continue
 
-            if single_property is None:
+            if property is None:
                 src = src[1:].lstrip()
                 break
-            properties.append(single_property)
+            properties.append(property)
             if src.startswith(';'):
                 src = src[1:].lstrip()
             else:
                 break
 
         if braces:
             if not src.startswith('}'):
@@ -1106,31 +1052,31 @@
             # S* : S*
             if src[:1] in (':', '='):
                 # Note: we are being fairly flexable here...  technically, the
                 # ":" is *required*, but in the name of flexibility we
                 # suppor a null transition, as well as an "=" transition
                 src = src[1:].lstrip()
 
-            src, single_property = self._parseDeclarationProperty(src, propertyName)
+            src, property = self._parseDeclarationProperty(src, propertyName)
         else:
-            single_property = None
+            property = None
 
-        return src, single_property
+        return src, property
 
 
     def _parseDeclarationProperty(self, src, propertyName):
         # expr
         src, expr = self._parseExpression(src)
 
         # prio?
         important, src = self._getMatchResult(self.re_important, src)
         src = src.lstrip()
 
-        single_property = self.cssBuilder.property(propertyName, expr, important)
-        return src, single_property
+        property = self.cssBuilder.property(propertyName, expr, important)
+        return src, property
 
 
     def _parseExpression(self, src, returnList=False):
         """
         expr
         : term [ operator term ]*
         ;
@@ -1220,26 +1166,26 @@
         if result is not None:
             term = self.cssBuilder.termString(result)
             return src.lstrip(), term
 
         return self.cssBuilder.termUnknown(src)
 
 
-    # ~ utility methods ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+    #~ utility methods ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
     def _getIdent(self, src, default=None):
         return self._getMatchResult(self.re_ident, src, default)
 
 
     def _getString(self, src, rexpression=None, default=None):
         if rexpression is None:
             rexpression = self.re_string
         result = rexpression.match(src)
         if result:
-            strres = tuple(filter(None, result.groups()))
+            strres = filter(None, result.groups())
             if strres:
                 try:
                     strres = strres[0]
                 except Exception:
                     strres = result.groups()[0]
             else:
                 strres = ''
```

## Comparing `xhtml2pdf/w3c/cssSpecial.py` & `xhtml2pdf-0.2b1/xhtml2pdf/w3c/cssSpecial.py`

 * *Files 3% similar despite different names*

```diff
@@ -9,16 +9,28 @@
 #     http://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software
 # distributed under the License is distributed on an "AS IS" BASIS,
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
 # limitations under the License.
+# Copyright 2010 Dirk Holtwick, holtwick.it
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
 
-import logging
 
 __reversion__ = "$Revision: 20 $"
 __author__ = "$Author: holtwick $"
 __date__ = "$Date: 2007-10-09 12:58:24 +0200 (Di, 09 Okt 2007) $"
 
 """
 Helper for complex CSS definitons like font, margin, padding and border
@@ -26,14 +38,17 @@
 """
 
 #support python 3
 #import types
 TupleType = tuple
 ListType = list
 
+import logging
+
+
 log = logging.getLogger("ho.css")
 
 
 def toList(value):
     if type(value) != ListType:
         return [value]
     return value
@@ -154,15 +169,15 @@
 
     http://www.w3.org/TR/CSS21/box.html#border-shorthand-properties
     """
 
     width = style = color = None
 
     if len(parts) > 3:
-        log.warning("To many elements for border style %r", parts)
+        log.warn("To many elements for border style %r", parts)
 
     for part in parts:
         # Width
         if isSize(part):
             width = part
 
         # Style
@@ -223,34 +238,31 @@
         elif name == "background":
             # [<'background-color'> || <'background-image'> || <'background-repeat'> || <'background-attachment'> || <'background-position'>] | inherit
 
             # XXX We do not receive url() and parts list, so we go for a dirty work arround
             part = getNextPart(parts) or oparts
             if part:
 
-                if isinstance(part, str) and (("." in part) or ("data:" in part)):
+                if hasattr(part, '__iter__') and (type("." in part) or ("data:" in part)):
                     dd.append(("background-image", part, last))
                 else:
                     dd.append(("background-color", part, last))
 
             if 0:
                 part = getNextPart(parts) or oparts
-                print("~", part, parts, oparts, declarations)
+                print ("~", part, parts, oparts, declarations)
                 # Color
                 if part and (not part.startswith("url")):
                     dd.append(("background-color", part, last))
                     part = getNextPart(parts)
                     # Background
                 if part:
                     dd.append(("background-image", part, last))
                     # XXX Incomplete! Error in url()!
 
-# TODO: We should definitely outsource the "if len() ==" part into a separate function!
-# Because we're repeating the same if-elif-else statement for MARGIN, PADDING,
-# BORDER-WIDTH, BORDER-COLOR and BORDER-STYLE. That's pretty messy. (fbernhart)
         # MARGIN
         elif name == "margin":
             if len(parts) == 1:
                 top = bottom = left = right = parts[0]
             elif len(parts) == 2:
                 top = bottom = parts[0]
                 left = right = parts[1]
```

## Comparing `xhtml2pdf-0.2.9.dist-info/LICENSE.txt` & `xhtml2pdf-0.2b1/LICENSE.txt`

 * *Files identical despite different names*

## Comparing `xhtml2pdf-0.2.9.dist-info/METADATA` & `xhtml2pdf-0.2b1/PKG-INFO`

 * *Files 23% similar despite different names*

```diff
@@ -1,229 +1,241 @@
-Metadata-Version: 2.1
+Metadata-Version: 1.1
 Name: xhtml2pdf
-Version: 0.2.9
+Version: 0.2b1
 Summary: PDF generator using HTML and CSS
 Home-page: http://github.com/xhtml2pdf/xhtml2pdf
-Author: Dirk Holtwick
-Maintainer: Luis Zarate
-Maintainer-email: luisza14@gmail.com
+Author: Sam Spencer
+Author-email: use-github@doit.com
 License: Apache License 2.0
+Description: *********
+        XHTML2PDF
+        *********
+        
+        
+        .. image:: https://travis-ci.org/xhtml2pdf/xhtml2pdf.svg
+            :target: https://travis-ci.org/xhtml2pdf/xhtml2pdf
+        
+        .. image:: https://ci.appveyor.com/api/projects/status/y2mj843lpptwars9/branch/master?svg=true
+            :target: https://ci.appveyor.com/project/LegoStormtroopr/xhtml2pdf/branch/master
+        
+        .. image:: https://coveralls.io/repos/xhtml2pdf/xhtml2pdf/badge.svg?branch=develop&service=github
+                :target: https://coveralls.io/github/xhtml2pdf/xhtml2pdf?branch=develop
+                :alt: Coveralls
+        
+        .. image:: https://badge.fury.io/py/xhtml2pdf.svg
+           :target: https://pypi.python.org/pypi/xhtml2pdf
+        
+        .. image:: https://readthedocs.org/projects/xhtml2pdf/badge/?version=latest
+           :target: http://xhtml2pdf.readthedocs.io/en/latest/?badge=latest
+           :alt: Documentation Status
+        
+        The current release of xhtml2pdf is xhtml2pdf **0.2b1** which is a beta that has
+        Python 3 support. As with all open-source software, its use in production depends
+        on many factors, so be aware that you may find issues in some cases.
+        **Big thanks** to everyone
+        who has worked on this project so far and to those who help maintain it.
+        
+        --------------------------------------------------------------------------------
+        
+        What else can you use instead?
+        ==============================
+        
+        Go use WeasyPrint, the codebase is pretty, it has a different features, and it
+        does a lot of what xhtml2pdf does and it is easier to use in many circumstances.
+        
+        `WeasyPrint <http://weasyprint.org/>`__
+        
+        
+        Documentation?
+        ==============
+        
+        xhtml2pdf has some documentation, and we could use your help improving it.
+        A good place to start is ``doc/usage.rst``.
+        
+        
+        --------------------------------------------------------------------------------
+        --------------------------------------------------------------------------------
+        
+        
+        This project is community-led! To strengthen it, please hang out on IRC #xhtml2pdf (Freenode)
+        or join `our maling list <http://groups.google.com/group/xhtml2pdf>`__.
+        
+        
+        Call for testing
+        ================
+        
+        This project is heavily dependent on getting its test coverage up!
+        Currently, Python 3 support is being worked on and many refactors and suggestions are potentially coming in.
+        Furthermore, parts of the codebase could do well with cleanups and refactoring.
+        
+        If you benefit from xhtml2pdf, perhaps `look at the test coverage <https://coveralls.io/github/xhtml2pdf/xhtml2pdf?branch=master>`__ and identify parts that are yet untouched.
+        
+        
+        About
+        =====
+        
+        ``xhtml2pdf`` is a html2pdf converter using the ReportLab Toolkit,
+        the HTML5lib and pyPdf. It supports HTML 5 and CSS 2.1 (and some of CSS 3).
+        It is completely written in pure Python so it is platform independent.
+        
+        The main benefit of this tool that a user with Web skills like HTML and CSS
+        is able to generate PDF templates very quickly without learning new
+        technologies.
+        
+        
+        Installation
+        ============
+        
+        This is a typical Python library and is installed using pip::
+        
+            pip install xhtml2pdf
+        
+        To obtain the latest experimental version that has **Python 3 support**, please
+        use a prerelease::
+        
+            pip install --pre xhtml2pdf
+        
+        
+        
+        Requirements
+        ============
+        
+        Python 2.7+. Only Python 3.4+ is tested and guaranteed to work.
+        
+        All additional requirements are listed in ``requirements.txt`` file and are
+        installed automatically using the ``pip install xhtml2pdf`` method.
+        
+        
+        Development environment
+        =======================
+        
+        #. If you don't have it, install ``pip``, the python package installer::
+        
+            sudo easy_install pip
+        
+           For more information about ``pip`` refer to http://www.pip-installer.org/.
+        
+        #. I will recommend using ``virtualenv`` for development. This is great to have separate environment for
+           each project, keeping the dependencies for multiple projects separated::
+        
+            sudo pip install virtualenv
+        
+           For more information about ``virtualenv`` refer to http://www.virtualenv.org/
+        
+        #. Create virtualenv for the project. This can be inside the project directory, but cannot be under
+           version control::
+        
+            virtualenv --distribute xhtml2pdfenv --python=python2
+        
+        #. Activate your virtualenv::
+        
+            source xhtml2pdfenv/bin/activate
+        
+           Later to deactivate use::
+        
+            deactivate
+        
+        #. Next step will be to install/upgrade dependencies from ``requirements.txt`` file::
+        
+            pip install -r requirements.txt
+        
+        #. Run tests to check your configuration::
+        
+            nosetests --with-coverage
+        
+           You should have a log with success status::
+        
+            Ran 36 tests in 0.322s
+        
+            OK
+        
+        
+        Python integration
+        ==================
+        
+        Some simple demos of how to integrate xhtml2pdf into
+        a Python program may be found here: test/simple.py
+        
+        
+        Running tests
+        =============
+        
+        Two different test suites are available to assert xhtml2pdf works reliably:
+        
+        #. Unit tests. The unit testing framework is currently minimal, but is being
+           improved on a daily basis (contributions welcome). They should run in the
+           expected way for Python's unittest module, i.e.::
+        
+                nosetests --with-coverage (or your personal favorite)
+        
+        #. Functional tests. Thanks to mawe42's super cool work, a full functional
+           test suite lives in testrender/.
+        
+        
+        Contact
+        =======
+        
+        * IRC: #xhtml2pdf on freenode
+        * Mailing list: xhtml2pdf@googlegroups.com
+        * Google group: http://groups.google.com/group/xhtml2pdf
+        
+        
+        History
+        =======
+        
+        This are the major milestones and the maintainers of the project:
+        
+        * 2000-2007, commercial project, spirito.de, written by Dirk Holtwich
+        * 2007-2010 Dirk Holtwich (project named "Pisa", project released as GPL)
+        * 2010-2012 Dirk Holtwick (project named "xhtml2pdf", changed license to Apache)
+        * 2012-2015 Chris Glass (@chrisglass)
+        * 2015-2016 Benjamin Bach (@benjaoming)
+        * 2016-Current Sam Spencer (@LegoStormtroopr)
+        
+        For more history, see the CHANGELOG.
+        
+        License
+        =======
+        
+        Copyright 2010 Dirk Holtwick, holtwick.it
+        
+        Licensed under the Apache License, Version 2.0 (the "License");
+        you may not use this file except in compliance with the License.
+        You may obtain a copy of the License at
+        
+            http://www.apache.org/licenses/LICENSE-2.0
+        
+        Unless required by applicable law or agreed to in writing, software
+        distributed under the License is distributed on an "AS IS" BASIS,
+        WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+        See the License for the specific language governing permissions and
+        limitations under the License.
+        
 Keywords: PDF,HTML,XHTML,XML,CSS
 Platform: UNKNOWN
 Classifier: License :: OSI Approved :: Apache Software License
 Classifier: Development Status :: 4 - Beta
 Classifier: Environment :: Console
 Classifier: Environment :: Other Environment
 Classifier: Intended Audience :: Developers
 Classifier: Intended Audience :: System Administrators
 Classifier: Natural Language :: English
 Classifier: Operating System :: OS Independent
+Classifier: Programming Language :: Python :: 2
+Classifier: Programming Language :: Python :: 2.7
 Classifier: Programming Language :: Python :: 3
-Classifier: Programming Language :: Python :: 3.6
-Classifier: Programming Language :: Python :: 3.7
-Classifier: Programming Language :: Python :: 3.8
-Classifier: Programming Language :: Python :: 3.9
-Classifier: Programming Language :: Python :: 3.10
+Classifier: Programming Language :: Python :: 3.3
+Classifier: Programming Language :: Python :: 3.4
+Classifier: Programming Language :: Python :: 3.5
 Classifier: Topic :: Documentation
 Classifier: Topic :: Multimedia
 Classifier: Topic :: Office/Business
 Classifier: Topic :: Printing
 Classifier: Topic :: Text Processing
 Classifier: Topic :: Text Processing :: Filters
 Classifier: Topic :: Text Processing :: Fonts
 Classifier: Topic :: Text Processing :: General
 Classifier: Topic :: Text Processing :: Indexing
 Classifier: Topic :: Text Processing :: Markup
 Classifier: Topic :: Text Processing :: Markup :: HTML
 Classifier: Topic :: Text Processing :: Markup :: XML
 Classifier: Topic :: Utilities
-License-File: LICENSE.txt
-License-File: AUTHORS.rst
-Requires-Dist: html5lib (>=1.0.1)
-Requires-Dist: pypdf (>=3.0.0)
-Requires-Dist: Pillow (>=8.1.1)
-Requires-Dist: reportlab (>=3.5.53)
-Requires-Dist: svglib (>=1.2.1)
-Requires-Dist: python-bidi (>=0.4.2)
-Requires-Dist: arabic-reshaper (>=3.0.0)
-Requires-Dist: pyHanko (>=0.12.1)
-Requires-Dist: pypdf (>=3.1.0)
-Requires-Dist: pyhanko-certvalidator (>=0.19.5)
-
-XHTML2PDF
-=========
-
-.. image:: https://img.shields.io/pypi/v/xhtml2pdf?label=PyPI&logo=PyPI&logoColor=white&color=blue
-    :target: https://pypi.python.org/pypi/xhtml2pdf
-    :alt: PyPI version
-
-.. image:: https://img.shields.io/pypi/pyversions/xhtml2pdf?label=Python&logo=Python&logoColor=white
-    :target: https://www.python.org/downloads
-    :alt: Python versions
-
-.. image:: https://img.shields.io/coveralls/github/xhtml2pdf/xhtml2pdf?label=Coveralls&logo=Coveralls&logoColor=white
-    :target: https://coveralls.io/github/xhtml2pdf/xhtml2pdf
-    :alt: Coveralls
-
-.. image:: https://img.shields.io/readthedocs/xhtml2pdf?label=Read%20the%20Docs&logo=read%20the%20docs&logoColor=white
-   :target: http://xhtml2pdf.readthedocs.io/en/latest/?badge=latest
-   :alt: Read the Docs
-
-|
-
-The current release of xhtml2pdf is **xhtml2pdf 0.2.7**. Release Notes can be found here: `Release Notes <https://xhtml2pdf.readthedocs.io/en/latest/release-notes.html>`__
-As with all open-source software, its use in production depends on many factors, so be aware that you may find issues in some cases.
-
-**Big thanks** to everyone who has worked on this project so far and to those who help maintain it.
-
-About
-=====
-
-xhtml2pdf is a HTML to PDF converter using Python, the ReportLab Toolkit, html5lib and pypdf. It supports HTML5 and CSS 2.1 (and some of CSS 3). It is completely written in pure Python, so it is platform independent.
-
-The main benefit of this tool is that a user with web skills like HTML and CSS is able to generate PDF templates very quickly without learning new technologies.
-
-Please consider support this project using `Patreon <https://www.patreon.com/xhtml2pdf>`__ or Bitcoins: ``bc1qmr0skzwx5scyvh2ql28f7gfh6l65ua250qv227``
-
-
-
-Documentation
-==============
-
-The documentation of xhtml2pdf is available at `Read the Docs <http://xhtml2pdf.readthedocs.io>`__.
-
-And we could use your help improving it! A good place to start is ``doc/source/usage.rst``.
-
-
-Installation
-============
-
-This is a typical Python library and can be installed using pip::
-
-    pip install xhtml2pdf
-
-
-Requirements
-============
-
-Only Python 3.7+ is tested and guaranteed to work.
-
-All additional requirements are listed in the ``requirements.txt`` file and are installed automatically using the ``pip install xhtml2pdf`` method.
-
-
-Alternatives
-==============================
-
-You can try `WeasyPrint <http://weasyprint.org>`__. The codebase is pretty, it has different features and it does a lot of what xhtml2pdf does.
-
-
-Call for testing
-================
-
-This project is heavily dependent on getting its test coverage up! Furthermore, parts of the codebase could do well with cleanups and refactoring.
-
-If you benefit from xhtml2pdf, perhaps look at the `test coverage <https://coveralls.io/github/xhtml2pdf/xhtml2pdf>`__ and identify parts that are yet untouched.
-
-
-Development environment
-=======================
-
-#. If you don't have it, install ``pip``, the python package installer::
-
-    sudo easy_install pip
-
-   For more information about ``pip`` refer to http://www.pip-installer.org
-
-#. We will recommend using ``virtualenv`` for development.
-
-#. Create a virtualenv for the project. This can be inside the project directory, but cannot be under version control::
-
-    python -m venv xhtml2pdfenv
-
-#. Activate your virtualenv::
-
-    source xhtml2pdfenv/bin/activate
-
-   Later to deactivate it use::
-
-    deactivate
-
-#. The next step will be to install/upgrade dependencies from the ``requirements.txt`` file::
-
-    pip install -r requirements.txt
-
-#. Run tests to check your configuration::
-
-    nosetests --with-coverage
-
-   You should have a log with the following success status::
-
-    Ran 167 tests in 34.585s
-
-    OK
-
-
-Python integration
-==================
-
-Some simple demos of how to integrate xhtml2pdf into a Python program may be found here: ``test/simple.py``
-
-
-Running tests
-=============
-
-Two different test suites are available to assert that xhtml2pdf works reliably:
-
-#. Unit tests. The unit testing framework is currently minimal, but is being
-   improved on a regular basis (contributions welcome). They should run in the
-   expected way for Python's unittest module, i.e.::
-
-        nosetests --with-coverage (or your personal favorite)
-
-#. Functional tests. Thanks to mawe42's super cool work, a full functional
-   test suite is available at ``testrender/``.
-
-You can run them using make
-
-.. code:: bash
-
-        make test       # run nosetest
-        make test-ref   # generate reference data for testrender
-        make test-all   # Run all test using tox
-
-Contact
-=======
-
-This project is community-led! Feel free to open up issues on GitHub about new ideas to improve xhtml2pdf.
-
-
-History
-=======
-
-These are the major milestones and the maintainers of the project:
-
-* 2000-2007, commercial project, spirito.de, written by Dirk Holtwich
-* 2007-2010 Dirk Holtwich (project named "Pisa", project released as GPL)
-* 2010-2012 Dirk Holtwick (project named "xhtml2pdf", changed license to Apache)
-* 2012-2015 Chris Glass (@chrisglass)
-* 2015-2016 Benjamin Bach (@benjaoming)
-* 2016-2018 Sam Spencer (@LegoStormtroopr)
-* 2018-Current Luis Zarate (@luisza) 
-
-For more history, see the ``CHANGELOG.txt`` file.
-
-License
-=======
-
-Copyright 2010 Dirk Holtwick, holtwick.it
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at: http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-
-
```

