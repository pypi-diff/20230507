# Comparing `tmp/blume-0.2.5.3-py3-none-any.whl.zip` & `tmp/blume-0.2.5.4-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,34 +1,34 @@
-Zip file size: 86485 bytes, number of entries: 47
+Zip file size: 86395 bytes, number of entries: 47
 -rw-rw-r--  2.0 unx       14 b- defN 21-Aug-16 21:17 blume/__init__.py
 -rw-rw-r--  2.0 unx     7656 b- defN 22-Jun-01 22:01 blume/blitting.py
 -rw-rw-r--  2.0 unx     3127 b- defN 21-Aug-16 21:17 blume/cod.py
 -rw-rw-r--  2.0 unx     2982 b- defN 23-Jan-12 18:54 blume/console.py
 -rw-rw-r--  2.0 unx    13610 b- defN 22-Jun-01 22:01 blume/cpr.py
 -rw-rw-r--  2.0 unx     7571 b- defN 22-Jun-01 22:01 blume/dataklasses.py
 -rw-rw-r--  2.0 unx      704 b- defN 22-Jul-13 10:53 blume/docs.py
 -rw-rw-r--  2.0 unx     3660 b- defN 22-Jun-01 22:01 blume/dss.py
 -rw-rw-r--  2.0 unx     2746 b- defN 22-Jun-21 20:31 blume/eggshow.py
--rw-rw-r--  2.0 unx    18465 b- defN 23-Jan-06 19:43 blume/farm.py
+-rw-rw-r--  2.0 unx     7423 b- defN 23-May-07 20:23 blume/farm.py
 -rw-rw-r--  2.0 unx    10886 b- defN 21-Aug-16 21:17 blume/gaia.py
 -rw-rw-r--  2.0 unx     2244 b- defN 22-Jul-13 10:53 blume/gw.py
 -rw-rw-r--  2.0 unx     8423 b- defN 22-Jul-13 10:53 blume/legend.py
--rw-rw-r--  2.0 unx    36755 b- defN 23-Jan-06 19:43 blume/magic.py
+-rw-rw-r--  2.0 unx    46619 b- defN 23-May-07 20:23 blume/magic.py
 -rw-rw-r--  2.0 unx     3823 b- defN 22-Jun-01 22:01 blume/magic2.py
--rw-rw-r--  2.0 unx     5140 b- defN 22-Jun-01 22:01 blume/mb.py
+-rw-rw-r--  2.0 unx     5112 b- defN 23-May-07 20:23 blume/mb.py
 -rw-rw-r--  2.0 unx     7429 b- defN 22-Jul-13 10:53 blume/mclock2.py
 -rw-rw-r--  2.0 unx     3669 b- defN 22-Jun-01 22:01 blume/metagit.py
 -rw-rw-r--  2.0 unx      611 b- defN 22-Jun-01 22:01 blume/modnar.py
 -rw-rw-r--  2.0 unx     4351 b- defN 22-Jun-01 22:01 blume/mosaic.py
 -rw-rw-r--  2.0 unx     1392 b- defN 21-Aug-16 21:17 blume/noligo.py
 -rw-rw-r--  2.0 unx     1427 b- defN 22-Jul-13 10:53 blume/rcparms.py
 -rw-rw-r--  2.0 unx    31302 b- defN 22-Dec-22 19:53 blume/table.py
 -rw-rw-r--  2.0 unx     4540 b- defN 22-Dec-22 19:53 blume/taybell.py
 -rw-rw-r--  2.0 unx     3427 b- defN 21-Aug-16 21:17 blume/teakhat.py
--rw-rw-r--  2.0 unx     3201 b- defN 22-Dec-22 19:53 blume/train.py
+-rw-rw-r--  2.0 unx     4028 b- defN 23-May-07 20:23 blume/train.py
 -rw-rw-r--  2.0 unx      321 b- defN 21-Aug-16 21:17 blume/twins.py
 -rw-rw-r--  2.0 unx        0 b- defN 21-Aug-16 21:17 blume/balls/__init__.py
 -rw-rw-r--  2.0 unx     3609 b- defN 21-Aug-16 21:17 blume/balls/sudoku.py
 -rw-rw-r--  2.0 unx        0 b- defN 22-Jun-01 22:01 blume/examples/__init__.py
 -rw-rw-r--  2.0 unx     1871 b- defN 21-Aug-16 21:17 blume/examples/chess_table.py
 -rw-rw-r--  2.0 unx    15192 b- defN 22-Jun-04 18:52 blume/examples/cod.py
 -rw-rw-r--  2.0 unx     3182 b- defN 21-Aug-16 21:17 blume/examples/cpr.py
@@ -36,14 +36,14 @@
 -rw-rw-r--  2.0 unx      875 b- defN 21-Aug-16 21:17 blume/examples/iyield.py
 -rw-rw-r--  2.0 unx     2780 b- defN 22-Jul-13 10:53 blume/examples/legendary.py
 -rw-rw-r--  2.0 unx     1208 b- defN 21-Aug-16 21:17 blume/examples/ligoview.py
 -rw-rw-r--  2.0 unx      555 b- defN 21-Aug-16 21:17 blume/examples/multiline.py
 -rw-rw-r--  2.0 unx      567 b- defN 21-Aug-16 21:17 blume/examples/shortify.py
 -rw-rw-r--  2.0 unx     1208 b- defN 21-Aug-16 21:17 blume/examples/show.py
 -rw-rw-r--  2.0 unx     1687 b- defN 21-Aug-16 21:17 blume/examples/table_demo.py
--rw-rw-r--  2.0 unx     4830 b- defN 23-Jan-12 18:54 blume-0.2.5.3.dist-info/LICENSE
--rw-rw-r--  2.0 unx     2665 b- defN 23-Jan-12 18:54 blume-0.2.5.3.dist-info/METADATA
--rw-rw-r--  2.0 unx       92 b- defN 23-Jan-12 18:54 blume-0.2.5.3.dist-info/WHEEL
--rw-rw-r--  2.0 unx       19 b- defN 23-Jan-12 18:54 blume-0.2.5.3.dist-info/dependency_links.txt
--rw-rw-r--  2.0 unx        6 b- defN 23-Jan-12 18:54 blume-0.2.5.3.dist-info/top_level.txt
-?rw-rw-r--  2.0 unx     3548 b- defN 23-Jan-12 18:54 blume-0.2.5.3.dist-info/RECORD
-47 files, 233866 bytes uncompressed, 81013 bytes compressed:  65.4%
+-rw-rw-r--  2.0 unx     4830 b- defN 23-May-07 20:25 blume-0.2.5.4.dist-info/LICENSE
+-rw-rw-r--  2.0 unx     2665 b- defN 23-May-07 20:25 blume-0.2.5.4.dist-info/METADATA
+-rw-rw-r--  2.0 unx       92 b- defN 23-May-07 20:25 blume-0.2.5.4.dist-info/WHEEL
+-rw-rw-r--  2.0 unx       19 b- defN 23-May-07 20:25 blume-0.2.5.4.dist-info/dependency_links.txt
+-rw-rw-r--  2.0 unx        6 b- defN 23-May-07 20:25 blume-0.2.5.4.dist-info/top_level.txt
+?rw-rw-r--  2.0 unx     3547 b- defN 23-May-07 20:25 blume-0.2.5.4.dist-info/RECORD
+47 files, 233486 bytes uncompressed, 80923 bytes compressed:  65.3%
```

## zipnote {}

```diff
@@ -117,26 +117,26 @@
 
 Filename: blume/examples/show.py
 Comment: 
 
 Filename: blume/examples/table_demo.py
 Comment: 
 
-Filename: blume-0.2.5.3.dist-info/LICENSE
+Filename: blume-0.2.5.4.dist-info/LICENSE
 Comment: 
 
-Filename: blume-0.2.5.3.dist-info/METADATA
+Filename: blume-0.2.5.4.dist-info/METADATA
 Comment: 
 
-Filename: blume-0.2.5.3.dist-info/WHEEL
+Filename: blume-0.2.5.4.dist-info/WHEEL
 Comment: 
 
-Filename: blume-0.2.5.3.dist-info/dependency_links.txt
+Filename: blume-0.2.5.4.dist-info/dependency_links.txt
 Comment: 
 
-Filename: blume-0.2.5.3.dist-info/top_level.txt
+Filename: blume-0.2.5.4.dist-info/top_level.txt
 Comment: 
 
-Filename: blume-0.2.5.3.dist-info/RECORD
+Filename: blume-0.2.5.4.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## blume/farm.py

```diff
@@ -35,14 +35,16 @@
 The plan in magic land is to get the magic roundabout working.
 
 At the moment there is a magic roundabout for each Ball.
 
 """
 import sys
 
+import inspect
+
 import random
 
 import math
 
 import io
 
 from pathlib import Path
@@ -57,211 +59,56 @@
 
 import numpy as np
 
 from PIL import Image
 
 import matplotlib
 
-from matplotlib import figure, rc, colors, patches
+from matplotlib import figure, rc
 
 from matplotlib import pyplot as plt
-from matplotlib.transforms import Bbox
-
-#from .mosaic import Carpet
 
 from blume import magic, console
-from .magic import Ball, RoundAbout, GeeFarm, fig2data, Shepherd
+from .magic import Ball, RoundAbout, Shepherd, Carpet, spawn
+
 from .mclock2 import GuidoClock
 from .rcparms import Params
+from .console import Console
 
-class PatchColours:
-
-    def __init__(self):
-        self.colours = deque(
-            ('skyblue',))
-        return
-        self.colours = deque(
-            ('skyblue', 'lightgreen', 'yellow', 'pink', 'orange'))
-
-        for extra in range(4):
-            self.colours.append(
-             [random.random()/2,
-              random.random()/2,
-              random.random()/2])
 
-    def next(self):
+class Farm(Ball):
+    """ A farm, for now.. 
 
-        self.colours.rotate()
-        return self.colours[0]
+    A network of things running around.
 
-Colours = PatchColours()
+    Magic round-abouts of queues connecting it all.
 
-class Axe:
-    """ A matplotlib axis that has some extra methods 
+    Displays, keyboards, human input, outputs.
 
-    The idea is to hand these out to anyone looking for an axis.
-    
-    By wrapping the axis object we can carry around some meta data
-    that might come in useful.
-
-    But mostly I want an Axis that I can show and hide from the figure
-    and change its layout.
+    A graph of tools.
 
-    I would like to just go with show and hide, but suspect I might need 
-    draw too.
+    And something to help it run.
     """
 
-    def __init__(self, delegate, carpet):
-
-        self.delegate = delegate
-        self.carpet = carpet
-
-    def __getattr__(self, attr):
-
-        try:
-            return getattr(self.delegate, attr)
-        except AttributeError as e:
-            # fixme:
-            #raise e
-            raise AttributeError
-
-    def position(self, target):
-        """ Set position to that of target """
-        sps = self.get_subplotspec()
-        self.set_subplotspec(target.get_subplotspec())
-
-    def show(self):
-        """ Show the axes """
-        self.set_visible(True)
-        if not hasattr(self, 'img'):
-            self._blank()
-        else:
-            self.img.set_visible(True)
-        self.carpet.show(self)
-
-    def hide(self):
-        """ Hide the axes """
-        self.set_visible(False)
-        if hasattr(self, 'img'):
-            self.img.set_visible(False)
-        self.carpet.hide(self)
-
-    def please_draw(self):
-        """ Try to force a draw of the axes """
-        print('politely asked to draw')
-        #self.draw_artist(self)
-
-    def projection(self, name):
-        """ Set the projection 
-
-        Not sure if this is possible.
-        """
-        ax = self.delegate
-        parms = dict(projection=name, visible = False)
-
-        pax = ax.figure.subplots(subplot_kw=parms)
-
-        self.delegate = pax
-        self.position(ax)
-        self.carpet.lookup[id(pax)] = self
-
-        if hasattr(ax, 'img'):
-            ax.img.remove()
-
-        # now delete ax
-        ax.remove()
-
-    def simplify(self):
-
-        #self.xaxis.set_visible(False)
-        #self.yaxis.set_visible(False)
-        self.axis('off')
-
-    def colorbar(self, mappable):
-
-        self.figure.colorbar(mappable, self)
-
-    def hide_axes(self):
-
-        self.get_xaxis().set_visible(False)
-        self.get_yaxis().set_visible(False)
-
-    def get_id(self):
-
-        return id(self.delegate)
-
-    def _blank(self):
-
-        fig = self.figure
-
-        bb = self.get_full_bbox()
-
-        self.img = patches.Rectangle(
-            bb.p0,
-            bb.width, bb.height,
-            facecolor=Colours.next()
-        )
-
-        # add patch to the background
-        self.carpet.background.add_artist(self.img)
-        
-        
-    def get_full_bbox(self):
-        # FIXME -- this needs to take account of padding of the figure
-        #  see toggle_expand
-        ss = self.get_subplotspec()
-        gs = ss.get_gridspec()
-
-        nrows, ncols = gs.get_geometry()
-
-        fig = self.figure
-        fbbox = fig.bbox
-        dpi = fig.dpi
-        spp = fig.subplotpars
-
-        # set hspace/wspace to zeo
-        hspace, wspace = spp.hspace, spp.wspace
-        spp.hspace, spp.wspace = 0., 0.
-        
-        bottoms, tops, lefts, rights = gs.get_grid_positions(fig)
-
-        # now calculate our bottom, top, left, right
-        rowstart, rowstop = ss.rowspan[0], ss.rowspan[-1]
-        colstart, colstop = ss.colspan[0], ss.colspan[-1]
-
-        top = tops[rowstart]
-        left = lefts[colstart]
-
-        bottom = bottoms[rowstop]
-        right = rights[colstop]
-
-        # adjust edge box for figure padding
-        if True:
-            if rowstart == 0:
-                top = 1.0
-            if colstart == 0:
-                left = 0
-            if rowstop == nrows-1:
-                bottom = 0.0
-            if colstop == ncols-1:
-                right = 1.0
-
-        # restore hspace, wspace in subplotparms
-        spp.hspace, spp.wspace = hspace, wspace
-
-        bbox = Bbox([[left, bottom], [right, top]])
-
-        return bbox
-
+    def __init__(self, hub=None, nodes=None, edges=None):
+        """ Turn graph into a running farm """
+        super().__init__()
+        self.pause = True
+        hub = hub or DiGraph()
 
-class Farm(GeeFarm):
+        hub.add_nodes_from(nodes or set())
+        hub.add_edges_from(edges or set())
 
-    def __init__(self):
-
-        super().__init__()
+        print('OK to here')
+        self.hub = hub
+        self.shep = Shepherd()
+
+        # register quit event with shepherd
+        self.shep.add_filter('q', self.quit)
+        print('OK to here2')
 
         # start a farm going
         carpet = Carpet()
         self.carpet = carpet
 
         clock = GuidoClock()
 
@@ -288,379 +135,142 @@
         # sheperd looking after gfarm.hub, which it is itself part of.
         self.shep.set_flock(self.hub)
 
         # initial path this needs more thought - let's do it in start()
         self.shep.set_path([self.shep, self.carpet])
 
 
-    def add(self, item):
-
-        #self.add_edge(item, self.carpet)
-        self.add_edge(self.carpet, item)
-
-        
-
-class Carpet(Ball):
-    """ FIXME This should of course be in the magic module.
-        I Can't remember why it needed to be here - probably worth
-        moving it back there, but that requires making it magic!
-
-        Current status: history just added, wormholes opened.
-
-        FIXME: figure out lifecycle of an Axe
-
-        generate_mosaic creates and adds to self.axes
-
-        Need to be able to know:
-             a. Axe has been handed out
-             b. Axe has been shown
-             c. Axe still in history
-             d. geometry -- so we can spot Axe replacing another in same spot.
         
-        Cases:  
-            handed out, still in history == keep
-            handed out, not in history, 
-
-        Deletion:
-            a. not in history
-            b. has been handed out
-            c. not in current image:  ie self.showing
-    """
-    def __init__(self):
 
-        super().__init__()
-
-        self.sleep = 0.01
+    def __getattr__(self, attr):
+        """ Delegate to hub
 
-        # grid related
-        self.size = [1, 1]  # wibni Interact operations worked sanely here
-        self.simple = False
-        self.expanded = None
-        self.output = None
-        self.showing = {}
-
-        self.history = deque(maxlen=random.randint(10, 20))
-
-        self.axes = deque()
-        self.lookup = dict()
-        #self.savefig_dpi = 3000
-        #self.image = plt.figure(constrained_layout=True, facecolor='grey')
-        self.image = plt.figure()
-        print("GOT IMAGE", self.image)
-
-        # for emscripten and html5_canvas
-        # need an easy way to use any id as the root element.
-        # for now, its 'canvas'
-        if hasattr(self.image.canvas, "create_root_element"):
-            from js import document
-            print('FIGURE CANVAS', self.image.canvas.create_root_element)
-            def create_root_element():
-                return document.getElementById('canvas')
-
-            # monkey patch
-            self.image.canvas.create_root_element = create_root_element
-        else:
-            print('CANVAS has no create_root_element')
-            
-        self.background = self.image.add_axes((0,0,1,1))
-        try:
-            plt.show(block=False)
-        except:
-            # sometimes backends have show without block parameter?  
-            plt.show()
-
-        # keyboard handling
-        self.image.canvas.mpl_connect('key_press_event', self.keypress)
-
-        # let's see everything
-        #self.log_events()
-
-        self.add_filter('+', self.more)
-        self.add_filter('=', self.more)
-        self.add_filter('-', self.less)
-        self.add_filter('a', self.add_row)
-        self.add_filter('c', self.add_column)
-
-        self.add_filter('[', self.history_back)
-        self.add_filter(']', self.history_forward)
-
-        self.add_filter('S', self.save)
-        self.add_filter('E', self.toggle_expand)
-        self.add_filter('F', self.toggle_expand2)
-        #self.add_filter(' ', self.toggle_pause)
-
-
-    def log_events(self):
-
-        events = [
-            'button_press_event',
-            'button_release_event',
-            'draw_event',
-            'key_press_event',
-            'key_release_event',
-            'motion_notify_event',
-            'pick_event',
-            'resize_event',
-            'scroll_event',
-            'figure_enter_event',
-            'figure_leave_event',
-            'axes_enter_event',
-            'axes_leave_event',
-            'close_event']
-
-        connect = self.image.canvas.mpl_connect
-        from functools import partial
-                    
-        for event in events:
-            connect(event, partial(self.log_event, name=event))
-
-    def log_event(self, event, name=None):
-
-         print(name, event)
-
-    def keypress(self, event):
-        """ Take keypress events put them out there """
-
-        #print('mosaic carpet handling', event)
-        # use select here to get actual magic curio queue
-        # where put can magically be a coroutine or a function according
-        # to context.
-        qq = self.select(event.key)
-        qq.put_nowait(event)
-
-    async def save(self):
-        """ Save current image """
-        self.image.savefig(f'carpet{datetime.datetime.now()}.png')
-        #                   dpi=self.savefig_dpi)
-
-    async def add_row(self):
-        """ add a row to the mosaic """
-        self.size[0] += 1
-        await self.rebuild()
-        
-    async def add_column(self):
-        self.size[1] += 1
-        await self.rebuild()
+        self.hub is a directed graph, so we're a Ball that is a graph
+        """
+        #print(f'farm looking for {attr}')
+        if attr == 'hub':
+            raise AttributeError
+        return getattr(self.hub, attr)
 
-    async def more(self):
-        """ Show more pictures """
-        self.size[0] += 1
-        self.size[1] += 1
-        await self.rebuild()
+    def status(self):
 
-    async def less(self):
-        """ Show fewer pictures """
-        if self.size[0] > 1:
-            self.size[0] -= 1
-        if self.size[1] > 1:
-            self.size[1] -= 1
-        await self.rebuild()    
+        print(f' nodes: {self.hub.number_of_nodes()}')
+        print(f' edges: {self.hub.number_of_edges()}')
 
-    async def rebuild(self):
-        self.hideall()
-        #self.generate_mosaic()
+        hub = self.hub
+        for item in hub.nodes:
+            print(hub[item])
 
-        print('replay history', len(self.history))
+        for edge in hub.edges:
+            print(edge, hub.edges[edge])
 
-        await self.replay_history()
+    def add(self, item):
 
-    def hideall(self):
+        #self.add_edge(item, self.carpet)
+        self.add_edge(self.carpet, item)
 
-        # hide everything currently being shown
-        for key, ax in self.showing.items():
-            ax.hide()
-            
-        self.showing.clear()
+    async def start(self):
+        """ Traverse the graph do some plumbing? 
 
-        # drain any axes waiting in self.axes
-        for ax in self.axes:
-            ax.figure.delaxes(ax.delegate)
-        self.axes.clear()
+        Let the shepherd look after the running of everything
+        """
 
-    async def history_back(self):
+        # Tell the shepherd what to look after
+        self.shep.flock = self.hub
 
-        await self.history_rotate(-1)
+        print('GEEEFAR starting shep')
+        result = self.shep.start()
+        if inspect.iscoroutine(result):
+            await result
+
+        # create a task which is a dog watching the shepherd
+        print('GEEEFAR spawning superdog')
+        self.superdog = spawn(magic.canine(self.shep))
 
-    async def history_forward(self):
+        # set the shepherd to pause 
+        self.shep.pause = True
 
-        await self.history_rotate(1)
+        # figure out an initial path
+        await self.shep.show_help()
 
-    async def history_rotate(self, n=1):
 
-        print('history', len(self.history), 'rotate', n)
+    async def run(self):
+        """ Run the farm 
 
-        if len(self.history) == 0:
-            return
-        
-        self.history.rotate(n)
+        For now, just plot the current graph.
+        """
+        print('MAGIC TREE FARM')
 
-        # we want to replace the current axes with the value we pop
-        qq = self.select()
+        # wait for the super dog
+        try:
+            await self.superdog
 
-        pos = await self.get()
-        ax = self.history.popleft()
-        ax.position(pos)
-        #ax.set_visible(True)
+        except asyncio.CancelledError:
+            print('Farm shutting down')
 
-        if pos.delegate in self.image.axes:
-            self.image.delaxes(pos.delegate)
-        del pos
 
-        ax.show()
+    async def quit(self):
+        """ quit the farm """
 
-    async def replay_history(self):
+        await self.shep.quit()
 
-        # take a copy of the current history
-        hlen = len(self.history)
+        self.superdog.cancel()
 
-        # need to throw away one axis in the queue
-        await self.get()
-        for hh in range(hlen):
-            await self.history_rotate(1)
-        
-    def toggle_expand2(self):
-        fig = self.image
 
-        fig.subplots_adjust(hspace=0, wspace=0)
-        
-    def toggle_expand(self, names=None):
-        
-        names = names or ["left", "bottom", "right", "top", "wspace", "hspace"]
+class DiGraph:
 
-        fig = self.image
-        if not self.expanded:
+    def __init__(self):
 
-            self.expanded = {}
-            for name in names:
-                self.expanded[name] = getattr(fig.subplotpars, name)
-            
-            rc('image', aspect='auto')
-
-            fig.subplots_adjust(
-               left=0, right=1,
-               bottom=0, top=1,
-               hspace=0, wspace=0)
-        else:
-            print(self.expanded)
-            fig.subplots_adjust(**self.expanded)
-            self.expanded = None
-        
-    async def poll(self):
-        """ Gui Loop """
+        self.nodes = defaultdict(dict)
+        self.edges = defaultdict(dict)
 
-        # Experiment with sleep to keep gui responsive
-        # but not a cpu hog.
-        event = 0
-
-        nap = 0.05
-        canvas = self.image.canvas
-        while True:
-            #print('RUNNING EVENT LOOP')
-            
-            canvas.flush_events()
-            canvas.start_event_loop(self.sleep)
+    def add_nodes_from(self, nodes):
 
-            await magic.sleep(self.sleep * 10)
+        for node in nodes:
+            self.add_node(node)
 
-    async def start(self):
-        
-            
-        # start some tasks to keep things ticking along
-        #watch_task = await curio.spawn(self.watch())
-        print("carpet starting tasks")
-        poll_task = magic.spawn(self.poll())
-        print('POLL TASK SPAWNED')
-        self.tasks = [poll_task]
-        print("DONE STARTED carpet")
-
-    def generate_mosaic(self):
-
-        # first try and delete some stuff
-        self.delete_old_axes()
-
-        # set up the square mosaic for current size
-        mosaic = []
-        mosaic = np.arange(self.size[0] * self.size[1])
-        mosaic = mosaic.reshape(*self.size)
-
-        keys = dict(visible=False)
-
-        picture = self.image.subplot_mosaic(mosaic, subplot_kw=keys)
-
-        for key, ax in picture.items():
-            ax.meta = dict(key=key)
-            axe = Axe(ax, self)
-            self.axes.append(axe)
-            self.lookup[id(ax)] = axe
-
-    def delete_old_axes(self):
-
-        naxes = len(self.image.axes)
-
-        showing = self.showing.values()
-        for ax in self.image.axes:
-            if ax is self.background:
-                continue
-
-            try:
-                axe = self.lookup[id(ax)]
-            except:
-                print(f'WHOA {id(ax)} {type(ax)} missing from lookup')
-                raise
-
-            if (axe not in self.history and
-                axe not in showing and
-                hasattr(axe, 'img')):
-                
-                axe.img.remove()
-                ax.figure.delaxes(ax)
-                del self.lookup[id(ax)]
-                del ax
+    def add_edges_from(self, edges):
 
+        for edge in edges:
+            self.add_edge(*edge)
 
-    async def run(self):
-        # nobody waiting for axes, don't add to the queue
-        if self.select().qsize() > 0:
-            return
+    def add_node(self, node, **keyw):
 
-        if not self.axes:
-            self.generate_mosaic()
-            
-        axe = self.axes.popleft()
-        if self.simple:
-            axe.simplify()
-            axe.grid(True)
-        await self.put(axe)
+        self.nodes[node].update(**keyw)
+    
+    def add_edge(self, a, b, **keyw):
+        
+        self.edges[(a, b)].update(**keyw)
+        for node in a, b:
+            if node not in self.nodes:
+                self.nodes[node].update(**keyw)
 
+    def succcessors(self, node):
 
-    def get_axe_geometry(self, axe):
+        result = []
+        for a, b in self.edges.keys():
+            if a is node:
+                result.append(b)
 
-        return axe.get_subplotspec().get_geometry()
+    def predecessors(self, node):
 
-    def show(self, axe):
+        result = []
+        for a, b in self.edges.keys():
+            if b is node:
+                result.append(a)
 
-        gg = self.get_axe_geometry(axe)
+    def __iter__(self):
 
-        if gg in self.showing:
-            tohide = self.showing[gg]
-            #print(f'Showing {id(tohide)} {tohide.get_visible()}')
-            if tohide is not axe:
-                tohide.hide()
+        return iter(self.nodes)
 
-        self.history.appendleft(axe)
-        
-        self.showing[gg] = axe
+    def __len__(self):
 
-        self.image.canvas.draw_idle()
-        
+        return len(self.nodes)
 
-    def hide(self, axe):
 
-        if axe.get_visible():
-            axe.set_visible(False)
 
 
 # example below ignore for now
 class MagicPlot(Ball):
     """ Use a Ball to plot.
     
     FIXME: make this one more interesting.
```

## blume/magic.py

```diff
@@ -123,15 +123,17 @@
 
 import numpy as np
 
 from PIL import Image
 
 import matplotlib
 
-from matplotlib import figure, artist
+from matplotlib.transforms import Bbox
+
+from matplotlib import figure, artist, patches, colors, rc
 
 from matplotlib import pyplot as plt
 
 from .modnar import random_colour, random_queue
 
 from . import table
 
@@ -228,15 +230,21 @@
         
         self.add_filter('z', self.sleepy)
         self.add_filter('w', self.wakey)
         #self.add_filter(' ', self.toggle_pause)
         self.add_filter('W', self.dump_roundabout)
         self.add_filter('j', self.status)
 
-    def add_filter(self, key, coro, name='keys'):
+    def add_filter(self, key=None, coro=None, name='keys'):
+
+        filters = self.filters[name]
+        if key is None:
+            for char in coro.__name__:
+                if char not in filters:
+                    key = char
 
         self.filters[name][key] = coro
 
 
     async def dump_roundabout(self):
 
         print('DUMPING ROUNDABOUT')
@@ -289,14 +297,195 @@
 
     async def start(self):
         pass
 
     async def run(self):
         pass
 
+class Axe:
+    """ A matplotlib axis that has some extra methods 
+
+    The idea is to hand these out to anyone looking for an axis.
+    
+    By wrapping the axis object we can carry around some meta data
+    that might come in useful.
+
+    But mostly I want an Axis that I can show and hide from the figure
+    and change its layout.
+
+    I would like to just go with show and hide, but suspect I might need 
+    draw too.
+    """
+
+    def __init__(self, delegate, carpet):
+
+        self.delegate = delegate
+        self.carpet = carpet
+
+    def __getattr__(self, attr):
+
+        try:
+            return getattr(self.delegate, attr)
+        except AttributeError as e:
+            # fixme:
+            #raise e
+            raise AttributeError
+
+    def position(self, target):
+        """ Set position to that of target """
+        sps = self.get_subplotspec()
+        self.set_subplotspec(target.get_subplotspec())
+
+    def show(self):
+        """ Show the axes """
+        self.set_visible(True)
+        if not hasattr(self, 'img'):
+            self._blank()
+        else:
+            self.img.set_visible(True)
+        self.carpet.show(self)
+
+    def hide(self):
+        """ Hide the axes """
+        self.set_visible(False)
+        if hasattr(self, 'img'):
+            self.img.set_visible(False)
+        self.carpet.hide(self)
+
+    def please_draw(self):
+        """ Try to force a draw of the axes """
+        print('politely asked to draw')
+        #self.draw_artist(self)
+
+    def projection(self, name):
+        """ Set the projection 
+
+        Not sure if this is possible.
+        """
+        ax = self.delegate
+        parms = dict(projection=name, visible = False)
+
+        pax = ax.figure.subplots(subplot_kw=parms)
+
+        self.delegate = pax
+        self.position(ax)
+        self.carpet.lookup[id(pax)] = self
+
+        if hasattr(ax, 'img'):
+            ax.img.remove()
+
+        # now delete ax
+        ax.remove()
+
+    def simplify(self):
+
+        #self.xaxis.set_visible(False)
+        #self.yaxis.set_visible(False)
+        self.axis('off')
+
+    def colorbar(self, mappable):
+
+        self.figure.colorbar(mappable, self)
+
+    def hide_axes(self):
+
+        self.get_xaxis().set_visible(False)
+        self.get_yaxis().set_visible(False)
+
+    def get_id(self):
+
+        return id(self.delegate)
+
+    def _blank(self):
+
+        fig = self.figure
+
+        bb = self.get_full_bbox()
+
+        self.img = patches.Rectangle(
+            bb.p0,
+            bb.width, bb.height,
+            facecolor=Colours.next()
+        )
+
+        # add patch to the background
+        self.carpet.background.add_artist(self.img)
+        
+        
+    def get_full_bbox(self):
+        # FIXME -- this needs to take account of padding of the figure
+        #  see toggle_expand
+        ss = self.get_subplotspec()
+        gs = ss.get_gridspec()
+
+        nrows, ncols = gs.get_geometry()
+
+        fig = self.figure
+        fbbox = fig.bbox
+        dpi = fig.dpi
+        spp = fig.subplotpars
+
+        # set hspace/wspace to zeo
+        hspace, wspace = spp.hspace, spp.wspace
+        spp.hspace, spp.wspace = 0., 0.
+        
+        bottoms, tops, lefts, rights = gs.get_grid_positions(fig)
+
+        # now calculate our bottom, top, left, right
+        rowstart, rowstop = ss.rowspan[0], ss.rowspan[-1]
+        colstart, colstop = ss.colspan[0], ss.colspan[-1]
+
+        top = tops[rowstart]
+        left = lefts[colstart]
+
+        bottom = bottoms[rowstop]
+        right = rights[colstop]
+
+        # adjust edge box for figure padding
+        if True:
+            if rowstart == 0:
+                top = 1.0
+            if colstart == 0:
+                left = 0
+            if rowstop == nrows-1:
+                bottom = 0.0
+            if colstop == ncols-1:
+                right = 1.0
+
+        # restore hspace, wspace in subplotparms
+        spp.hspace, spp.wspace = hspace, wspace
+
+        bbox = Bbox([[left, bottom], [right, top]])
+
+        return bbox
+
+class PatchColours:
+
+    def __init__(self):
+        self.colours = deque(
+            ('skyblue',))
+        return
+        self.colours = deque(
+            ('skyblue', 'lightgreen', 'yellow', 'pink', 'orange'))
+
+        for extra in range(4):
+            self.colours.append(
+             [random.random()/2,
+              random.random()/2,
+              random.random()/2])
+
+    def next(self):
+
+        self.colours.rotate()
+        return self.colours[0]
+
+Colours = PatchColours()
+
+    
+
 class Interact(Ball):
 
     def __init__(self, ball):
 
         super().__init__()
         
         self.history = deque()
@@ -660,164 +849,14 @@
             date = dateutil.parser.parser(value)
             return key
         except Exception as e:
             # guess it is not this one
             print(e)
             print(key, value, 'is not a date')
 
-class DiGraph:
-
-    def __init__(self):
-
-        self.nodes = defaultdict(dict)
-        self.edges = defaultdict(dict)
-
-    def add_nodes_from(self, nodes):
-
-        for node in nodes:
-            self.add_node(node)
-
-    def add_edges_from(self, edges):
-
-        for edge in edges:
-            self.add_edge(*edge)
-
-    def add_node(self, node, **keyw):
-
-        self.nodes[node].update(**keyw)
-    
-    def add_edge(self, a, b, **keyw):
-        
-        self.edges[(a, b)].update(**keyw)
-        for node in a, b:
-            if node not in self.nodes:
-                self.nodes[node].update(**keyw)
-
-    def succcessors(self, node):
-
-        result = []
-        for a, b in self.edges.keys():
-            if a is node:
-                result.append(b)
-
-    def predecessors(self, node):
-
-        result = []
-        for a, b in self.edges.keys():
-            if b is node:
-                result.append(a)
-
-    def __iter__(self):
-
-        return iter(self.nodes)
-
-    def __len__(self):
-
-        return len(self.nodes)
-
-class GeeFarm(Ball):
-    """ A farm, for now.. 
-
-    A network of things running around.
-
-    Magic round-abouts of queues connecting it all.
-
-    Displays, keyboards, human input, outputs.
-
-    A graph of tools.
-
-    And something to help it run.
-    """
-
-    def __init__(self, hub=None, nodes=None, edges=None):
-        """ Turn graph into a running farm """
-        super().__init__()
-        self.pause = True
-        hub = hub or DiGraph()
-
-        hub.add_nodes_from(nodes or set())
-        hub.add_edges_from(edges or set())
-
-        print('OK to here')
-        self.hub = hub
-        self.shep = Shepherd()
-
-        # register quit event with shepherd
-        self.shep.add_filter('q', self.quit)
-        print('OK to here2')
-
-
-    def __getattr__(self, attr):
-        """ Delegate to hub
-
-        self.hub is a directed graph, so we're a Ball that is a graph
-        """
-        #print(f'farm looking for {attr}')
-        if attr == 'hub':
-            raise AttributeError
-        return getattr(self.hub, attr)
-
-    def status(self):
-
-        print(f' nodes: {self.hub.number_of_nodes()}')
-        print(f' edges: {self.hub.number_of_edges()}')
-
-        hub = self.hub
-        for item in hub.nodes:
-            print(hub[item])
-
-        for edge in hub.edges:
-            print(edge, hub.edges[edge])
-
-    async def start(self):
-        """ Traverse the graph do some plumbing? 
-
-        Let the shepherd look after the running of everything
-        """
-
-        # Tell the shepherd what to look after
-        self.shep.flock = self.hub
-
-        print('GEEEFAR starting shep')
-        result = self.shep.start()
-        if inspect.iscoroutine(result):
-            await result
-
-        # create a task which is a dog watching the shepherd
-        print('GEEEFAR spawning superdog')
-        self.superdog = spawn(canine(self.shep))
-
-        # set the shepherd to pause 
-        self.shep.pause = True
-
-        # figure out an initial path
-
-
-    async def run(self):
-        """ Run the farm 
-
-        For now, just plot the current graph.
-        """
-        print('MAGIC TREE FARM')
-
-        # wait for the super dog
-        try:
-            await self.superdog
-
-        except asyncio.CancelledError:
-            print('Farm shutting down')
-
-
-    async def quit(self):
-        """ quit the farm """
-
-        await self.shep.quit()
-
-        self.superdog.cancel()
-
 
 modes = deque(['grey', 'white', 'black'])
 
 def fig2data(fig=None, background='grey'):
     """ Convert a Matplotlib figure to a PIL image.
 
     fig: a matplotlib figure
@@ -985,31 +1024,32 @@
         for sheep in reversed(self.path):
             #msg += repr(sheep) + '\n'
             lu = sheep.filters[name]
         
             for key, value in lu.items():
                 if key in keys:
                     continue
+
                 yield sheep, key, value
 
                 keys.add(key)
 
 
     async def show_help(self, name='keys'):
         """ Show what keys do what """
         print('HELP', self.path)
 
         # FIXME? 
-        msg = ''
+        msg = []
         for sheep, key, callback in self.generate_key_bindings(name=name):
-            msg += '{} {}\n'.format(
-                key,
-                self.doc_firstline(callback))
+            doc = self.doc_firstline(callback)
+            msg.append([key, sheep.__class__.__name__,  doc])
 
-        print(msg)
+        textmsg = '\n'.join([' '.join(x) for x in msg])
+        print(textmsg)
         # hmm -- there's a queue of help messages somewhere
         # maybe should use that for some other display.
 
         hq = self.select('help')
         if hq.qsize() < hq.maxsize - 1:
             # if the queue is getting full, then we don't want to hang here.
             # curiously, maxsize - 1 is the critical size at which it seems
@@ -1019,15 +1059,15 @@
     def doc_firstline(self, value):
         """ Return first line of doc """
 
         doc = value.__doc__
         if doc:
             return doc.split('\n')[0]
         else:
-            return repr(value)
+            return value.__name__
             #return "????"
 
     async def helper(self):
         """ Task to run if you want help on the carpet 
 
         One day it will be easy to start and stop this.
         """
@@ -1036,70 +1076,30 @@
         print('xxHELPER STARTING UPxx')
         while True:
             msg = await self.get('help')
             ax = await self.get()
             try:
                 if isinstance(msg, str):
                     msg = [[msg]]
+
+                widths = get_widths(msg)
                 tab = table.table(
                     ax.delegate, cellText=msg, bbox=(0,0,1,1),
-                    cellLoc='center')
+                    cellLoc='center',
+                    colWidths=widths)
 
                 foo = tab[0,0]
                 foo.set_text_props(multialignment='left')
             except:
                 print("HELPER CAUGHT AN EXCEPTION")
                 print_exc()
                 continue
 
             ax.axis('off')
             ax.show()
-            continue
-            
-            fontsize = 6
-            prop = dict(size=fontsize)
-            grid = Grid([[msg]], prop=prop)
-            #grid.set_visible(False)
-            #ax.text(0., 0., msg)
-            #        verticalalignment='center',
-            #        horizontalalignment='center',
-            #        transform=ax.transAxes)
-            #ax.axis('off')
-            renderer = ax.figure._cachedRenderer
-
-            grid.figure = ax.figure
-            ax.axis('off')
-            ax.add_artist(grid)
-        
-            if renderer:
-                try:
-                    #print('FONT SCALING')
-                    extent = grid.get_window_extent(renderer)
-                    #print('WINDOW EXTENT', extent)
-                    ax_extent = ax.get_window_extent(renderer)
-                    #print('AXES EXTENT  ', ax_extent)
-                    #print(ax_extent.x1 - ax_extent.x0)
-                    #print(extent.x1 - extent.x0)
-                    xfontscale = (ax_extent.x1 - ax_extent.x0) / (extent.x1 - extent.x0)
-                    yfontscale = (ax_extent.y1 - ax_extent.y0) / (extent.y1 - extent.y0)
-                    fontscale = min(xfontscale, yfontscale) * 0.9
-
-                    prop['size'] *= fontscale
-                    grid.remove()
-                    grid = Grid([[msg]], prop=prop)
-                    ax.add_artist(grid)
-
-                    #print('scaled by', fontscale, xfontscale, yfontscale)
-                    #print('bbox after scaling')
-                    #print(grid.get_window_extent(renderer))
-                except:
-                    print_exc()
-                        
-            print('showing help axes')
-            ax.show()
 
 
     async def start(self):
         """ Start things going 
 
         FIXME: make it simple
         """
@@ -1295,14 +1295,30 @@
         #        print(task)
         
 
     def __str__(self):
 
         return f'shepherd of flock degree {len(self.flock)}'
 
+def get_widths(msg):
+
+    # find max len of string for each column
+    ncols = len(msg[0])
+
+    widths = []
+    for col in range(ncols):
+        widths.append(max([len(x[col]) for x in msg]) + 3)
+
+    # now normalise
+    total = sum(widths)
+    widths = [x/total for x in widths]
+    print('WWWWWWWWWWWW', widths)
+    return widths
+
+    
 class IdleRunner:
 
     def __init__(self, filename):
 
         self.filename = filename
 
     def __call__(self):
@@ -1326,30 +1342,375 @@
         self.meta_data = meta_data
         
         """ now what?  look at data with a magic spell and get meta data.
         
         
         """
 
-class Carpet(Ball):
 
+class Carpet(Ball):
+    """ FIXME This should of course be in the magic module.
+        I Can't remember why it needed to be here - probably worth
+        moving it back there, but that requires making it magic!
+
+        Current status: history just added, wormholes opened.
+
+        FIXME: figure out lifecycle of an Axe
+
+        generate_mosaic creates and adds to self.axes
+
+        Need to be able to know:
+             a. Axe has been handed out
+             b. Axe has been shown
+             c. Axe still in history
+             d. geometry -- so we can spot Axe replacing another in same spot.
+        
+        Cases:  
+            handed out, still in history == keep
+            handed out, not in history, 
+
+        Deletion:
+            a. not in history
+            b. has been handed out
+            c. not in current image:  ie self.showing
+    """
     def __init__(self):
 
         super().__init__()
 
-        self.fig = plt.figure(layout='constrained')
+        self.sleep = 0.01
 
-    def __getattr__(self, attr):
+        # grid related
+        self.size = [1, 1]  # wibni Interact operations worked sanely here
+        self.simple = False
+        self.expanded = None
+        self.output = None
+        self.showing = {}
+
+        self.history = deque(maxlen=random.randint(10, 20))
+
+        self.axes = deque()
+        self.lookup = dict()
+        #self.savefig_dpi = 3000
+        #self.image = plt.figure(constrained_layout=True, facecolor='grey')
+        self.image = plt.figure()
+        print("GOT IMAGE", self.image)
+
+        # for emscripten and html5_canvas
+        # need an easy way to use any id as the root element.
+        # for now, its 'canvas'
+        if hasattr(self.image.canvas, "create_root_element"):
+            from js import document
+            print('FIGURE CANVAS', self.image.canvas.create_root_element)
+            def create_root_element():
+                return document.getElementById('canvas')
+
+            # monkey patch
+            self.image.canvas.create_root_element = create_root_element
+        else:
+            print('CANVAS has no create_root_element')
+            
+        self.background = self.image.add_axes((0,0,1,1))
+        try:
+            plt.show(block=False)
+        except:
+            # sometimes backends have show without block parameter?  
+            plt.show()
+
+        # keyboard handling
+        self.image.canvas.mpl_connect('key_press_event', self.keypress)
+
+        # let's see everything
+        #self.log_events()
+
+        self.add_filter('+', self.more)
+        self.add_filter('=', self.more)
+        self.add_filter('-', self.less)
+        self.add_filter('a', self.add_row)
+        self.add_filter('c', self.add_column)
+
+        self.add_filter('[', self.history_back)
+        self.add_filter(']', self.history_forward)
+
+        self.add_filter('S', self.save)
+        self.add_filter('E', self.toggle_expand)
+        self.add_filter('F', self.toggle_expand2)
+        #self.add_filter(' ', self.toggle_pause)
+
+
+    def log_events(self):
+
+        events = [
+            'button_press_event',
+            'button_release_event',
+            'draw_event',
+            'key_press_event',
+            'key_release_event',
+            'motion_notify_event',
+            'pick_event',
+            'resize_event',
+            'scroll_event',
+            'figure_enter_event',
+            'figure_leave_event',
+            'axes_enter_event',
+            'axes_leave_event',
+            'close_event']
+
+        connect = self.image.canvas.mpl_connect
+        from functools import partial
+                    
+        for event in events:
+            connect(event, partial(self.log_event, name=event))
+
+    def log_event(self, event, name=None):
+
+         print(name, event)
+
+    def keypress(self, event):
+        """ Take keypress events put them out there """
+
+        #print('mosaic carpet handling', event)
+        # use select here to get actual magic curio queue
+        # where put can magically be a coroutine or a function according
+        # to context.
+        qq = self.select(event.key)
+        qq.put_nowait(event)
+
+    async def save(self):
+        """ Save current image """
+        self.image.savefig(f'carpet{datetime.datetime.now()}.png')
+        #                   dpi=self.savefig_dpi)
+
+    async def add_row(self):
+        """ add a row to the mosaic """
+        self.size[0] += 1
+        await self.rebuild()
+        
+    async def add_column(self):
+        self.size[1] += 1
+        await self.rebuild()
+
+    async def more(self):
+        """ Show more pictures """
+        self.size[0] += 1
+        self.size[1] += 1
+        await self.rebuild()
+
+    async def less(self):
+        """ Show fewer pictures """
+        if self.size[0] > 1:
+            self.size[0] -= 1
+        if self.size[1] > 1:
+            self.size[1] -= 1
+        await self.rebuild()    
+
+    async def rebuild(self):
+        self.hideall()
+        #self.generate_mosaic()
+
+        print('replay history', len(self.history))
+
+        await self.replay_history()
+
+    def hideall(self):
+
+        # hide everything currently being shown
+        for key, ax in self.showing.items():
+            ax.hide()
+            
+        self.showing.clear()
+
+        # drain any axes waiting in self.axes
+        for ax in self.axes:
+            ax.figure.delaxes(ax.delegate)
+        self.axes.clear()
+
+    async def history_back(self):
+
+        await self.history_rotate(-1)
+
+    async def history_forward(self):
+
+        await self.history_rotate(1)
+
+    async def history_rotate(self, n=1):
+
+        #print('history', len(self.history), 'rotate', n)
+
+        if len(self.history) == 0:
+            return
+        
+        self.history.rotate(n)
+
+        # we want to replace the current axes with the value we pop
+        qq = self.select()
+
+        pos = await self.get()
+        ax = self.history.popleft()
+        ax.position(pos)
+        #ax.set_visible(True)
+
+        if pos.delegate in self.image.axes:
+            self.image.delaxes(pos.delegate)
+        del pos
+
+        ax.show()
+
+    async def replay_history(self):
+
+        # take a copy of the current history
+        hlen = len(self.history)
+
+        # need to throw away one axis in the queue
+        await self.get()
+        for hh in range(hlen):
+            await self.history_rotate(1)
+        
+    def toggle_expand2(self):
+        """ ask figure to expand the axes to fill the space """
+        fig = self.image
+
+        fig.subplots_adjust(hspace=0, wspace=0)
+        
+    def toggle_expand(self, names=None):
+        """ Toggle making each axis fill its space """
+        names = names or ["left", "bottom", "right", "top", "wspace", "hspace"]
+
+        fig = self.image
+        if not self.expanded:
+
+            self.expanded = {}
+            for name in names:
+                self.expanded[name] = getattr(fig.subplotpars, name)
+            
+            rc('image', aspect='auto')
+
+            fig.subplots_adjust(
+               left=0, right=1,
+               bottom=0, top=1,
+               hspace=0, wspace=0)
+        else:
+            print(self.expanded)
+            fig.subplots_adjust(**self.expanded)
+            self.expanded = None
+        
+    async def poll(self):
+        """ Gui Loop """
+
+        # Experiment with sleep to keep gui responsive
+        # but not a cpu hog.
+        event = 0
+
+        nap = 0.05
+        canvas = self.image.canvas
+        while True:
+            #print('RUNNING EVENT LOOP')
+            
+            canvas.flush_events()
+            canvas.start_event_loop(self.sleep)
+
+            await sleep(self.sleep * 10)
+
+    async def start(self):
+        
+            
+        # start some tasks to keep things ticking along
+        #watch_task = await curio.spawn(self.watch())
+        print("carpet starting tasks")
+        poll_task = spawn(self.poll())
+        print('POLL TASK SPAWNED')
+        self.tasks = [poll_task]
+        print("DONE STARTED carpet")
+
+    def generate_mosaic(self):
+
+        # first try and delete some stuff
+        self.delete_old_axes()
+
+        # set up the square mosaic for current size
+        mosaic = []
+        mosaic = np.arange(self.size[0] * self.size[1])
+        mosaic = mosaic.reshape(*self.size)
+
+        keys = dict(visible=False)
+
+        picture = self.image.subplot_mosaic(mosaic, subplot_kw=keys)
+
+        for key, ax in picture.items():
+            ax.meta = dict(key=key)
+            axe = Axe(ax, self)
+            self.axes.append(axe)
+            self.lookup[id(ax)] = axe
+
+    def delete_old_axes(self):
+
+        naxes = len(self.image.axes)
+
+        showing = self.showing.values()
+        for ax in self.image.axes:
+            if ax is self.background:
+                continue
+
+            try:
+                axe = self.lookup[id(ax)]
+            except:
+                print(f'WHOA {id(ax)} {type(ax)} missing from lookup')
+                raise
+
+            if (axe not in self.history and
+                axe not in showing and
+                hasattr(axe, 'img')):
+                
+                axe.img.remove()
+                ax.figure.delaxes(ax)
+                del self.lookup[id(ax)]
+                del ax
 
-        return getattr(self.fig)
 
     async def run(self):
+        # nobody waiting for axes, don't add to the queue
+        if self.select().qsize() > 0:
+            return
 
-        await self.put(self)
+        if not self.axes:
+            self.generate_mosaic()
+            
+        axe = self.axes.popleft()
+        if self.simple:
+            axe.simplify()
+            axe.grid(True)
+        await self.put(axe)
+
+
+    def get_axe_geometry(self, axe):
+
+        return axe.get_subplotspec().get_geometry()
+
+    def show(self, axe):
+
+        gg = self.get_axe_geometry(axe)
+
+        if gg in self.showing:
+            tohide = self.showing[gg]
+            #print(f'Showing {id(tohide)} {tohide.get_visible()}')
+            if tohide is not axe:
+                tohide.hide()
 
+        self.history.appendleft(axe)
+        
+        self.showing[gg] = axe
+
+        self.image.canvas.draw_idle()
+        
+
+    def hide(self, axe):
+
+        if axe.get_visible():
+            axe.set_visible(False)
+        
 
 async def canine(ball):
     """ A sheep dog, something to control when it pauses and sleeps
 
     runner for node.run and more
 
     This was an an attempt to factor out some boiler plate from 
@@ -1381,15 +1742,15 @@
                     #print(f'canine awaits result {runs} for {ball}')
                     await result
             
                 runs += 1
 
                 await sleep(ball.sleep)
             except asyncio.CancelledError:
-                print(f'cancelled running of {ball}')
+                print(f'cancelled running of {ball} after {runs} runs')
                 raise
 
             except:
                 print_exc()
                 raise
```

## blume/mb.py

```diff
@@ -216,17 +216,15 @@
     farm.add(mandy)
     #farm.add(milky)
 
     # farm strageness, whilst I figure out how it should work
     # add to path to get key events at start 
     farm.shep.path.append(mandy)
 
-    await farm.start()
-
-    await farm.run()
+    fm.run(farm)
 
 
 
 if __name__ == '__main__':
 
     parser = argparse.ArgumentParser()
     parser.add_argument('-random', action='store_true')
```

## blume/train.py

```diff
@@ -29,21 +29,43 @@
         super().__init__()
         
         self.path = Path(path)
         self.scale = 0
         self.size = 1024
         self.rotation = -1
         self.clip = None
+        self.min_entropy = .0
 
-        self.boost = 20
+        self.boost = 0
 
         def reverse():
             """ U turn if U want 2 """
             self.rotation *= -1
         self.add_filter('u', reverse)
+        self.add_filter('d', self.down)
+        self.add_filter('b', self.back)
+
+
+    async def down(self):
+
+        choices = [x for x in self.path.glob('*') if x.is_dir()]
+
+        if not choices:
+            print(self.path, 'has no sub directories')
+
+        else:
+            # pick at rando from choices
+            self.path = random.choice(choices)
+            print(self.path)
+            await self.start()
+        
+    async def back(self):
+        self.path = self.path.parent
+        print(self.path)
+        await self.start()
 
     async def start(self):
 
         if self.path.is_file():
             self.paths = [self.path]
         else:
             path = Path(self.path)
@@ -77,15 +99,14 @@
         if str(path) in self.bads:
             return
 
         try:
             image = Image.open(path)
         except:
             print('BAD ONE', path)
-            traceback.print_exc(limit=20)
             self.bads.add(str(path))
             return
 
 
         w, h = image.size
 
         scale = self.scale
@@ -98,16 +119,25 @@
 
         if self.clip:
 
             image = np.clip(image, 0, self.clip)
 
         if self.boost:
             image = self.booster(image)
-        
-        print('publishing', path, image.size, 'entropy:', image.entropy())
+
+        mininfo = self.min_entropy
+        if mininfo:
+            entropy = image.entropy()
+            if entropy < mininfo:
+                print('skipping  ', path, image.size, 'entropy:', entropy)
+                return
+            else:
+                print('publishing', path, image.size, 'entropy:', entropy)
+        else:
+            print('publishing', path, image.size)
 
         ax = await self.get()
         ax.axis('off')
         ax.imshow(image, cmap=magic.random_colour())
         
         ax.show()
```

## Comparing `blume-0.2.5.3.dist-info/LICENSE` & `blume-0.2.5.4.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `blume-0.2.5.3.dist-info/METADATA` & `blume-0.2.5.4.dist-info/METADATA`

 * *Files 1% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: blume
-Version: 0.2.5.3
+Version: 0.2.5.4
 Summary: Better looking tables for matplotlib
 Home-page: https://github.com/swfiua/blume
 Author: The Matplotlib Team, John Hunter, Johnny Gill
 Author-email: swfiua@gmail.com
 License: Matplotlib
 Keywords: matplotlib table
 Platform: UNKNOWN
```

## Comparing `blume-0.2.5.3.dist-info/RECORD` & `blume-0.2.5.4.dist-info/RECORD`

 * *Files 19% similar despite different names*

```diff
@@ -3,31 +3,31 @@
 blume/cod.py,sha256=k53ptYbLyUNVh5mYw6cW5gjIBPMRnz8yUTc1zfhLJUs,3127
 blume/console.py,sha256=6gIDg6BxN9pkvXlZZkNVdtZXOigfIGrBOakz-WjBQo0,2982
 blume/cpr.py,sha256=4Sb1KAeivgWkR3rInAJ6bvGEE4nQFZy9ZvHoRQwET6Q,13610
 blume/dataklasses.py,sha256=mEqLpzYMya5TXfk46IbfukodGHSjPUwHSUbNhtYioFk,7571
 blume/docs.py,sha256=MywT5uFjfBSDJUiacJvtFoytkisDRcCBlEaBdGODqLE,704
 blume/dss.py,sha256=e0LBweyet0ly2RFM0rFAnD8hLLH2ZkhaztI0yTuHLsU,3660
 blume/eggshow.py,sha256=wzS7-DN6t7xIGd3v2ZDHRgi2snZd7g7asmNeLycXpfg,2746
-blume/farm.py,sha256=sQ66Pb43QY4qnyudsyhc-zJZ3MVS8tUptLtQvoi15Hs,18465
+blume/farm.py,sha256=b4dnSZZaANhXGynUX6b-zJxQVf4MoiZZDpWMiAkWFHU,7423
 blume/gaia.py,sha256=YYWR7wbeUTAg-dW_ALxFPYjmVF5lPPCkiMUHla63Wds,10886
 blume/gw.py,sha256=7XUI8txVpiyKS5UH3FDbWDFKecp2YDcAnWAFGTxvPWw,2244
 blume/legend.py,sha256=LA_bbnNMwkOYhopwQ245uXuWIAZcJsVAwNYCi--Af48,8423
-blume/magic.py,sha256=EY_RM4MKd2bUigfNdAYFqgqfCRG2ePEd3_9JDLlTPTM,36755
+blume/magic.py,sha256=XlpjHvDrbWhuvLUCXKgu9vImnLCY-s_9VTBBB7tiDq0,46619
 blume/magic2.py,sha256=m5tnvRHjWye1eg4eqV8zURnMcl6vcLLVk3bO5vKjuxQ,3823
-blume/mb.py,sha256=EPZibDhRaMORtEbyesFgFB2OLwyo08jWTTMbIflHatA,5140
+blume/mb.py,sha256=xMxEOEFoIeheOVUiVsVW64GEzMKMp0mUrbugXCkUb7U,5112
 blume/mclock2.py,sha256=_quou6t6hGcnbNsKWQCbYJ9ktOIOyU1Zzo_o_ceJFpc,7429
 blume/metagit.py,sha256=-1VSQiL3iVtR2_Qz1Zn5LCkOoqgELTaE5nqQ5Aq7HOo,3669
 blume/modnar.py,sha256=yyxi7VAFbf6ZMHj_1KFF0Vene0DwOvQr903wf27rqwc,611
 blume/mosaic.py,sha256=Ai67HEQ5Ej4CVL-IIXREhvugWAAlYj5IO0L0z7xsREk,4351
 blume/noligo.py,sha256=UNNBt8Wl1j1gSDjghzY2Sii-Lsz9csPlPk9FxiwFzY0,1392
 blume/rcparms.py,sha256=DwUVv645aO1GI5l5pjbVA4E3ia6pDNTTdwzS5_aQbyY,1427
 blume/table.py,sha256=NKwekXXQ9f0aVu156ps7WJnZWrKZZZZsWkuf3cByJRM,31302
 blume/taybell.py,sha256=Hdw93lHtOJIU4bpZ49mcVC1cGKsH6WoS4rzNVwvULzo,4540
 blume/teakhat.py,sha256=AKJXmSBSrEB7WKHSsGXuZfPlLWladXqklCwkAWpxfUY,3427
-blume/train.py,sha256=QYhWj9Q3J4gotCCifpaL6Rszj0u60JH1xWsWJyO2qD8,3201
+blume/train.py,sha256=0oJ4mzGJuo2CZOIFdG2Y4ZFMU0AcWaeNhSXUFFbmBTI,4028
 blume/twins.py,sha256=oPbRkoD6_nyG4kjiCB_m4L1GjlElvwPntSxt4DZodYg,321
 blume/balls/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 blume/balls/sudoku.py,sha256=NS2PMi25LNzzz57eiEsG27ppOCaK2JGn_fd5rSmz0aE,3609
 blume/examples/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 blume/examples/chess_table.py,sha256=jzhhWD75JhNSWXnPmF0DeqB0x8GLCLiKUVul0GIhMuw,1871
 blume/examples/cod.py,sha256=n3zqajgIqxo7PvheQyiOAEuJpbaheJ0hgSy9XG4ePuw,15192
 blume/examples/cpr.py,sha256=aysTt9HGDdI6F-70TFT-bPlj9ZzbeMI89y1KcTbQKII,3182
@@ -35,13 +35,13 @@
 blume/examples/iyield.py,sha256=CEQsP9y5Dh656DrOyf2oFGuYQ9HRM9wuaus93RQVLeM,875
 blume/examples/legendary.py,sha256=1qr6tVqIW714moigRKXexhhJ2pUsn4iPc8qyQE2FCRI,2780
 blume/examples/ligoview.py,sha256=O5yx84oMIWFBBhb0UTj6--vKHKDMrwUJ6IRsqgDPK-c,1208
 blume/examples/multiline.py,sha256=RNU0iz0qCK5siIzl4-gd8AR8qzvV40WIUQg9-5JUDDo,555
 blume/examples/shortify.py,sha256=q6Ri6w9VlXuxd03Wc3yXZbKlAktlng8cyMUMKwTeesk,567
 blume/examples/show.py,sha256=O5yx84oMIWFBBhb0UTj6--vKHKDMrwUJ6IRsqgDPK-c,1208
 blume/examples/table_demo.py,sha256=osw4MQbd50YlF3nXifTmouU6lfdNAyCflqBYj-S7Uso,1687
-blume-0.2.5.3.dist-info/LICENSE,sha256=WhqB6jAXKMi7opM9qDLAzWIina8giToCSrPVMkRGjbw,4830
-blume-0.2.5.3.dist-info/METADATA,sha256=_4u9Dlp7gmXTCCORIWcfByAbWM-4Fj0mZUPDU8XbUZA,2665
-blume-0.2.5.3.dist-info/WHEEL,sha256=G16H4A3IeoQmnOrYV4ueZGKSjhipXx8zc8nu9FGlvMA,92
-blume-0.2.5.3.dist-info/dependency_links.txt,sha256=fjX3xDlFYONxFI0p8GEIs8FkUh8yxJSwz7nG0Hj1Pkg,19
-blume-0.2.5.3.dist-info/top_level.txt,sha256=tr0vvX_VuW05wnTP3Xnd0Y45PheI1lN8cHh-c8nW7Xc,6
-blume-0.2.5.3.dist-info/RECORD,,
+blume-0.2.5.4.dist-info/LICENSE,sha256=WhqB6jAXKMi7opM9qDLAzWIina8giToCSrPVMkRGjbw,4830
+blume-0.2.5.4.dist-info/METADATA,sha256=tpXHldjA7Qj_AGxjqhFdoh1zzUsNciTm2W3TGqcWYPU,2665
+blume-0.2.5.4.dist-info/WHEEL,sha256=G16H4A3IeoQmnOrYV4ueZGKSjhipXx8zc8nu9FGlvMA,92
+blume-0.2.5.4.dist-info/dependency_links.txt,sha256=fjX3xDlFYONxFI0p8GEIs8FkUh8yxJSwz7nG0Hj1Pkg,19
+blume-0.2.5.4.dist-info/top_level.txt,sha256=tr0vvX_VuW05wnTP3Xnd0Y45PheI1lN8cHh-c8nW7Xc,6
+blume-0.2.5.4.dist-info/RECORD,,
```

